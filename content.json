{"pages":[{"title":"","text":"/* latin-ext */ @font-face { font-family: 'Source Code Pro'; font-style: normal; font-weight: 400; src: local('Source Code Pro'), local('SourceCodePro-Regular'), url(/fonts/sourcecodepro/v9/HI_SiYsKILxRpg3hIP6sJ7fM7PqlM-vWnsUnxlC9.woff2) format('woff2'); unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* latin */ @font-face { font-family: 'Source Code Pro'; font-style: normal; font-weight: 400; src: local('Source Code Pro'), local('SourceCodePro-Regular'), url(/fonts/sourcecodepro/v9/HI_SiYsKILxRpg3hIP6sJ7fM7PqlPevWnsUnxg.woff2) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; } /* cyrillic-ext */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKcg72nU6AF7xm.woff2) format('woff2'); unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F; } /* cyrillic */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKew72nU6AF7xm.woff2) format('woff2'); unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116; } /* greek-ext */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKcw72nU6AF7xm.woff2) format('woff2'); unicode-range: U+1F00-1FFF; } /* greek */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKfA72nU6AF7xm.woff2) format('woff2'); unicode-range: U+0370-03FF; } /* latin-ext */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKcQ72nU6AF7xm.woff2) format('woff2'); unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* latin */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKfw72nU6AFw.woff2) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; }","link":"/fonts/css.css"},{"title":"","text":"/*! * Font Awesome Free 5.4.1 by @fontawesome - https://fontawesome.com * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) */ .fa,.fab,.fal,.far,.fas { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; display: inline-block; font-style: normal; font-variant: normal; text-rendering: auto; line-height: 1 } .fa-lg { font-size: 1.33333em; line-height: .75em; vertical-align: -.0667em } .fa-xs { font-size: .75em } .fa-sm { font-size: .875em } .fa-1x { font-size: 1em } .fa-2x { font-size: 2em } .fa-3x { font-size: 3em } .fa-4x { font-size: 4em } .fa-5x { font-size: 5em } .fa-6x { font-size: 6em } .fa-7x { font-size: 7em } .fa-8x { font-size: 8em } .fa-9x { font-size: 9em } .fa-10x { font-size: 10em } .fa-fw { text-align: center; width: 1.25em } .fa-ul { list-style-type: none; margin-left: 2.5em; padding-left: 0 } .fa-ul>li { position: relative } .fa-li { left: -2em; position: absolute; text-align: center; width: 2em; line-height: inherit } .fa-border { border: .08em solid #eee; border-radius: .1em; padding: .2em .25em .15em } .fa-pull-left { float: left } .fa-pull-right { float: right } .fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left { margin-right: .3em } .fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right { margin-left: .3em } .fa-spin { animation: fa-spin 2s infinite linear } .fa-pulse { animation: fa-spin 1s infinite steps(8) } @keyframes fa-spin { 0% { transform: rotate(0deg) } to { transform: rotate(1turn) } } .fa-rotate-90 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\"; transform: rotate(90deg) } .fa-rotate-180 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\"; transform: rotate(180deg) } .fa-rotate-270 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\"; transform: rotate(270deg) } .fa-flip-horizontal { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\"; transform: scaleX(-1) } .fa-flip-vertical { transform: scaleY(-1) } .fa-flip-horizontal.fa-flip-vertical,.fa-flip-vertical { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\" } .fa-flip-horizontal.fa-flip-vertical { transform: scale(-1) } :root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270 { -webkit-filter: none; filter: none } .fa-stack { display: inline-block; height: 2em; line-height: 2em; position: relative; vertical-align: middle; width: 2em } .fa-stack-1x,.fa-stack-2x { left: 0; position: absolute; text-align: center; width: 100% } .fa-stack-1x { line-height: inherit } .fa-stack-2x { font-size: 2em } .fa-inverse { color: #fff } .fa-500px:before { content: \"\\f26e\" } .fa-accessible-icon:before { content: \"\\f368\" } .fa-accusoft:before { content: \"\\f369\" } .fa-acquisitions-incorporated:before { content: \"\\f6af\" } .fa-ad:before { content: \"\\f641\" } .fa-address-book:before { content: \"\\f2b9\" } .fa-address-card:before { content: \"\\f2bb\" } .fa-adjust:before { content: \"\\f042\" } .fa-adn:before { content: \"\\f170\" } .fa-adversal:before { content: \"\\f36a\" } .fa-affiliatetheme:before { content: \"\\f36b\" } .fa-air-freshener:before { content: \"\\f5d0\" } .fa-algolia:before { content: \"\\f36c\" } .fa-align-center:before { content: \"\\f037\" } .fa-align-justify:before { content: \"\\f039\" } .fa-align-left:before { content: \"\\f036\" } .fa-align-right:before { content: \"\\f038\" } .fa-alipay:before { content: \"\\f642\" } .fa-allergies:before { content: \"\\f461\" } .fa-amazon:before { content: \"\\f270\" } .fa-amazon-pay:before { content: \"\\f42c\" } .fa-ambulance:before { content: \"\\f0f9\" } .fa-american-sign-language-interpreting:before { content: \"\\f2a3\" } .fa-amilia:before { content: \"\\f36d\" } .fa-anchor:before { content: \"\\f13d\" } .fa-android:before { content: \"\\f17b\" } .fa-angellist:before { content: \"\\f209\" } .fa-angle-double-down:before { content: \"\\f103\" } .fa-angle-double-left:before { content: \"\\f100\" } .fa-angle-double-right:before { content: \"\\f101\" } .fa-angle-double-up:before { content: \"\\f102\" } .fa-angle-down:before { content: \"\\f107\" } .fa-angle-left:before { content: \"\\f104\" } .fa-angle-right:before { content: \"\\f105\" } .fa-angle-up:before { content: \"\\f106\" } .fa-angry:before { content: \"\\f556\" } .fa-angrycreative:before { content: \"\\f36e\" } .fa-angular:before { content: \"\\f420\" } .fa-ankh:before { content: \"\\f644\" } .fa-app-store:before { content: \"\\f36f\" } .fa-app-store-ios:before { content: \"\\f370\" } .fa-apper:before { content: \"\\f371\" } .fa-apple:before { content: \"\\f179\" } .fa-apple-alt:before { content: \"\\f5d1\" } .fa-apple-pay:before { content: \"\\f415\" } .fa-archive:before { content: \"\\f187\" } .fa-archway:before { content: \"\\f557\" } .fa-arrow-alt-circle-down:before { content: \"\\f358\" } .fa-arrow-alt-circle-left:before { content: \"\\f359\" } .fa-arrow-alt-circle-right:before { content: \"\\f35a\" } .fa-arrow-alt-circle-up:before { content: \"\\f35b\" } .fa-arrow-circle-down:before { content: \"\\f0ab\" } .fa-arrow-circle-left:before { content: \"\\f0a8\" } .fa-arrow-circle-right:before { content: \"\\f0a9\" } .fa-arrow-circle-up:before { content: \"\\f0aa\" } .fa-arrow-down:before { content: \"\\f063\" } .fa-arrow-left:before { content: \"\\f060\" } .fa-arrow-right:before { content: \"\\f061\" } .fa-arrow-up:before { content: \"\\f062\" } .fa-arrows-alt:before { content: \"\\f0b2\" } .fa-arrows-alt-h:before { content: \"\\f337\" } .fa-arrows-alt-v:before { content: \"\\f338\" } .fa-assistive-listening-systems:before { content: \"\\f2a2\" } .fa-asterisk:before { content: \"\\f069\" } .fa-asymmetrik:before { content: \"\\f372\" } .fa-at:before { content: \"\\f1fa\" } .fa-atlas:before { content: \"\\f558\" } .fa-atom:before { content: \"\\f5d2\" } .fa-audible:before { content: \"\\f373\" } .fa-audio-description:before { content: \"\\f29e\" } .fa-autoprefixer:before { content: \"\\f41c\" } .fa-avianex:before { content: \"\\f374\" } .fa-aviato:before { content: \"\\f421\" } .fa-award:before { content: \"\\f559\" } .fa-aws:before { content: \"\\f375\" } .fa-backspace:before { content: \"\\f55a\" } .fa-backward:before { content: \"\\f04a\" } .fa-balance-scale:before { content: \"\\f24e\" } .fa-ban:before { content: \"\\f05e\" } .fa-band-aid:before { content: \"\\f462\" } .fa-bandcamp:before { content: \"\\f2d5\" } .fa-barcode:before { content: \"\\f02a\" } .fa-bars:before { content: \"\\f0c9\" } .fa-baseball-ball:before { content: \"\\f433\" } .fa-basketball-ball:before { content: \"\\f434\" } .fa-bath:before { content: \"\\f2cd\" } .fa-battery-empty:before { content: \"\\f244\" } .fa-battery-full:before { content: \"\\f240\" } .fa-battery-half:before { content: \"\\f242\" } .fa-battery-quarter:before { content: \"\\f243\" } .fa-battery-three-quarters:before { content: \"\\f241\" } .fa-bed:before { content: \"\\f236\" } .fa-beer:before { content: \"\\f0fc\" } .fa-behance:before { content: \"\\f1b4\" } .fa-behance-square:before { content: \"\\f1b5\" } .fa-bell:before { content: \"\\f0f3\" } .fa-bell-slash:before { content: \"\\f1f6\" } .fa-bezier-curve:before { content: \"\\f55b\" } .fa-bible:before { content: \"\\f647\" } .fa-bicycle:before { content: \"\\f206\" } .fa-bimobject:before { content: \"\\f378\" } .fa-binoculars:before { content: \"\\f1e5\" } .fa-birthday-cake:before { content: \"\\f1fd\" } .fa-bitbucket:before { content: \"\\f171\" } .fa-bitcoin:before { content: \"\\f379\" } .fa-bity:before { content: \"\\f37a\" } .fa-black-tie:before { content: \"\\f27e\" } .fa-blackberry:before { content: \"\\f37b\" } .fa-blender:before { content: \"\\f517\" } .fa-blender-phone:before { content: \"\\f6b6\" } .fa-blind:before { content: \"\\f29d\" } .fa-blogger:before { content: \"\\f37c\" } .fa-blogger-b:before { content: \"\\f37d\" } .fa-bluetooth:before { content: \"\\f293\" } .fa-bluetooth-b:before { content: \"\\f294\" } .fa-bold:before { content: \"\\f032\" } .fa-bolt:before { content: \"\\f0e7\" } .fa-bomb:before { content: \"\\f1e2\" } .fa-bone:before { content: \"\\f5d7\" } .fa-bong:before { content: \"\\f55c\" } .fa-book:before { content: \"\\f02d\" } .fa-book-dead:before { content: \"\\f6b7\" } .fa-book-open:before { content: \"\\f518\" } .fa-book-reader:before { content: \"\\f5da\" } .fa-bookmark:before { content: \"\\f02e\" } .fa-bowling-ball:before { content: \"\\f436\" } .fa-box:before { content: \"\\f466\" } .fa-box-open:before { content: \"\\f49e\" } .fa-boxes:before { content: \"\\f468\" } .fa-braille:before { content: \"\\f2a1\" } .fa-brain:before { content: \"\\f5dc\" } .fa-briefcase:before { content: \"\\f0b1\" } .fa-briefcase-medical:before { content: \"\\f469\" } .fa-broadcast-tower:before { content: \"\\f519\" } .fa-broom:before { content: \"\\f51a\" } .fa-brush:before { content: \"\\f55d\" } .fa-btc:before { content: \"\\f15a\" } .fa-bug:before { content: \"\\f188\" } .fa-building:before { content: \"\\f1ad\" } .fa-bullhorn:before { content: \"\\f0a1\" } .fa-bullseye:before { content: \"\\f140\" } .fa-burn:before { content: \"\\f46a\" } .fa-buromobelexperte:before { content: \"\\f37f\" } .fa-bus:before { content: \"\\f207\" } .fa-bus-alt:before { content: \"\\f55e\" } .fa-business-time:before { content: \"\\f64a\" } .fa-buysellads:before { content: \"\\f20d\" } .fa-calculator:before { content: \"\\f1ec\" } .fa-calendar:before { content: \"\\f133\" } .fa-calendar-alt:before { content: \"\\f073\" } .fa-calendar-check:before { content: \"\\f274\" } .fa-calendar-minus:before { content: \"\\f272\" } .fa-calendar-plus:before { content: \"\\f271\" } .fa-calendar-times:before { content: \"\\f273\" } .fa-camera:before { content: \"\\f030\" } .fa-camera-retro:before { content: \"\\f083\" } .fa-campground:before { content: \"\\f6bb\" } .fa-cannabis:before { content: \"\\f55f\" } .fa-capsules:before { content: \"\\f46b\" } .fa-car:before { content: \"\\f1b9\" } .fa-car-alt:before { content: \"\\f5de\" } .fa-car-battery:before { content: \"\\f5df\" } .fa-car-crash:before { content: \"\\f5e1\" } .fa-car-side:before { content: \"\\f5e4\" } .fa-caret-down:before { content: \"\\f0d7\" } .fa-caret-left:before { content: \"\\f0d9\" } .fa-caret-right:before { content: \"\\f0da\" } .fa-caret-square-down:before { content: \"\\f150\" } .fa-caret-square-left:before { content: \"\\f191\" } .fa-caret-square-right:before { content: \"\\f152\" } .fa-caret-square-up:before { content: \"\\f151\" } .fa-caret-up:before { content: \"\\f0d8\" } .fa-cart-arrow-down:before { content: \"\\f218\" } .fa-cart-plus:before { content: \"\\f217\" } .fa-cat:before { content: \"\\f6be\" } .fa-cc-amazon-pay:before { content: \"\\f42d\" } .fa-cc-amex:before { content: \"\\f1f3\" } .fa-cc-apple-pay:before { content: \"\\f416\" } .fa-cc-diners-club:before { content: \"\\f24c\" } .fa-cc-discover:before { content: \"\\f1f2\" } .fa-cc-jcb:before { content: \"\\f24b\" } .fa-cc-mastercard:before { content: \"\\f1f1\" } .fa-cc-paypal:before { content: \"\\f1f4\" } .fa-cc-stripe:before { content: \"\\f1f5\" } .fa-cc-visa:before { content: \"\\f1f0\" } .fa-centercode:before { content: \"\\f380\" } .fa-certificate:before { content: \"\\f0a3\" } .fa-chair:before { content: \"\\f6c0\" } .fa-chalkboard:before { content: \"\\f51b\" } .fa-chalkboard-teacher:before { content: \"\\f51c\" } .fa-charging-station:before { content: \"\\f5e7\" } .fa-chart-area:before { content: \"\\f1fe\" } .fa-chart-bar:before { content: \"\\f080\" } .fa-chart-line:before { content: \"\\f201\" } .fa-chart-pie:before { content: \"\\f200\" } .fa-check:before { content: \"\\f00c\" } .fa-check-circle:before { content: \"\\f058\" } .fa-check-double:before { content: \"\\f560\" } .fa-check-square:before { content: \"\\f14a\" } .fa-chess:before { content: \"\\f439\" } .fa-chess-bishop:before { content: \"\\f43a\" } .fa-chess-board:before { content: \"\\f43c\" } .fa-chess-king:before { content: \"\\f43f\" } .fa-chess-knight:before { content: \"\\f441\" } .fa-chess-pawn:before { content: \"\\f443\" } .fa-chess-queen:before { content: \"\\f445\" } .fa-chess-rook:before { content: \"\\f447\" } .fa-chevron-circle-down:before { content: \"\\f13a\" } .fa-chevron-circle-left:before { content: \"\\f137\" } .fa-chevron-circle-right:before { content: \"\\f138\" } .fa-chevron-circle-up:before { content: \"\\f139\" } .fa-chevron-down:before { content: \"\\f078\" } .fa-chevron-left:before { content: \"\\f053\" } .fa-chevron-right:before { content: \"\\f054\" } .fa-chevron-up:before { content: \"\\f077\" } .fa-child:before { content: \"\\f1ae\" } .fa-chrome:before { content: \"\\f268\" } .fa-church:before { content: \"\\f51d\" } .fa-circle:before { content: \"\\f111\" } .fa-circle-notch:before { content: \"\\f1ce\" } .fa-city:before { content: \"\\f64f\" } .fa-clipboard:before { content: \"\\f328\" } .fa-clipboard-check:before { content: \"\\f46c\" } .fa-clipboard-list:before { content: \"\\f46d\" } .fa-clock:before { content: \"\\f017\" } .fa-clone:before { content: \"\\f24d\" } .fa-closed-captioning:before { content: \"\\f20a\" } .fa-cloud:before { content: \"\\f0c2\" } .fa-cloud-download-alt:before { content: \"\\f381\" } .fa-cloud-moon:before { content: \"\\f6c3\" } .fa-cloud-sun:before { content: \"\\f6c4\" } .fa-cloud-upload-alt:before { content: \"\\f382\" } .fa-cloudscale:before { content: \"\\f383\" } .fa-cloudsmith:before { content: \"\\f384\" } .fa-cloudversify:before { content: \"\\f385\" } .fa-cocktail:before { content: \"\\f561\" } .fa-code:before { content: \"\\f121\" } .fa-code-branch:before { content: \"\\f126\" } .fa-codepen:before { content: \"\\f1cb\" } .fa-codiepie:before { content: \"\\f284\" } .fa-coffee:before { content: \"\\f0f4\" } .fa-cog:before { content: \"\\f013\" } .fa-cogs:before { content: \"\\f085\" } .fa-coins:before { content: \"\\f51e\" } .fa-columns:before { content: \"\\f0db\" } .fa-comment:before { content: \"\\f075\" } .fa-comment-alt:before { content: \"\\f27a\" } .fa-comment-dollar:before { content: \"\\f651\" } .fa-comment-dots:before { content: \"\\f4ad\" } .fa-comment-slash:before { content: \"\\f4b3\" } .fa-comments:before { content: \"\\f086\" } .fa-comments-dollar:before { content: \"\\f653\" } .fa-compact-disc:before { content: \"\\f51f\" } .fa-compass:before { content: \"\\f14e\" } .fa-compress:before { content: \"\\f066\" } .fa-concierge-bell:before { content: \"\\f562\" } .fa-connectdevelop:before { content: \"\\f20e\" } .fa-contao:before { content: \"\\f26d\" } .fa-cookie:before { content: \"\\f563\" } .fa-cookie-bite:before { content: \"\\f564\" } .fa-copy:before { content: \"\\f0c5\" } .fa-copyright:before { content: \"\\f1f9\" } .fa-couch:before { content: \"\\f4b8\" } .fa-cpanel:before { content: \"\\f388\" } .fa-creative-commons:before { content: \"\\f25e\" } .fa-creative-commons-by:before { content: \"\\f4e7\" } .fa-creative-commons-nc:before { content: \"\\f4e8\" } .fa-creative-commons-nc-eu:before { content: \"\\f4e9\" } .fa-creative-commons-nc-jp:before { content: \"\\f4ea\" } .fa-creative-commons-nd:before { content: \"\\f4eb\" } .fa-creative-commons-pd:before { content: \"\\f4ec\" } .fa-creative-commons-pd-alt:before { content: \"\\f4ed\" } .fa-creative-commons-remix:before { content: \"\\f4ee\" } .fa-creative-commons-sa:before { content: \"\\f4ef\" } .fa-creative-commons-sampling:before { content: \"\\f4f0\" } .fa-creative-commons-sampling-plus:before { content: \"\\f4f1\" } .fa-creative-commons-share:before { content: \"\\f4f2\" } .fa-creative-commons-zero:before { content: \"\\f4f3\" } .fa-credit-card:before { content: \"\\f09d\" } .fa-critical-role:before { content: \"\\f6c9\" } .fa-crop:before { content: \"\\f125\" } .fa-crop-alt:before { content: \"\\f565\" } .fa-cross:before { content: \"\\f654\" } .fa-crosshairs:before { content: \"\\f05b\" } .fa-crow:before { content: \"\\f520\" } .fa-crown:before { content: \"\\f521\" } .fa-css3:before { content: \"\\f13c\" } .fa-css3-alt:before { content: \"\\f38b\" } .fa-cube:before { content: \"\\f1b2\" } .fa-cubes:before { content: \"\\f1b3\" } .fa-cut:before { content: \"\\f0c4\" } .fa-cuttlefish:before { content: \"\\f38c\" } .fa-d-and-d:before { content: \"\\f38d\" } .fa-dashcube:before { content: \"\\f210\" } .fa-database:before { content: \"\\f1c0\" } .fa-deaf:before { content: \"\\f2a4\" } .fa-delicious:before { content: \"\\f1a5\" } .fa-deploydog:before { content: \"\\f38e\" } .fa-deskpro:before { content: \"\\f38f\" } .fa-desktop:before { content: \"\\f108\" } .fa-dev:before { content: \"\\f6cc\" } .fa-deviantart:before { content: \"\\f1bd\" } .fa-dharmachakra:before { content: \"\\f655\" } .fa-diagnoses:before { content: \"\\f470\" } .fa-dice:before { content: \"\\f522\" } .fa-dice-d20:before { content: \"\\f6cf\" } .fa-dice-d6:before { content: \"\\f6d1\" } .fa-dice-five:before { content: \"\\f523\" } .fa-dice-four:before { content: \"\\f524\" } .fa-dice-one:before { content: \"\\f525\" } .fa-dice-six:before { content: \"\\f526\" } .fa-dice-three:before { content: \"\\f527\" } .fa-dice-two:before { content: \"\\f528\" } .fa-digg:before { content: \"\\f1a6\" } .fa-digital-ocean:before { content: \"\\f391\" } .fa-digital-tachograph:before { content: \"\\f566\" } .fa-directions:before { content: \"\\f5eb\" } .fa-discord:before { content: \"\\f392\" } .fa-discourse:before { content: \"\\f393\" } .fa-divide:before { content: \"\\f529\" } .fa-dizzy:before { content: \"\\f567\" } .fa-dna:before { content: \"\\f471\" } .fa-dochub:before { content: \"\\f394\" } .fa-docker:before { content: \"\\f395\" } .fa-dog:before { content: \"\\f6d3\" } .fa-dollar-sign:before { content: \"\\f155\" } .fa-dolly:before { content: \"\\f472\" } .fa-dolly-flatbed:before { content: \"\\f474\" } .fa-donate:before { content: \"\\f4b9\" } .fa-door-closed:before { content: \"\\f52a\" } .fa-door-open:before { content: \"\\f52b\" } .fa-dot-circle:before { content: \"\\f192\" } .fa-dove:before { content: \"\\f4ba\" } .fa-download:before { content: \"\\f019\" } .fa-draft2digital:before { content: \"\\f396\" } .fa-drafting-compass:before { content: \"\\f568\" } .fa-dragon:before { content: \"\\f6d5\" } .fa-draw-polygon:before { content: \"\\f5ee\" } .fa-dribbble:before { content: \"\\f17d\" } .fa-dribbble-square:before { content: \"\\f397\" } .fa-dropbox:before { content: \"\\f16b\" } .fa-drum:before { content: \"\\f569\" } .fa-drum-steelpan:before { content: \"\\f56a\" } .fa-drumstick-bite:before { content: \"\\f6d7\" } .fa-drupal:before { content: \"\\f1a9\" } .fa-dumbbell:before { content: \"\\f44b\" } .fa-dungeon:before { content: \"\\f6d9\" } .fa-dyalog:before { content: \"\\f399\" } .fa-earlybirds:before { content: \"\\f39a\" } .fa-ebay:before { content: \"\\f4f4\" } .fa-edge:before { content: \"\\f282\" } .fa-edit:before { content: \"\\f044\" } .fa-eject:before { content: \"\\f052\" } .fa-elementor:before { content: \"\\f430\" } .fa-ellipsis-h:before { content: \"\\f141\" } .fa-ellipsis-v:before { content: \"\\f142\" } .fa-ello:before { content: \"\\f5f1\" } .fa-ember:before { content: \"\\f423\" } .fa-empire:before { content: \"\\f1d1\" } .fa-envelope:before { content: \"\\f0e0\" } .fa-envelope-open:before { content: \"\\f2b6\" } .fa-envelope-open-text:before { content: \"\\f658\" } .fa-envelope-square:before { content: \"\\f199\" } .fa-envira:before { content: \"\\f299\" } .fa-equals:before { content: \"\\f52c\" } .fa-eraser:before { content: \"\\f12d\" } .fa-erlang:before { content: \"\\f39d\" } .fa-ethereum:before { content: \"\\f42e\" } .fa-etsy:before { content: \"\\f2d7\" } .fa-euro-sign:before { content: \"\\f153\" } .fa-exchange-alt:before { content: \"\\f362\" } .fa-exclamation:before { content: \"\\f12a\" } .fa-exclamation-circle:before { content: \"\\f06a\" } .fa-exclamation-triangle:before { content: \"\\f071\" } .fa-expand:before { content: \"\\f065\" } .fa-expand-arrows-alt:before { content: \"\\f31e\" } .fa-expeditedssl:before { content: \"\\f23e\" } .fa-external-link-alt:before { content: \"\\f35d\" } .fa-external-link-square-alt:before { content: \"\\f360\" } .fa-eye:before { content: \"\\f06e\" } .fa-eye-dropper:before { content: \"\\f1fb\" } .fa-eye-slash:before { content: \"\\f070\" } .fa-facebook:before { content: \"\\f09a\" } .fa-facebook-f:before { content: \"\\f39e\" } .fa-facebook-messenger:before { content: \"\\f39f\" } .fa-facebook-square:before { content: \"\\f082\" } .fa-fantasy-flight-games:before { content: \"\\f6dc\" } .fa-fast-backward:before { content: \"\\f049\" } .fa-fast-forward:before { content: \"\\f050\" } .fa-fax:before { content: \"\\f1ac\" } .fa-feather:before { content: \"\\f52d\" } .fa-feather-alt:before { content: \"\\f56b\" } .fa-female:before { content: \"\\f182\" } .fa-fighter-jet:before { content: \"\\f0fb\" } .fa-file:before { content: \"\\f15b\" } .fa-file-alt:before { content: \"\\f15c\" } .fa-file-archive:before { content: \"\\f1c6\" } .fa-file-audio:before { content: \"\\f1c7\" } .fa-file-code:before { content: \"\\f1c9\" } .fa-file-contract:before { content: \"\\f56c\" } .fa-file-csv:before { content: \"\\f6dd\" } .fa-file-download:before { content: \"\\f56d\" } .fa-file-excel:before { content: \"\\f1c3\" } .fa-file-export:before { content: \"\\f56e\" } .fa-file-image:before { content: \"\\f1c5\" } .fa-file-import:before { content: \"\\f56f\" } .fa-file-invoice:before { content: \"\\f570\" } .fa-file-invoice-dollar:before { content: \"\\f571\" } .fa-file-medical:before { content: \"\\f477\" } .fa-file-medical-alt:before { content: \"\\f478\" } .fa-file-pdf:before { content: \"\\f1c1\" } .fa-file-powerpoint:before { content: \"\\f1c4\" } .fa-file-prescription:before { content: \"\\f572\" } .fa-file-signature:before { content: \"\\f573\" } .fa-file-upload:before { content: \"\\f574\" } .fa-file-video:before { content: \"\\f1c8\" } .fa-file-word:before { content: \"\\f1c2\" } .fa-fill:before { content: \"\\f575\" } .fa-fill-drip:before { content: \"\\f576\" } .fa-film:before { content: \"\\f008\" } .fa-filter:before { content: \"\\f0b0\" } .fa-fingerprint:before { content: \"\\f577\" } .fa-fire:before { content: \"\\f06d\" } .fa-fire-extinguisher:before { content: \"\\f134\" } .fa-firefox:before { content: \"\\f269\" } .fa-first-aid:before { content: \"\\f479\" } .fa-first-order:before { content: \"\\f2b0\" } .fa-first-order-alt:before { content: \"\\f50a\" } .fa-firstdraft:before { content: \"\\f3a1\" } .fa-fish:before { content: \"\\f578\" } .fa-fist-raised:before { content: \"\\f6de\" } .fa-flag:before { content: \"\\f024\" } .fa-flag-checkered:before { content: \"\\f11e\" } .fa-flask:before { content: \"\\f0c3\" } .fa-flickr:before { content: \"\\f16e\" } .fa-flipboard:before { content: \"\\f44d\" } .fa-flushed:before { content: \"\\f579\" } .fa-fly:before { content: \"\\f417\" } .fa-folder:before { content: \"\\f07b\" } .fa-folder-minus:before { content: \"\\f65d\" } .fa-folder-open:before { content: \"\\f07c\" } .fa-folder-plus:before { content: \"\\f65e\" } .fa-font:before { content: \"\\f031\" } .fa-font-awesome:before { content: \"\\f2b4\" } .fa-font-awesome-alt:before { content: \"\\f35c\" } .fa-font-awesome-flag:before { content: \"\\f425\" } .fa-font-awesome-logo-full:before { content: \"\\f4e6\" } .fa-fonticons:before { content: \"\\f280\" } .fa-fonticons-fi:before { content: \"\\f3a2\" } .fa-football-ball:before { content: \"\\f44e\" } .fa-fort-awesome:before { content: \"\\f286\" } .fa-fort-awesome-alt:before { content: \"\\f3a3\" } .fa-forumbee:before { content: \"\\f211\" } .fa-forward:before { content: \"\\f04e\" } .fa-foursquare:before { content: \"\\f180\" } .fa-free-code-camp:before { content: \"\\f2c5\" } .fa-freebsd:before { content: \"\\f3a4\" } .fa-frog:before { content: \"\\f52e\" } .fa-frown:before { content: \"\\f119\" } .fa-frown-open:before { content: \"\\f57a\" } .fa-fulcrum:before { content: \"\\f50b\" } .fa-funnel-dollar:before { content: \"\\f662\" } .fa-futbol:before { content: \"\\f1e3\" } .fa-galactic-republic:before { content: \"\\f50c\" } .fa-galactic-senate:before { content: \"\\f50d\" } .fa-gamepad:before { content: \"\\f11b\" } .fa-gas-pump:before { content: \"\\f52f\" } .fa-gavel:before { content: \"\\f0e3\" } .fa-gem:before { content: \"\\f3a5\" } .fa-genderless:before { content: \"\\f22d\" } .fa-get-pocket:before { content: \"\\f265\" } .fa-gg:before { content: \"\\f260\" } .fa-gg-circle:before { content: \"\\f261\" } .fa-ghost:before { content: \"\\f6e2\" } .fa-gift:before { content: \"\\f06b\" } .fa-git:before { content: \"\\f1d3\" } .fa-git-square:before { content: \"\\f1d2\" } .fa-github:before { content: \"\\f09b\" } .fa-github-alt:before { content: \"\\f113\" } .fa-github-square:before { content: \"\\f092\" } .fa-gitkraken:before { content: \"\\f3a6\" } .fa-gitlab:before { content: \"\\f296\" } .fa-gitter:before { content: \"\\f426\" } .fa-glass-martini:before { content: \"\\f000\" } .fa-glass-martini-alt:before { content: \"\\f57b\" } .fa-glasses:before { content: \"\\f530\" } .fa-glide:before { content: \"\\f2a5\" } .fa-glide-g:before { content: \"\\f2a6\" } .fa-globe:before { content: \"\\f0ac\" } .fa-globe-africa:before { content: \"\\f57c\" } .fa-globe-americas:before { content: \"\\f57d\" } .fa-globe-asia:before { content: \"\\f57e\" } .fa-gofore:before { content: \"\\f3a7\" } .fa-golf-ball:before { content: \"\\f450\" } .fa-goodreads:before { content: \"\\f3a8\" } .fa-goodreads-g:before { content: \"\\f3a9\" } .fa-google:before { content: \"\\f1a0\" } .fa-google-drive:before { content: \"\\f3aa\" } .fa-google-play:before { content: \"\\f3ab\" } .fa-google-plus:before { content: \"\\f2b3\" } .fa-google-plus-g:before { content: \"\\f0d5\" } .fa-google-plus-square:before { content: \"\\f0d4\" } .fa-google-wallet:before { content: \"\\f1ee\" } .fa-gopuram:before { content: \"\\f664\" } .fa-graduation-cap:before { content: \"\\f19d\" } .fa-gratipay:before { content: \"\\f184\" } .fa-grav:before { content: \"\\f2d6\" } .fa-greater-than:before { content: \"\\f531\" } .fa-greater-than-equal:before { content: \"\\f532\" } .fa-grimace:before { content: \"\\f57f\" } .fa-grin:before { content: \"\\f580\" } .fa-grin-alt:before { content: \"\\f581\" } .fa-grin-beam:before { content: \"\\f582\" } .fa-grin-beam-sweat:before { content: \"\\f583\" } .fa-grin-hearts:before { content: \"\\f584\" } .fa-grin-squint:before { content: \"\\f585\" } .fa-grin-squint-tears:before { content: \"\\f586\" } .fa-grin-stars:before { content: \"\\f587\" } .fa-grin-tears:before { content: \"\\f588\" } .fa-grin-tongue:before { content: \"\\f589\" } .fa-grin-tongue-squint:before { content: \"\\f58a\" } .fa-grin-tongue-wink:before { content: \"\\f58b\" } .fa-grin-wink:before { content: \"\\f58c\" } .fa-grip-horizontal:before { content: \"\\f58d\" } .fa-grip-vertical:before { content: \"\\f58e\" } .fa-gripfire:before { content: \"\\f3ac\" } .fa-grunt:before { content: \"\\f3ad\" } .fa-gulp:before { content: \"\\f3ae\" } .fa-h-square:before { content: \"\\f0fd\" } .fa-hacker-news:before { content: \"\\f1d4\" } .fa-hacker-news-square:before { content: \"\\f3af\" } .fa-hackerrank:before { content: \"\\f5f7\" } .fa-hammer:before { content: \"\\f6e3\" } .fa-hamsa:before { content: \"\\f665\" } .fa-hand-holding:before { content: \"\\f4bd\" } .fa-hand-holding-heart:before { content: \"\\f4be\" } .fa-hand-holding-usd:before { content: \"\\f4c0\" } .fa-hand-lizard:before { content: \"\\f258\" } .fa-hand-paper:before { content: \"\\f256\" } .fa-hand-peace:before { content: \"\\f25b\" } .fa-hand-point-down:before { content: \"\\f0a7\" } .fa-hand-point-left:before { content: \"\\f0a5\" } .fa-hand-point-right:before { content: \"\\f0a4\" } .fa-hand-point-up:before { content: \"\\f0a6\" } .fa-hand-pointer:before { content: \"\\f25a\" } .fa-hand-rock:before { content: \"\\f255\" } .fa-hand-scissors:before { content: \"\\f257\" } .fa-hand-spock:before { content: \"\\f259\" } .fa-hands:before { content: \"\\f4c2\" } .fa-hands-helping:before { content: \"\\f4c4\" } .fa-handshake:before { content: \"\\f2b5\" } .fa-hanukiah:before { content: \"\\f6e6\" } .fa-hashtag:before { content: \"\\f292\" } .fa-hat-wizard:before { content: \"\\f6e8\" } .fa-haykal:before { content: \"\\f666\" } .fa-hdd:before { content: \"\\f0a0\" } .fa-heading:before { content: \"\\f1dc\" } .fa-headphones:before { content: \"\\f025\" } .fa-headphones-alt:before { content: \"\\f58f\" } .fa-headset:before { content: \"\\f590\" } .fa-heart:before { content: \"\\f004\" } .fa-heartbeat:before { content: \"\\f21e\" } .fa-helicopter:before { content: \"\\f533\" } .fa-highlighter:before { content: \"\\f591\" } .fa-hiking:before { content: \"\\f6ec\" } .fa-hippo:before { content: \"\\f6ed\" } .fa-hips:before { content: \"\\f452\" } .fa-hire-a-helper:before { content: \"\\f3b0\" } .fa-history:before { content: \"\\f1da\" } .fa-hockey-puck:before { content: \"\\f453\" } .fa-home:before { content: \"\\f015\" } .fa-hooli:before { content: \"\\f427\" } .fa-hornbill:before { content: \"\\f592\" } .fa-horse:before { content: \"\\f6f0\" } .fa-hospital:before { content: \"\\f0f8\" } .fa-hospital-alt:before { content: \"\\f47d\" } .fa-hospital-symbol:before { content: \"\\f47e\" } .fa-hot-tub:before { content: \"\\f593\" } .fa-hotel:before { content: \"\\f594\" } .fa-hotjar:before { content: \"\\f3b1\" } .fa-hourglass:before { content: \"\\f254\" } .fa-hourglass-end:before { content: \"\\f253\" } .fa-hourglass-half:before { content: \"\\f252\" } .fa-hourglass-start:before { content: \"\\f251\" } .fa-house-damage:before { content: \"\\f6f1\" } .fa-houzz:before { content: \"\\f27c\" } .fa-hryvnia:before { content: \"\\f6f2\" } .fa-html5:before { content: \"\\f13b\" } .fa-hubspot:before { content: \"\\f3b2\" } .fa-i-cursor:before { content: \"\\f246\" } .fa-id-badge:before { content: \"\\f2c1\" } .fa-id-card:before { content: \"\\f2c2\" } .fa-id-card-alt:before { content: \"\\f47f\" } .fa-image:before { content: \"\\f03e\" } .fa-images:before { content: \"\\f302\" } .fa-imdb:before { content: \"\\f2d8\" } .fa-inbox:before { content: \"\\f01c\" } .fa-indent:before { content: \"\\f03c\" } .fa-industry:before { content: \"\\f275\" } .fa-infinity:before { content: \"\\f534\" } .fa-info:before { content: \"\\f129\" } .fa-info-circle:before { content: \"\\f05a\" } .fa-instagram:before { content: \"\\f16d\" } .fa-internet-explorer:before { content: \"\\f26b\" } .fa-ioxhost:before { content: \"\\f208\" } .fa-italic:before { content: \"\\f033\" } .fa-itunes:before { content: \"\\f3b4\" } .fa-itunes-note:before { content: \"\\f3b5\" } .fa-java:before { content: \"\\f4e4\" } .fa-jedi:before { content: \"\\f669\" } .fa-jedi-order:before { content: \"\\f50e\" } .fa-jenkins:before { content: \"\\f3b6\" } .fa-joget:before { content: \"\\f3b7\" } .fa-joint:before { content: \"\\f595\" } .fa-joomla:before { content: \"\\f1aa\" } .fa-journal-whills:before { content: \"\\f66a\" } .fa-js:before { content: \"\\f3b8\" } .fa-js-square:before { content: \"\\f3b9\" } .fa-jsfiddle:before { content: \"\\f1cc\" } .fa-kaaba:before { content: \"\\f66b\" } .fa-kaggle:before { content: \"\\f5fa\" } .fa-key:before { content: \"\\f084\" } .fa-keybase:before { content: \"\\f4f5\" } .fa-keyboard:before { content: \"\\f11c\" } .fa-keycdn:before { content: \"\\f3ba\" } .fa-khanda:before { content: \"\\f66d\" } .fa-kickstarter:before { content: \"\\f3bb\" } .fa-kickstarter-k:before { content: \"\\f3bc\" } .fa-kiss:before { content: \"\\f596\" } .fa-kiss-beam:before { content: \"\\f597\" } .fa-kiss-wink-heart:before { content: \"\\f598\" } .fa-kiwi-bird:before { content: \"\\f535\" } .fa-korvue:before { content: \"\\f42f\" } .fa-landmark:before { content: \"\\f66f\" } .fa-language:before { content: \"\\f1ab\" } .fa-laptop:before { content: \"\\f109\" } .fa-laptop-code:before { content: \"\\f5fc\" } .fa-laravel:before { content: \"\\f3bd\" } .fa-lastfm:before { content: \"\\f202\" } .fa-lastfm-square:before { content: \"\\f203\" } .fa-laugh:before { content: \"\\f599\" } .fa-laugh-beam:before { content: \"\\f59a\" } .fa-laugh-squint:before { content: \"\\f59b\" } .fa-laugh-wink:before { content: \"\\f59c\" } .fa-layer-group:before { content: \"\\f5fd\" } .fa-leaf:before { content: \"\\f06c\" } .fa-leanpub:before { content: \"\\f212\" } .fa-lemon:before { content: \"\\f094\" } .fa-less:before { content: \"\\f41d\" } .fa-less-than:before { content: \"\\f536\" } .fa-less-than-equal:before { content: \"\\f537\" } .fa-level-down-alt:before { content: \"\\f3be\" } .fa-level-up-alt:before { content: \"\\f3bf\" } .fa-life-ring:before { content: \"\\f1cd\" } .fa-lightbulb:before { content: \"\\f0eb\" } .fa-line:before { content: \"\\f3c0\" } .fa-link:before { content: \"\\f0c1\" } .fa-linkedin:before { content: \"\\f08c\" } .fa-linkedin-in:before { content: \"\\f0e1\" } .fa-linode:before { content: \"\\f2b8\" } .fa-linux:before { content: \"\\f17c\" } .fa-lira-sign:before { content: \"\\f195\" } .fa-list:before { content: \"\\f03a\" } .fa-list-alt:before { content: \"\\f022\" } .fa-list-ol:before { content: \"\\f0cb\" } .fa-list-ul:before { content: \"\\f0ca\" } .fa-location-arrow:before { content: \"\\f124\" } .fa-lock:before { content: \"\\f023\" } .fa-lock-open:before { content: \"\\f3c1\" } .fa-long-arrow-alt-down:before { content: \"\\f309\" } .fa-long-arrow-alt-left:before { content: \"\\f30a\" } .fa-long-arrow-alt-right:before { content: \"\\f30b\" } .fa-long-arrow-alt-up:before { content: \"\\f30c\" } .fa-low-vision:before { content: \"\\f2a8\" } .fa-luggage-cart:before { content: \"\\f59d\" } .fa-lyft:before { content: \"\\f3c3\" } .fa-magento:before { content: \"\\f3c4\" } .fa-magic:before { content: \"\\f0d0\" } .fa-magnet:before { content: \"\\f076\" } .fa-mail-bulk:before { content: \"\\f674\" } .fa-mailchimp:before { content: \"\\f59e\" } .fa-male:before { content: \"\\f183\" } .fa-mandalorian:before { content: \"\\f50f\" } .fa-map:before { content: \"\\f279\" } .fa-map-marked:before { content: \"\\f59f\" } .fa-map-marked-alt:before { content: \"\\f5a0\" } .fa-map-marker:before { content: \"\\f041\" } .fa-map-marker-alt:before { content: \"\\f3c5\" } .fa-map-pin:before { content: \"\\f276\" } .fa-map-signs:before { content: \"\\f277\" } .fa-markdown:before { content: \"\\f60f\" } .fa-marker:before { content: \"\\f5a1\" } .fa-mars:before { content: \"\\f222\" } .fa-mars-double:before { content: \"\\f227\" } .fa-mars-stroke:before { content: \"\\f229\" } .fa-mars-stroke-h:before { content: \"\\f22b\" } .fa-mars-stroke-v:before { content: \"\\f22a\" } .fa-mask:before { content: \"\\f6fa\" } .fa-mastodon:before { content: \"\\f4f6\" } .fa-maxcdn:before { content: \"\\f136\" } .fa-medal:before { content: \"\\f5a2\" } .fa-medapps:before { content: \"\\f3c6\" } .fa-medium:before { content: \"\\f23a\" } .fa-medium-m:before { content: \"\\f3c7\" } .fa-medkit:before { content: \"\\f0fa\" } .fa-medrt:before { content: \"\\f3c8\" } .fa-meetup:before { content: \"\\f2e0\" } .fa-megaport:before { content: \"\\f5a3\" } .fa-meh:before { content: \"\\f11a\" } .fa-meh-blank:before { content: \"\\f5a4\" } .fa-meh-rolling-eyes:before { content: \"\\f5a5\" } .fa-memory:before { content: \"\\f538\" } .fa-menorah:before { content: \"\\f676\" } .fa-mercury:before { content: \"\\f223\" } .fa-microchip:before { content: \"\\f2db\" } .fa-microphone:before { content: \"\\f130\" } .fa-microphone-alt:before { content: \"\\f3c9\" } .fa-microphone-alt-slash:before { content: \"\\f539\" } .fa-microphone-slash:before { content: \"\\f131\" } .fa-microscope:before { content: \"\\f610\" } .fa-microsoft:before { content: \"\\f3ca\" } .fa-minus:before { content: \"\\f068\" } .fa-minus-circle:before { content: \"\\f056\" } .fa-minus-square:before { content: \"\\f146\" } .fa-mix:before { content: \"\\f3cb\" } .fa-mixcloud:before { content: \"\\f289\" } .fa-mizuni:before { content: \"\\f3cc\" } .fa-mobile:before { content: \"\\f10b\" } .fa-mobile-alt:before { content: \"\\f3cd\" } .fa-modx:before { content: \"\\f285\" } .fa-monero:before { content: \"\\f3d0\" } .fa-money-bill:before { content: \"\\f0d6\" } .fa-money-bill-alt:before { content: \"\\f3d1\" } .fa-money-bill-wave:before { content: \"\\f53a\" } .fa-money-bill-wave-alt:before { content: \"\\f53b\" } .fa-money-check:before { content: \"\\f53c\" } .fa-money-check-alt:before { content: \"\\f53d\" } .fa-monument:before { content: \"\\f5a6\" } .fa-moon:before { content: \"\\f186\" } .fa-mortar-pestle:before { content: \"\\f5a7\" } .fa-mosque:before { content: \"\\f678\" } .fa-motorcycle:before { content: \"\\f21c\" } .fa-mountain:before { content: \"\\f6fc\" } .fa-mouse-pointer:before { content: \"\\f245\" } .fa-music:before { content: \"\\f001\" } .fa-napster:before { content: \"\\f3d2\" } .fa-neos:before { content: \"\\f612\" } .fa-network-wired:before { content: \"\\f6ff\" } .fa-neuter:before { content: \"\\f22c\" } .fa-newspaper:before { content: \"\\f1ea\" } .fa-nimblr:before { content: \"\\f5a8\" } .fa-nintendo-switch:before { content: \"\\f418\" } .fa-node:before { content: \"\\f419\" } .fa-node-js:before { content: \"\\f3d3\" } .fa-not-equal:before { content: \"\\f53e\" } .fa-notes-medical:before { content: \"\\f481\" } .fa-npm:before { content: \"\\f3d4\" } .fa-ns8:before { content: \"\\f3d5\" } .fa-nutritionix:before { content: \"\\f3d6\" } .fa-object-group:before { content: \"\\f247\" } .fa-object-ungroup:before { content: \"\\f248\" } .fa-odnoklassniki:before { content: \"\\f263\" } .fa-odnoklassniki-square:before { content: \"\\f264\" } .fa-oil-can:before { content: \"\\f613\" } .fa-old-republic:before { content: \"\\f510\" } .fa-om:before { content: \"\\f679\" } .fa-opencart:before { content: \"\\f23d\" } .fa-openid:before { content: \"\\f19b\" } .fa-opera:before { content: \"\\f26a\" } .fa-optin-monster:before { content: \"\\f23c\" } .fa-osi:before { content: \"\\f41a\" } .fa-otter:before { content: \"\\f700\" } .fa-outdent:before { content: \"\\f03b\" } .fa-page4:before { content: \"\\f3d7\" } .fa-pagelines:before { content: \"\\f18c\" } .fa-paint-brush:before { content: \"\\f1fc\" } .fa-paint-roller:before { content: \"\\f5aa\" } .fa-palette:before { content: \"\\f53f\" } .fa-palfed:before { content: \"\\f3d8\" } .fa-pallet:before { content: \"\\f482\" } .fa-paper-plane:before { content: \"\\f1d8\" } .fa-paperclip:before { content: \"\\f0c6\" } .fa-parachute-box:before { content: \"\\f4cd\" } .fa-paragraph:before { content: \"\\f1dd\" } .fa-parking:before { content: \"\\f540\" } .fa-passport:before { content: \"\\f5ab\" } .fa-pastafarianism:before { content: \"\\f67b\" } .fa-paste:before { content: \"\\f0ea\" } .fa-patreon:before { content: \"\\f3d9\" } .fa-pause:before { content: \"\\f04c\" } .fa-pause-circle:before { content: \"\\f28b\" } .fa-paw:before { content: \"\\f1b0\" } .fa-paypal:before { content: \"\\f1ed\" } .fa-peace:before { content: \"\\f67c\" } .fa-pen:before { content: \"\\f304\" } .fa-pen-alt:before { content: \"\\f305\" } .fa-pen-fancy:before { content: \"\\f5ac\" } .fa-pen-nib:before { content: \"\\f5ad\" } .fa-pen-square:before { content: \"\\f14b\" } .fa-pencil-alt:before { content: \"\\f303\" } .fa-pencil-ruler:before { content: \"\\f5ae\" } .fa-penny-arcade:before { content: \"\\f704\" } .fa-people-carry:before { content: \"\\f4ce\" } .fa-percent:before { content: \"\\f295\" } .fa-percentage:before { content: \"\\f541\" } .fa-periscope:before { content: \"\\f3da\" } .fa-phabricator:before { content: \"\\f3db\" } .fa-phoenix-framework:before { content: \"\\f3dc\" } .fa-phoenix-squadron:before { content: \"\\f511\" } .fa-phone:before { content: \"\\f095\" } .fa-phone-slash:before { content: \"\\f3dd\" } .fa-phone-square:before { content: \"\\f098\" } .fa-phone-volume:before { content: \"\\f2a0\" } .fa-php:before { content: \"\\f457\" } .fa-pied-piper:before { content: \"\\f2ae\" } .fa-pied-piper-alt:before { content: \"\\f1a8\" } .fa-pied-piper-hat:before { content: \"\\f4e5\" } .fa-pied-piper-pp:before { content: \"\\f1a7\" } .fa-piggy-bank:before { content: \"\\f4d3\" } .fa-pills:before { content: \"\\f484\" } .fa-pinterest:before { content: \"\\f0d2\" } .fa-pinterest-p:before { content: \"\\f231\" } .fa-pinterest-square:before { content: \"\\f0d3\" } .fa-place-of-worship:before { content: \"\\f67f\" } .fa-plane:before { content: \"\\f072\" } .fa-plane-arrival:before { content: \"\\f5af\" } .fa-plane-departure:before { content: \"\\f5b0\" } .fa-play:before { content: \"\\f04b\" } .fa-play-circle:before { content: \"\\f144\" } .fa-playstation:before { content: \"\\f3df\" } .fa-plug:before { content: \"\\f1e6\" } .fa-plus:before { content: \"\\f067\" } .fa-plus-circle:before { content: \"\\f055\" } .fa-plus-square:before { content: \"\\f0fe\" } .fa-podcast:before { content: \"\\f2ce\" } .fa-poll:before { content: \"\\f681\" } .fa-poll-h:before { content: \"\\f682\" } .fa-poo:before { content: \"\\f2fe\" } .fa-poop:before { content: \"\\f619\" } .fa-portrait:before { content: \"\\f3e0\" } .fa-pound-sign:before { content: \"\\f154\" } .fa-power-off:before { content: \"\\f011\" } .fa-pray:before { content: \"\\f683\" } .fa-praying-hands:before { content: \"\\f684\" } .fa-prescription:before { content: \"\\f5b1\" } .fa-prescription-bottle:before { content: \"\\f485\" } .fa-prescription-bottle-alt:before { content: \"\\f486\" } .fa-print:before { content: \"\\f02f\" } .fa-procedures:before { content: \"\\f487\" } .fa-product-hunt:before { content: \"\\f288\" } .fa-project-diagram:before { content: \"\\f542\" } .fa-pushed:before { content: \"\\f3e1\" } .fa-puzzle-piece:before { content: \"\\f12e\" } .fa-python:before { content: \"\\f3e2\" } .fa-qq:before { content: \"\\f1d6\" } .fa-qrcode:before { content: \"\\f029\" } .fa-question:before { content: \"\\f128\" } .fa-question-circle:before { content: \"\\f059\" } .fa-quidditch:before { content: \"\\f458\" } .fa-quinscape:before { content: \"\\f459\" } .fa-quora:before { content: \"\\f2c4\" } .fa-quote-left:before { content: \"\\f10d\" } .fa-quote-right:before { content: \"\\f10e\" } .fa-quran:before { content: \"\\f687\" } .fa-r-project:before { content: \"\\f4f7\" } .fa-random:before { content: \"\\f074\" } .fa-ravelry:before { content: \"\\f2d9\" } .fa-react:before { content: \"\\f41b\" } .fa-readme:before { content: \"\\f4d5\" } .fa-rebel:before { content: \"\\f1d0\" } .fa-receipt:before { content: \"\\f543\" } .fa-recycle:before { content: \"\\f1b8\" } .fa-red-river:before { content: \"\\f3e3\" } .fa-reddit:before { content: \"\\f1a1\" } .fa-reddit-alien:before { content: \"\\f281\" } .fa-reddit-square:before { content: \"\\f1a2\" } .fa-redo:before { content: \"\\f01e\" } .fa-redo-alt:before { content: \"\\f2f9\" } .fa-registered:before { content: \"\\f25d\" } .fa-rendact:before { content: \"\\f3e4\" } .fa-renren:before { content: \"\\f18b\" } .fa-reply:before { content: \"\\f3e5\" } .fa-reply-all:before { content: \"\\f122\" } .fa-replyd:before { content: \"\\f3e6\" } .fa-researchgate:before { content: \"\\f4f8\" } .fa-resolving:before { content: \"\\f3e7\" } .fa-retweet:before { content: \"\\f079\" } .fa-rev:before { content: \"\\f5b2\" } .fa-ribbon:before { content: \"\\f4d6\" } .fa-ring:before { content: \"\\f70b\" } .fa-road:before { content: \"\\f018\" } .fa-robot:before { content: \"\\f544\" } .fa-rocket:before { content: \"\\f135\" } .fa-rocketchat:before { content: \"\\f3e8\" } .fa-rockrms:before { content: \"\\f3e9\" } .fa-route:before { content: \"\\f4d7\" } .fa-rss:before { content: \"\\f09e\" } .fa-rss-square:before { content: \"\\f143\" } .fa-ruble-sign:before { content: \"\\f158\" } .fa-ruler:before { content: \"\\f545\" } .fa-ruler-combined:before { content: \"\\f546\" } .fa-ruler-horizontal:before { content: \"\\f547\" } .fa-ruler-vertical:before { content: \"\\f548\" } .fa-running:before { content: \"\\f70c\" } .fa-rupee-sign:before { content: \"\\f156\" } .fa-sad-cry:before { content: \"\\f5b3\" } .fa-sad-tear:before { content: \"\\f5b4\" } .fa-safari:before { content: \"\\f267\" } .fa-sass:before { content: \"\\f41e\" } .fa-save:before { content: \"\\f0c7\" } .fa-schlix:before { content: \"\\f3ea\" } .fa-school:before { content: \"\\f549\" } .fa-screwdriver:before { content: \"\\f54a\" } .fa-scribd:before { content: \"\\f28a\" } .fa-scroll:before { content: \"\\f70e\" } .fa-search:before { content: \"\\f002\" } .fa-search-dollar:before { content: \"\\f688\" } .fa-search-location:before { content: \"\\f689\" } .fa-search-minus:before { content: \"\\f010\" } .fa-search-plus:before { content: \"\\f00e\" } .fa-searchengin:before { content: \"\\f3eb\" } .fa-seedling:before { content: \"\\f4d8\" } .fa-sellcast:before { content: \"\\f2da\" } .fa-sellsy:before { content: \"\\f213\" } .fa-server:before { content: \"\\f233\" } .fa-servicestack:before { content: \"\\f3ec\" } .fa-shapes:before { content: \"\\f61f\" } .fa-share:before { content: \"\\f064\" } .fa-share-alt:before { content: \"\\f1e0\" } .fa-share-alt-square:before { content: \"\\f1e1\" } .fa-share-square:before { content: \"\\f14d\" } .fa-shekel-sign:before { content: \"\\f20b\" } .fa-shield-alt:before { content: \"\\f3ed\" } .fa-ship:before { content: \"\\f21a\" } .fa-shipping-fast:before { content: \"\\f48b\" } .fa-shirtsinbulk:before { content: \"\\f214\" } .fa-shoe-prints:before { content: \"\\f54b\" } .fa-shopping-bag:before { content: \"\\f290\" } .fa-shopping-basket:before { content: \"\\f291\" } .fa-shopping-cart:before { content: \"\\f07a\" } .fa-shopware:before { content: \"\\f5b5\" } .fa-shower:before { content: \"\\f2cc\" } .fa-shuttle-van:before { content: \"\\f5b6\" } .fa-sign:before { content: \"\\f4d9\" } .fa-sign-in-alt:before { content: \"\\f2f6\" } .fa-sign-language:before { content: \"\\f2a7\" } .fa-sign-out-alt:before { content: \"\\f2f5\" } .fa-signal:before { content: \"\\f012\" } .fa-signature:before { content: \"\\f5b7\" } .fa-simplybuilt:before { content: \"\\f215\" } .fa-sistrix:before { content: \"\\f3ee\" } .fa-sitemap:before { content: \"\\f0e8\" } .fa-sith:before { content: \"\\f512\" } .fa-skull:before { content: \"\\f54c\" } .fa-skull-crossbones:before { content: \"\\f714\" } .fa-skyatlas:before { content: \"\\f216\" } .fa-skype:before { content: \"\\f17e\" } .fa-slack:before { content: \"\\f198\" } .fa-slack-hash:before { content: \"\\f3ef\" } .fa-slash:before { content: \"\\f715\" } .fa-sliders-h:before { content: \"\\f1de\" } .fa-slideshare:before { content: \"\\f1e7\" } .fa-smile:before { content: \"\\f118\" } .fa-smile-beam:before { content: \"\\f5b8\" } .fa-smile-wink:before { content: \"\\f4da\" } .fa-smoking:before { content: \"\\f48d\" } .fa-smoking-ban:before { content: \"\\f54d\" } .fa-snapchat:before { content: \"\\f2ab\" } .fa-snapchat-ghost:before { content: \"\\f2ac\" } .fa-snapchat-square:before { content: \"\\f2ad\" } .fa-snowflake:before { content: \"\\f2dc\" } .fa-socks:before { content: \"\\f696\" } .fa-solar-panel:before { content: \"\\f5ba\" } .fa-sort:before { content: \"\\f0dc\" } .fa-sort-alpha-down:before { content: \"\\f15d\" } .fa-sort-alpha-up:before { content: \"\\f15e\" } .fa-sort-amount-down:before { content: \"\\f160\" } .fa-sort-amount-up:before { content: \"\\f161\" } .fa-sort-down:before { content: \"\\f0dd\" } .fa-sort-numeric-down:before { content: \"\\f162\" } .fa-sort-numeric-up:before { content: \"\\f163\" } .fa-sort-up:before { content: \"\\f0de\" } .fa-soundcloud:before { content: \"\\f1be\" } .fa-spa:before { content: \"\\f5bb\" } .fa-space-shuttle:before { content: \"\\f197\" } .fa-speakap:before { content: \"\\f3f3\" } .fa-spider:before { content: \"\\f717\" } .fa-spinner:before { content: \"\\f110\" } .fa-splotch:before { content: \"\\f5bc\" } .fa-spotify:before { content: \"\\f1bc\" } .fa-spray-can:before { content: \"\\f5bd\" } .fa-square:before { content: \"\\f0c8\" } .fa-square-full:before { content: \"\\f45c\" } .fa-square-root-alt:before { content: \"\\f698\" } .fa-squarespace:before { content: \"\\f5be\" } .fa-stack-exchange:before { content: \"\\f18d\" } .fa-stack-overflow:before { content: \"\\f16c\" } .fa-stamp:before { content: \"\\f5bf\" } .fa-star:before { content: \"\\f005\" } .fa-star-and-crescent:before { content: \"\\f699\" } .fa-star-half:before { content: \"\\f089\" } .fa-star-half-alt:before { content: \"\\f5c0\" } .fa-star-of-david:before { content: \"\\f69a\" } .fa-star-of-life:before { content: \"\\f621\" } .fa-staylinked:before { content: \"\\f3f5\" } .fa-steam:before { content: \"\\f1b6\" } .fa-steam-square:before { content: \"\\f1b7\" } .fa-steam-symbol:before { content: \"\\f3f6\" } .fa-step-backward:before { content: \"\\f048\" } .fa-step-forward:before { content: \"\\f051\" } .fa-stethoscope:before { content: \"\\f0f1\" } .fa-sticker-mule:before { content: \"\\f3f7\" } .fa-sticky-note:before { content: \"\\f249\" } .fa-stop:before { content: \"\\f04d\" } .fa-stop-circle:before { content: \"\\f28d\" } .fa-stopwatch:before { content: \"\\f2f2\" } .fa-store:before { content: \"\\f54e\" } .fa-store-alt:before { content: \"\\f54f\" } .fa-strava:before { content: \"\\f428\" } .fa-stream:before { content: \"\\f550\" } .fa-street-view:before { content: \"\\f21d\" } .fa-strikethrough:before { content: \"\\f0cc\" } .fa-stripe:before { content: \"\\f429\" } .fa-stripe-s:before { content: \"\\f42a\" } .fa-stroopwafel:before { content: \"\\f551\" } .fa-studiovinari:before { content: \"\\f3f8\" } .fa-stumbleupon:before { content: \"\\f1a4\" } .fa-stumbleupon-circle:before { content: \"\\f1a3\" } .fa-subscript:before { content: \"\\f12c\" } .fa-subway:before { content: \"\\f239\" } .fa-suitcase:before { content: \"\\f0f2\" } .fa-suitcase-rolling:before { content: \"\\f5c1\" } .fa-sun:before { content: \"\\f185\" } .fa-superpowers:before { content: \"\\f2dd\" } .fa-superscript:before { content: \"\\f12b\" } .fa-supple:before { content: \"\\f3f9\" } .fa-surprise:before { content: \"\\f5c2\" } .fa-swatchbook:before { content: \"\\f5c3\" } .fa-swimmer:before { content: \"\\f5c4\" } .fa-swimming-pool:before { content: \"\\f5c5\" } .fa-synagogue:before { content: \"\\f69b\" } .fa-sync:before { content: \"\\f021\" } .fa-sync-alt:before { content: \"\\f2f1\" } .fa-syringe:before { content: \"\\f48e\" } .fa-table:before { content: \"\\f0ce\" } .fa-table-tennis:before { content: \"\\f45d\" } .fa-tablet:before { content: \"\\f10a\" } .fa-tablet-alt:before { content: \"\\f3fa\" } .fa-tablets:before { content: \"\\f490\" } .fa-tachometer-alt:before { content: \"\\f3fd\" } .fa-tag:before { content: \"\\f02b\" } .fa-tags:before { content: \"\\f02c\" } .fa-tape:before { content: \"\\f4db\" } .fa-tasks:before { content: \"\\f0ae\" } .fa-taxi:before { content: \"\\f1ba\" } .fa-teamspeak:before { content: \"\\f4f9\" } .fa-teeth:before { content: \"\\f62e\" } .fa-teeth-open:before { content: \"\\f62f\" } .fa-telegram:before { content: \"\\f2c6\" } .fa-telegram-plane:before { content: \"\\f3fe\" } .fa-tencent-weibo:before { content: \"\\f1d5\" } .fa-terminal:before { content: \"\\f120\" } .fa-text-height:before { content: \"\\f034\" } .fa-text-width:before { content: \"\\f035\" } .fa-th:before { content: \"\\f00a\" } .fa-th-large:before { content: \"\\f009\" } .fa-th-list:before { content: \"\\f00b\" } .fa-the-red-yeti:before { content: \"\\f69d\" } .fa-theater-masks:before { content: \"\\f630\" } .fa-themeco:before { content: \"\\f5c6\" } .fa-themeisle:before { content: \"\\f2b2\" } .fa-thermometer:before { content: \"\\f491\" } .fa-thermometer-empty:before { content: \"\\f2cb\" } .fa-thermometer-full:before { content: \"\\f2c7\" } .fa-thermometer-half:before { content: \"\\f2c9\" } .fa-thermometer-quarter:before { content: \"\\f2ca\" } .fa-thermometer-three-quarters:before { content: \"\\f2c8\" } .fa-thumbs-down:before { content: \"\\f165\" } .fa-thumbs-up:before { content: \"\\f164\" } .fa-thumbtack:before { content: \"\\f08d\" } .fa-ticket-alt:before { content: \"\\f3ff\" } .fa-times:before { content: \"\\f00d\" } .fa-times-circle:before { content: \"\\f057\" } .fa-tint:before { content: \"\\f043\" } .fa-tint-slash:before { content: \"\\f5c7\" } .fa-tired:before { content: \"\\f5c8\" } .fa-toggle-off:before { content: \"\\f204\" } .fa-toggle-on:before { content: \"\\f205\" } .fa-toilet-paper:before { content: \"\\f71e\" } .fa-toolbox:before { content: \"\\f552\" } .fa-tooth:before { content: \"\\f5c9\" } .fa-torah:before { content: \"\\f6a0\" } .fa-torii-gate:before { content: \"\\f6a1\" } .fa-tractor:before { content: \"\\f722\" } .fa-trade-federation:before { content: \"\\f513\" } .fa-trademark:before { content: \"\\f25c\" } .fa-traffic-light:before { content: \"\\f637\" } .fa-train:before { content: \"\\f238\" } .fa-transgender:before { content: \"\\f224\" } .fa-transgender-alt:before { content: \"\\f225\" } .fa-trash:before { content: \"\\f1f8\" } .fa-trash-alt:before { content: \"\\f2ed\" } .fa-tree:before { content: \"\\f1bb\" } .fa-trello:before { content: \"\\f181\" } .fa-tripadvisor:before { content: \"\\f262\" } .fa-trophy:before { content: \"\\f091\" } .fa-truck:before { content: \"\\f0d1\" } .fa-truck-loading:before { content: \"\\f4de\" } .fa-truck-monster:before { content: \"\\f63b\" } .fa-truck-moving:before { content: \"\\f4df\" } .fa-truck-pickup:before { content: \"\\f63c\" } .fa-tshirt:before { content: \"\\f553\" } .fa-tty:before { content: \"\\f1e4\" } .fa-tumblr:before { content: \"\\f173\" } .fa-tumblr-square:before { content: \"\\f174\" } .fa-tv:before { content: \"\\f26c\" } .fa-twitch:before { content: \"\\f1e8\" } .fa-twitter:before { content: \"\\f099\" } .fa-twitter-square:before { content: \"\\f081\" } .fa-typo3:before { content: \"\\f42b\" } .fa-uber:before { content: \"\\f402\" } .fa-uikit:before { content: \"\\f403\" } .fa-umbrella:before { content: \"\\f0e9\" } .fa-umbrella-beach:before { content: \"\\f5ca\" } .fa-underline:before { content: \"\\f0cd\" } .fa-undo:before { content: \"\\f0e2\" } .fa-undo-alt:before { content: \"\\f2ea\" } .fa-uniregistry:before { content: \"\\f404\" } .fa-universal-access:before { content: \"\\f29a\" } .fa-university:before { content: \"\\f19c\" } .fa-unlink:before { content: \"\\f127\" } .fa-unlock:before { content: \"\\f09c\" } .fa-unlock-alt:before { content: \"\\f13e\" } .fa-untappd:before { content: \"\\f405\" } .fa-upload:before { content: \"\\f093\" } .fa-usb:before { content: \"\\f287\" } .fa-user:before { content: \"\\f007\" } .fa-user-alt:before { content: \"\\f406\" } .fa-user-alt-slash:before { content: \"\\f4fa\" } .fa-user-astronaut:before { content: \"\\f4fb\" } .fa-user-check:before { content: \"\\f4fc\" } .fa-user-circle:before { content: \"\\f2bd\" } .fa-user-clock:before { content: \"\\f4fd\" } .fa-user-cog:before { content: \"\\f4fe\" } .fa-user-edit:before { content: \"\\f4ff\" } .fa-user-friends:before { content: \"\\f500\" } .fa-user-graduate:before { content: \"\\f501\" } .fa-user-injured:before { content: \"\\f728\" } .fa-user-lock:before { content: \"\\f502\" } .fa-user-md:before { content: \"\\f0f0\" } .fa-user-minus:before { content: \"\\f503\" } .fa-user-ninja:before { content: \"\\f504\" } .fa-user-plus:before { content: \"\\f234\" } .fa-user-secret:before { content: \"\\f21b\" } .fa-user-shield:before { content: \"\\f505\" } .fa-user-slash:before { content: \"\\f506\" } .fa-user-tag:before { content: \"\\f507\" } .fa-user-tie:before { content: \"\\f508\" } .fa-user-times:before { content: \"\\f235\" } .fa-users:before { content: \"\\f0c0\" } .fa-users-cog:before { content: \"\\f509\" } .fa-ussunnah:before { content: \"\\f407\" } .fa-utensil-spoon:before { content: \"\\f2e5\" } .fa-utensils:before { content: \"\\f2e7\" } .fa-vaadin:before { content: \"\\f408\" } .fa-vector-square:before { content: \"\\f5cb\" } .fa-venus:before { content: \"\\f221\" } .fa-venus-double:before { content: \"\\f226\" } .fa-venus-mars:before { content: \"\\f228\" } .fa-viacoin:before { content: \"\\f237\" } .fa-viadeo:before { content: \"\\f2a9\" } .fa-viadeo-square:before { content: \"\\f2aa\" } .fa-vial:before { content: \"\\f492\" } .fa-vials:before { content: \"\\f493\" } .fa-viber:before { content: \"\\f409\" } .fa-video:before { content: \"\\f03d\" } .fa-video-slash:before { content: \"\\f4e2\" } .fa-vihara:before { content: \"\\f6a7\" } .fa-vimeo:before { content: \"\\f40a\" } .fa-vimeo-square:before { content: \"\\f194\" } .fa-vimeo-v:before { content: \"\\f27d\" } .fa-vine:before { content: \"\\f1ca\" } .fa-vk:before { content: \"\\f189\" } .fa-vnv:before { content: \"\\f40b\" } .fa-volleyball-ball:before { content: \"\\f45f\" } .fa-volume-down:before { content: \"\\f027\" } .fa-volume-mute:before { content: \"\\f6a9\" } .fa-volume-off:before { content: \"\\f026\" } .fa-volume-up:before { content: \"\\f028\" } .fa-vuejs:before { content: \"\\f41f\" } .fa-walking:before { content: \"\\f554\" } .fa-wallet:before { content: \"\\f555\" } .fa-warehouse:before { content: \"\\f494\" } .fa-weebly:before { content: \"\\f5cc\" } .fa-weibo:before { content: \"\\f18a\" } .fa-weight:before { content: \"\\f496\" } .fa-weight-hanging:before { content: \"\\f5cd\" } .fa-weixin:before { content: \"\\f1d7\" } .fa-whatsapp:before { content: \"\\f232\" } .fa-whatsapp-square:before { content: \"\\f40c\" } .fa-wheelchair:before { content: \"\\f193\" } .fa-whmcs:before { content: \"\\f40d\" } .fa-wifi:before { content: \"\\f1eb\" } .fa-wikipedia-w:before { content: \"\\f266\" } .fa-wind:before { content: \"\\f72e\" } .fa-window-close:before { content: \"\\f410\" } .fa-window-maximize:before { content: \"\\f2d0\" } .fa-window-minimize:before { content: \"\\f2d1\" } .fa-window-restore:before { content: \"\\f2d2\" } .fa-windows:before { content: \"\\f17a\" } .fa-wine-bottle:before { content: \"\\f72f\" } .fa-wine-glass:before { content: \"\\f4e3\" } .fa-wine-glass-alt:before { content: \"\\f5ce\" } .fa-wix:before { content: \"\\f5cf\" } .fa-wizards-of-the-coast:before { content: \"\\f730\" } .fa-wolf-pack-battalion:before { content: \"\\f514\" } .fa-won-sign:before { content: \"\\f159\" } .fa-wordpress:before { content: \"\\f19a\" } .fa-wordpress-simple:before { content: \"\\f411\" } .fa-wpbeginner:before { content: \"\\f297\" } .fa-wpexplorer:before { content: \"\\f2de\" } .fa-wpforms:before { content: \"\\f298\" } .fa-wrench:before { content: \"\\f0ad\" } .fa-x-ray:before { content: \"\\f497\" } .fa-xbox:before { content: \"\\f412\" } .fa-xing:before { content: \"\\f168\" } .fa-xing-square:before { content: \"\\f169\" } .fa-y-combinator:before { content: \"\\f23b\" } .fa-yahoo:before { content: \"\\f19e\" } .fa-yandex:before { content: \"\\f413\" } .fa-yandex-international:before { content: \"\\f414\" } .fa-yelp:before { content: \"\\f1e9\" } .fa-yen-sign:before { content: \"\\f157\" } .fa-yin-yang:before { content: \"\\f6ad\" } .fa-yoast:before { content: \"\\f2b1\" } .fa-youtube:before { content: \"\\f167\" } .fa-youtube-square:before { content: \"\\f431\" } .fa-zhihu:before { content: \"\\f63f\" } .sr-only { border: 0; clip: rect(0,0,0,0); height: 1px; margin: -1px; overflow: hidden; padding: 0; position: absolute; width: 1px } .sr-only-focusable:active,.sr-only-focusable:focus { clip: auto; height: auto; margin: 0; overflow: visible; position: static; width: auto } @font-face { font-family: \"Font Awesome 5 Brands\"; font-style: normal; font-weight: normal; src: url(./webfonts/fa-brands-400.eot); src: url(./webfonts/fa-brands-400.eot?#iefix) format(\"embedded-opentype\"),url(./webfonts/fa-brands-400.woff2) format(\"woff2\"),url(./webfonts/fa-brands-400.woff) format(\"woff\"),url(./webfonts/fa-brands-400.ttf) format(\"truetype\"),url(./webfonts/fa-brands-400.svg#fontawesome) format(\"svg\") } .fab { font-family: \"Font Awesome 5 Brands\" } @font-face { font-family: \"Font Awesome 5 Free\"; font-style: normal; font-weight: 400; src: url(./webfonts/fa-regular-400.eot); src: url(./webfonts/fa-regular-400.eot?#iefix) format(\"embedded-opentype\"),url(./webfonts/fa-regular-400.woff2) format(\"woff2\"),url(./webfonts/fa-regular-400.woff) format(\"woff\"),url(./webfonts/fa-regular-400.ttf) format(\"truetype\"),url(./webfonts/fa-regular-400.svg#fontawesome) format(\"svg\") } .far { font-weight: 400 } @font-face { font-family: \"Font Awesome 5 Free\"; font-style: normal; font-weight: 900; src: url(./webfonts/fa-solid-900.eot); src: url(./webfonts/fa-solid-900.eot?#iefix) format(\"embedded-opentype\"),url(./webfonts/fa-solid-900.woff2) format(\"woff2\"),url(./webfonts/fa-solid-900.woff) format(\"woff\"),url(./webfonts/fa-solid-900.ttf) format(\"truetype\"),url(./webfonts/fa-solid-900.svg#fontawesome) format(\"svg\") } .fa,.far,.fas { font-family: \"Font Awesome 5 Free\" } .fa,.fas { font-weight: 900 }","link":"/icons/all.css"}],"posts":[{"title":"JavaScript 中的闭包（Closures）","text":"什么是闭包？哪里用得到闭包？ 闭包是函数和声明该函数的词法环境的组合。 什么是闭包？ 闭包是函数和声明该函数的词法环境的组合。 —- JavaScript Reference 词法作用域考虑如下情况： 123456789function init() { var name = 'Mozilla'; // name 是 init 函数的局部变量 // displayName() 是一个内部函数，是一个闭包 function displayName() { console.log(name); // 使用了外部函数中的变量 } displayName();}init(); 这个例子说明词法作用域的范围，函数的词法作用域包括了函数自身的作用域以及定义该函数的位置的作用域。也就是说，函数可以访问在其上层作用域中定义的变量。 作用域对象每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。这与那些保存的所有全局变量和函数的全局对象（global object）类似，但仍有一些很重要的区别，第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；第二，与全局对象（在浏览器里面是当做 window 对象来访问的）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有可以遍历当前的作用域对象里面属性的方法。 一个闭包就是一个函数和其外层函数的作用域对象的组合。 闭包再看一下这个例子： 123456789function makeFunc() { var name = 'Mozilla'; function displayName() { console.log(name); } return displayName;}var myFunc = makeFunc();myFunc(); 在这个例子中，内部函数并没有直接执行，而是被外部函数返回。这个例子在 JavaScript 中是可行的。但是在一些其它的编程语言中，函数中的局部变量仅函数的其执行期可用，一旦函数执行完毕，函数中的局部变量将被销毁。但其实变量销毁的逻辑其实是一样的，都为了节省内存，在变量不可再被访问时，进行销毁。（比如这些语言的局部变量一定是在函数执行完毕就无法再被访问了，又比如一些语言的引用计数方式的 GC） 由于 JavaScript 中的函数会形成闭包，闭包可以访问其外层作用域，所以只要这些函数还能被访问到，外层作用域的变量就不会被销毁。由于我们还持有 myFunc（等同于 displayName，一个可以访问 name 变量的闭包），所以 name 变量不会被销毁。 下面是一个更有意思的例子： 1234567891011function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 在这个例子中，add5 和 add10 共享函数定义，但是各自有不同的词法环境。add5 的环境中，x 为 5，而 add10 中，x 为 10。 闭包的用处闭包是一个很有用的特性，因为他可以将函数和其定义的环境联系起来。这个面向对象编程中，对象允许将其方法和其属性与其它方法联系起来有些相像。 函数工厂在上面那个例子中，我们可以看到闭包的一种用法：函数工厂。根据不同参数，创建行为具有相同规则但是又不相同的函数，例如创建可以修改字体大小的函数，并且绑定到不同事件上面去： 123456789function fontSizeSetter(size) { return function() { document.body.style.fontSize = size + 'px'; };}document.getElementById('font-size-12').onClick = fontSizeSetter(12);document.getElementById('font-size-14').onClick = fontSizeSetter(14);document.getElementById('font-size-16').onClick = fontSizeSetter(16); 模拟私有变量与方法JavaScript 不像 Java 等一些其它语言，JavaScript 无法定义私有的变量或方法（即只能被同一个类访问的变量或方法）。 但是通过闭包，我们可以模拟相同的效果。例如： 123456789101112131415161718192021222324var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } };})();console.log(Counter.value()); // 0Counter.increment();Counter.increment();console.log(Counter.value()); // 2Counter.decrement();console.log(Counter.value()); // 1 这个例子中，Counter 对象有三个方法：increment、decrement 和 value，并且除了这三个方法，没有地方再可以访问 privateCounter 与 changeBy。 像这种通过闭包来定义公共函数，并使其可以访问私有变量和函数的方式，通常被称为模块模式（Module Pattern）。 再举一个更加面向对象一些的例子： 123456789101112131415161718192021222324function Counter(initValue) { var privateCounter = initValue || 0; return { increment() { privateCounter += 1; return this; }, decrement() { privateCounter -= 1; return this; }, get value() { return privateCounter; } };}const counter1 = new Counter();counter1.increment().increment().value; // 2counter1.decrement().value; // 1const counter2 = new Counter(counter1.value);counter2.increment().value; // 2counter2.increment().decrement().value; // 2 运用 class 语法的版本： 123456789101112131415161718class Counter { constructor(initValue = 0) { let privateCounter = initValue; function makeChainableChanger(value) { return function() { privateCounter += value; return this; }; } return { increment: makeChainableChanger(1), decrement: makeChainableChanger(-1), get value() { return privateCounter; } }; }} 闭包的常见错误在 ECMAScript 2015 引入 let 关键字之前，在循环中有一个常见的闭包创建问题。 示例如下： 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 这个例子中，每个循环创建了一个闭包，由于在循环中被创建，这 3 个闭包共享了相同的词法环境（循环的词法环境），在这些闭包被调用时，循环早已结束，词法环境中的 item 已经指向了 helpText 的最后一项。 解决这个问题有很多种办法，比如可以通过引入更多闭包解决： 123456789101112131415161718192021222324function showHelp(help) { document.getElementById('help').innerHTML = help;}function showHelpCallback(item) { return function() { showHelp(item.help); };}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = showHelpCallback(item); }}setupHelp(); 或者使用匿名闭包： 12345678910111213141516171819202122function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { (function() { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; })(); }}setupHelp(); 而更好的方法是，使用 let 关键词将变量声明到块作用域（循环的块作用域是每一次循环独立的）而不是整个循环上。（所以在很多项目的规范中，要求永远不要使用 var 关键词） 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { const helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (let i = 0; i &lt; helpText.length; i++) { let item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 性能考量 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。 —- JavaScript Reference 考虑以下示例： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; };} 在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();}MyObject.prototype.getName = function() { return this.name;};MyObject.prototype.getMessage = function() { return this.message;};","link":"/2019/05/23/js-closures/"},{"title":"JavaScript 的 new 操作符","text":"JavaScript 的 new 操作符都做了些什么？如何用一个函数来模拟 new 呢？ 官方文档官方文档第一段中的说法： new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象（即 {}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤 1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this 。 官方文档在 “描述” 章节中的说法： 当代码 new Foo(...) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 要点根据上面两段描述，可以整理出以下要点： 使用 new 来调用时，构造函数的上下文的 this 是一个新创建的对象，继承自构造函数的原型（prototype） 当构造函数的返回值是一个对象的时候，返回这个对象，否则返回用作 this 的那个对象 根据这两个要点，可以用函数来表示 new 操作符的逻辑。 函数表示12345678function newOperator(Constructor, args) { const thisValue = Object.create(Constructor.prototype); const returnValue = Constructor.apply(thisValue, args); if (typeof returnValue === 'object' &amp;&amp; returnValue !== null) { return returnValue; } return thisValue;} 相关要点创建一个继承自特定对象的新对象最简单粗暴的方式是，创建一个对象，并且将原型指向继承的那个对象： 12const newObject = {};newObject.__proto__ = parentObject; 不过 JavaScript 不推荐直接使用 __proto__（下面会说），并且为我们提供了这样一个函数： 1Object.create(proto, [propertiesObject]); 参数： proto - 作为新创建对象的原型的对象 propertiesObject - 可选参数。如果提供，将作为 Object.defineProperties() 的参数来使用 不推荐直接使用 __proto__来自官方文档的警告： 警告：通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性, 这种行为在每一个 JavaScript 引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 obj.__proto__ = ... 语句上, 它还会影响到所有继承来自该 [[Prototype]] 的对象，如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]。相反, 创建一个新的且可以继承 [[Prototype]] 的对象，推荐使用 Object.create()。 警告：当Object.prototype.__proto__ 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在 ECMAScript 2015 规范中被标准化为传统功能，以确保 Web 浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。 Object.prototype 的 __proto__ 属性是一个访问器属性（一个 getter 函数和一个 setter 函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 null)。 简单来说，官方不推荐直接修改或者访问 __proto__ 属性，修改会有性能问题，如果要创建包含继承关系的对象，推荐用 Object.create()，如果要访问原型，建议只使用 Object.getPrototypeOf()。","link":"/2019/05/22/js-new-operator/"},{"title":"重新介绍 JavaScript（一）","text":"为什么会有这一篇 “重新介绍” 呢？因为 JavaScript 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤为必要。 本篇涉及类型、变量、运算符、对象以及数组。 与大多数编程语言不同，JavaScript 没有输入或输出的概念。它是一个在主机环境（host environment）下运行的脚本语言，任何与外界沟通的机制都是由主机环境提供的。浏览器是最常见的主机环境，但在非常多的其他程序中也包含 JavaScript 解释器，如 Adobe Acrobat、Photoshop、SVG 图像、Yahoo! 的 Widget 引擎，以及 Node.js 之类的服务器端环境。JavaScript 的实际应用远不止这些，除此之外还有 NoSQL 数据库（如开源的 Apache CouchDB）、嵌入式计算机，以及包括 GNOME （注：GNU/Linux 上最流行的 GUI 之一）在内的桌面环境等等。 —- JavaScript Reference 概览JavaScript 是一种面向对象的动态语言，包含了类型、运算符、内置对象和方法。语法源于 Java 和 C 语言。和 Java 的主要区别在于 JavaScript 不支持类，类的概念在 JavaScript 中通过对象原型与继承的方式来实现。JavaScript 支持函数式编程，因为 JavaScript 中函数也是一种对象，可以保存在变量中并当作参数传递。 类型JavaScript 的类型包括： Number（数字） String（字符串） Boolean（布尔值） Symbol（符号，ES6 新增的类型） Object（对象） Function（函数） Array（数组） Date（日期） RegExp（正则表达式） null（空值） undefined（未定义） 数字JavaScript 采用 IEEE 754 双精度 64 位数字表示法，并且不区分整数和浮点数类型，所有数字均为浮点数值（但是在具体实现时，整数通常被视为 32 位整型变量），所以在进行计算时需要特别注意，比如： 10.1 + 0.2 = 0.30000000000000004 JavaScript 的算数运算符包括加（+）、减（-）、乘（*）、除（/）、取余（%）以及乘方（**，ES7 新增的操作符）。 JavaScript 内置的 Math 对象用于处理更多的数学函数和常数。 可以使用内置函数 parseInt() 将字符串转换为整型。该函数的第二个参数表示字符串所表示数字的基（进制）： 12parseInt('123', 10); // 123parseInt('010', 10); // 10 如果调用时没有提供第二个参数（字符串所表示数字的基），则会根据字符串来确定进制，但是 2013 年以前的 JavaScript 实现会返回一个意外的结果： 12parseInt('010'); // 8parseInt('0x10'); // 16 因为旧版本的 JavaScript 会认为 '0' 开头的数字字符串是八进制，而新版本只会认为 '0o'开头的数字字符串是八进制。 还有其它方法可以将字符串转换成数字：一元加号 +、以及 Number 函数，它们两个的效果是一样的。 parseInt 和 parseFloat 方法会尝试逐个解析字符串中的字符，直到遇上一个无法被解析成数字的字符，然后返回该字符前所有数字字符组成的数字。而一元加号 + 和 Number 函数则是如果字符串中包含无法解析成数字的字符，结果都将会是 NaN。 字符串JavaScript 中的字符串是一串 Unicode 字符的序列。更准确地说，是 UTF-16 编码单元的序列，而每个 Unicode 字符由 1 或 2 个编码单元来表示。 字符串的方法无法区分 Unicode 字符，只能按照 UTF-16 编码单元来拆分字符串： 12const t = '😄😂';t.split('') === ['�', '�', '�', '�']; 而把字符串当作迭代器来使用的话，就可以根据 Unicode 字符来迭代字符串了： 12const t = '😄😂';[...t] === ['😄', '😂']; 其它类型JavaScript 中的 null 和 undefined 是不同的，前者代表空值（non-value），必须使用 null 关键字访问，后者是 “未定义” 类型的对象，表示未初始化的值，也就是尚未分配的值。 所有值都可以转换为布尔值，可能在判断中隐式转换或者使用 Boolean 函数显式转换，布尔值的转换规则为： false、0、空字符串 ''、NaN、null 和 undefined 被转换为 false 其它值都被转换为 true 变量在 JavaScript 中，可以通过 let、const 或 var 关键字来声明新变量。 let 语句可以声明一个块级作用域的变量，并可以使用一个值来初始化该变量。 12345let a;{ let name = 'Simon';}a = name; // 抛出异常，因为这里不可访问 name 变量 const 语句用于定义一个不可变的常量（对于对象类型的值，对象的成员仍然可能是可修改的）。const 语句必须指定一个值来初始化变量。 var 是最常见的声明变量的关键字。它没有其他两个关键字的种种限制。这是因为它是传统上在 JavaScript 声明变量的唯一方法。使用 var 声明的变量在它所声明的整个函数都是可见的。 JavaScript 与其他语言的（如 Java）的重要区别是在 JavaScript 中语句块（blocks）是没有作用域的，只有函数有作用域。因此如果在一个复合语句中（如 if 控制结构中）使用 var 声明一个变量，那么它的作用域是整个函数（复合语句在函数中）。 但是从 ES6 开始将有所不同的， let 和 const 关键字允许你创建块作用域的变量。 运算符二元加号 + 可以用来连接字符串，如果你用一个字符串加上一个数字（或其他值），那么操作数都会被首先转换为字符串。通过与空字符串相加，可以将某个变量快速转换成字符串类型。 对象JavaScript 的对象可以简单理解成键值对，与其它语言的一些概念类似： Python 中的字典 Perl 和 Ruby 的 Hash C/C++ 中的哈希表 Java 中的 HashMap PHP 中的关联数组 JavaScript 中，几乎一切都是对象，所以 JavaScript 程序必然与大量的散列表查找操作有着千丝万缕的联系，而散列表擅长的正是高速查找。 数组JavaScript 中的数组是一种特殊的对象。它的工作原理与普通对象类似（以数字为属性名，但只能通过 [] 来访问），但数组还有一个特殊的属性 —— length（长度）属性。这个属性的值通常比数组最大索引大 1。 注意，Array.length 并不总是等于数组中元素的个数，如下所示： 123var a = ['dog', 'cat', 'hen'];a[100] = 'fox';a.length; // 101 记住：数组的长度是比数组最大索引值多一的数。 数组的 push、pop、shift、unshift 方法可以数组头尾添加或删除元素（取出元素）。 数组的 splice(index, deleteCount, ...insertItems) 方法可以在数组指定位置删除或添加多个元素。 数组的 sort([cmpfn]) 方法可以依据 cmpfn 返回的结果进行排序，如果未指定比较函数则按字符顺序比较（即使元素是数字）。","link":"/2019/05/24/js-re-introduction-1/"},{"title":"JavaScript 中的相等性判断","text":"JavaScript 中提供了三种不同的值比较操作： 严格相等（”Strict Equality Comparison”, or “Identity”）：=== 宽松相等（”Abstract Equality Comparision”, or “Loose Equality”）：== 同值判断（”SameValue”）：Object.is（ECMAScript 2015 新特性） 而 ECMAScript 2015 中的相等算法则分为四种： 非严格相等比较（==） 严格相等比较（===），用于 Array.prototype.indexOf，Array.prototype.lastIndexOf 以及 switch...case 同值（Object.is） 同值零（”SameValueZero”），用于 %TypedArray% 和 ArrayBuffer 的构造函数，Map 和 Set 操作，以及 ECMAScript 2016 中的 String.prototype.includes 中 简而言之， == 将进行类型转换并比较 === 不会进行类型转换，比较两个值是否相同（如果类型不同，则总是返回 false） Object.is 的行为与 === 相同，但是对于 NaN，-0 和 +0 进行了特殊处理，Object.is(+0, -0) 为 false，而 Object.is(NaN, NaN) 为 true（根据 IEEE 754, 使用 == 或 === 比较两个 NaN 结果将为 false） “SameValueZero” 与 Object.is 类似，但认为 -0 和 +0 是相等的 而以上这些比较，虽然结果有所区别，但均属于判断两个值是否相同。对于两个不同的非原始对象，以上判断的结果都是 false。 严格相等 ===全等操作符（===）比较两个值是否相等，被比较的值不会进行隐式类型转换，判断逻辑如下： 如果两个值具有不同的类型，则不全等 如果两个值具有相同的类型和值，且不为 number 类型，则全等 如果两个值都是 number 类型，且不为 NaN，且数值相等，则全等 如果两个值都是 NaN，则不全等 如果两个值分别为 +0 和 -0，则全等 在日常使用中 === 几乎总是正确的。 对于数字之外的类型，全等操作符有明确的定义：一个值只与自身相等。 对于数字类型，定义稍加修改： 浮点数 0 是不分正负的，因为除了特定的数学问题，大部分情况都不关心 0 值的正负 浮点数包含 NaN 值，来表示定义不明确的数学问题的解（比如：正负无穷相加），=== 认为 NaN 和任何值都不相等，包括它自己 x !== x 成立的唯一条件就是 x 为 NaN，因此可以用来做 NaN 值判断 ECMA 规范中的定义：Section 11.9.6, The Strict Equality Algorithm 非严格相等 ==相等操作符（==）比较两个值是否相等，比较前将被比较的值转换为相同类型（等式的一边或两边都可能进行转换），然后进行 === 比较。相等操作符满足交换律。判断逻辑如下： 具有不同类型时： 如果两个值为 null 或 undefined，则相等 如果一个值为 null 或 undefined，另一个值为 number 或 string 或 boolean，则不相等 如果一个值为 null 或 undefined，另一个值为 object，则对 object 进行 “IsFalsy” 判断 如果一个值为 object，另一个值为 number 或 string，则对 object 进行 “ToPrimitive” 转换并判断是否全等 如果一个值为 object，另一个值为 boolean，则将 boolean 转换为 number 并对 object 进行 “ToPrimitive” 转换并判断是否全等 如果一个值为 number，另一个值为 string 或 boolean，则将另一个值转换为 number 并判断是否全等 如果一个值为 string，另一个值为 boolean，则都转换为 number 来判断 注： “ToPrimitive” 通过尝试调用 toString() 和 valueOf() 来将对象转换为原始值 转换为 number 的逻辑与一元 + 运算符相同 “IsFalsy” 判断：大部分浏览器允许非常窄的一类对象在某种情况下充当 undefined，仅当这种情况下，”IsFalsy” 判断为 true 有些开发者认为，最好永远都不要使用 ==，因为 == 的结果难以预测，且会进行隐式类型转换，=== 更加容易预测并更加快速。 ECMA 规范中的定义：Section 11.9.3, The Abstract Equality Algorithm 同值相等（”SameValue”）同值相等（”SameValue”）用于判断两个对象是否在任何情况下功能上是相同的，判断逻辑如下： 如果两个值具有不同的类型，则不同值相等 如果两个值具有相同的类型和值，且不为 number 类型，则同值相等 如果两个值都是 number 类型，且不为 NaN，且数值相等，则同值相等 如果两个值都是 NaN，则同值相等（与 === 相反） 如果两个值分别为 +0 和 -0，则不同值相等（与 === 相反） 比如 Object.defineProperty 在试图修改不可变属性的时候，如果值发生变化就会抛出异常，而值没有变化的话则什么都不做。这时就是用同值相等来判断值是否发生了变化。 1234567891011Object.defineProperty(Number, 'NEGATIVE_ZERO', { value: -0, writable: false, configurable: false, enumerable: false});function attemptMutation(v) { Object.defineProperty(Number, 'NEGATIVE_ZERO', { value: v });}attemptMutation(-0); // 不发生任何事情attemptMutation(+0); // 将抛出异常 这个算法在 ES5 中仅用于 JS 引擎的内部，ES6 中通过 Object.is 暴露了这个算法。 ECMA 规范中的定义：Section 9.12, The SameValue Algorithm 同值零相等（”SameValueZero”）同值零相等（”SameValueZero”）与同值相等类似，只是它认为 +0 和 -0 是相等的。 什么时候使用 Object.is？总的来说，除了对待 NaN 的方式不同，Object.is 与 === 的唯一区别就是对待 -0 和 +0 的不同。 下面这些方法和操作符会区别对待 -0 和 +0： 一元负号（Unary -） 一元负号在表达式的使用可能会无意识产生 -0，比如：obj.mass * - obj.velocity，如果 obj.mass 为 0，则会得到一个 -0 Math.atan2 Math.ceil Math.pow Math.round 这些函数即使参数中没有 -0，都有可能产生 -0 的结果 Math.floor Math.max Math.min Math.sin Math.sqrt Math.tan 这些函数当参数中有 -0 时，有可能产生 -0 的结果 ~ &lt;&lt; &gt;&gt; 这些操作符内部都使用了 ToInt32 算法。因为内部的 Int32 类型不区分 0 的正负，-0 在进行了这些操作后，不会保留负号。 因此在未考虑到 0 的符号的情况下使用 Object.is 可能得不到预期的效果。","link":"/2019/05/23/js-equality-and-sameness/"},{"title":"算法基础思想","text":"本篇介绍一些算法的基础思想。 包括：迭代、数学归纳法、递归、分治。（还讲了一下位运算和排列组合） 迭代迭代法（Iterative Method），在计算数学中，迭代是通过从一个初始估计出发寻找一系列近似解来解决问题（一般是解方程或者方程组）的数学过程，为实现这一过程所使用的方法统称。 而在计算机中，迭代是程序中对一组指令（或一定步骤）的重复。它既可以被用作通用的术语（与 “重复” 同义，此时迭代的定义包括了递归），也可以用来描述一种特定形式的具有可变状态的重复（就是一般我们所说的迭代，与递归相对的概念）。迭代很容易通过循环语句来实现。 应用： 通过不断逼近来求某个数值或其近视值。典型方法包括二分法和牛顿法。 在一定范围内查找目标值。典型方法如二分查找。 机器学习算法中的迭代。比如 K-均值算法、PageRank 的马尔可夫链、梯度下降法等。 案例 1 二分法求平方根近似值1234567891011121314151617181920212223242526272829/** * @param {number} n 待求平方根的数 * @param {number} e 相对误差要求 * @param {number} limit 迭代次数限制 * @return {number} */function getSquareRootOf(n, e = 0.00000001, limit = 100000) { if (n &lt; 0) { return NaN; } if (n === 0 || n === 1) { return n; } let min = n &gt; 1 ? 1 : n; let max = n &gt; 1 ? n : 1; for (let times = 0; times &lt; limit; times += 1) { const middle = min + (max - min) / 2; const square = middle * middle; const diff = Math.abs(square / n - 1); if (diff &lt; e) { return middle; } else if (square &gt; n) { max = middle; } else { min = middle; } } return min + (max - min) / 2;} 技巧 1 使用 min + (max - min) / 2 而不是 (min + max) / 2 来防止计算溢出 技巧 2 计算相对误差来使迭代次数相对稳定（Math.abs(square / n - 1)） 案例 2 二分查找二分查找的条件为：数组的元素是可比较的，且数组是有序的（或者说，需要先排序的）。 12345678910111213141516171819202122232425/** * @param {number} value 待搜索的值 * @param {number} array 搜索的数组 * @param {number} isSorted 数组是否有序（是否需要排序） * @return {boolean} */function bisectionSearch(value, array, isSorted = false) { if (!isSorted) { array = array.sort((a, b) =&gt; a - b); } let left = 0; let right = array.length - 1; while (left &lt; right) { const middle = Math.floor(left + (right - left) / 2); const current = array[middle]; if (current === value) { return true; } else if (current &lt; value) { left = middle; } else { right = middle; } } return false;} 数学归纳法使用数学归纳法可以从理论上证明一些结论的成立而避免迭代计算。 数学归纳法（Mathematical Induction、MI、ID）是一种数学证明方法，通常被用于证明某个给定命题在整个（或者局部）自然数范围内成立。除了自然数以外，广义上的数学归纳法也可以用于证明一般良基结构，例如：集合论中的树。这种广义的数学归纳法应用于数学逻辑和计算机科学领域，称作结构归纳法。 使用数学归纳法证明通常需要以下两步： 证明基本情况（$ n=1 $）时，结论成立； 假设 $ n=k $ 时结论成立，证明 $ n=k+1 $ 时结论也成立（$ k $ 为任意大于 0 的自然数）。 以上两步的条件不是绝对的，基本情况的条件，以及第二步的递推条件都是可以修改的。当然，修改后结论成立的范围也需要重新审视。 案例 3 棋盘麦粒古印度一位宰相将受到国王赏赐麦粒，国王问他要多少麦粒，他拿出一个 8x8 的棋盘，说在第一个格子里放 1 粒、第二个格子里放 2 粒、之后每一个格子都放前一个个格子的 2 倍数量的麦粒，他需要放完这个棋盘所有格子的麦粒。 这一题（n 个格子的麦粒总数）最直接的方式就是通过迭代来解答： 123456789function countWheats(latticeCount) { let sum = 0; let current = 1; for (let i = 0; i &lt; latticeCount; i += 1) { sum += current; current *= 2; } return sum;} 不过我们可以发现，n 个格子的麦粒总数为 $ 1 + 2 + 2^2 + 2^3 + … + 2^{n-1} = 2^n-1 $，我们可以用数学归纳法来证明这个结论。 我们用 $ f(n) $ 来表示前 n 个格子的麦粒总数。 $ n=1 $ 时，$ f(n) = 1 = 2^0 - 1 $，结论成立 假设 $ f(n) = 2^n - 1 $，那么 $ f(n + 1) = f(n) + 2^n = 2^n + 2^n - 1 = 2^{n+1} - 1 $，结论成立 通过以上步骤，我们成功证明了结论在 n 为正整数的情况下均成立。 所以这个解答可以简化为： 123function countWheats(latticeCount) { return 2 ** latticeCount - 1;} 但是这个案例，通过浮点数计算乘方可能会损失精度，如果需要精确的值，我们需要使用 BigInt 类型来表示数值，通过迭代得到精确值。 递归递归（Recursion）在数学和计算机科学中，是指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。 观察数学归纳法的证明过程，我们可以发现，只要在 $ f(n) $ 值已知的情况下可以求的 $ f(n+1) $ 的值，并且能够得到初始条件下的值，我们就可以求得任意大于初始条件的情况下的 $ f(n) $。 例如案例 3，我们也可以通过递归来得到答案： 123456function countWheats(n) { if (n === 1) { return 1; } return countWheats(n - 1) + 2 ** (n - 1);} 递归的条件在于，我们已知基本情况的结果，而对于复杂情况，我们能够一步步地简化，直到简化为基本情况。 案例 4 列出 N 局猜拳获胜的所有情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const ROCK = '石头';const SCISSORS = '剪刀';const PAPER = '布';const shapes = [ROCK, SCISSORS, PAPER];const compare = (a, b) =&gt; { if (a === b) { return 0; } if ( (a === ROCK &amp;&amp; b === SCISSORS) || (a === SCISSORS &amp;&amp; b === PAPER) || (a === PAPER &amp;&amp; b === ROCK) ) { return 1; } return -1;};/** * @param {number} games 还有多少场比赛要比 * @param {[string, string][]} stack 已经比过的比赛的出拳方式 * @return {number} 获胜的情况数量 */function winCaces(games = 1, stack = []) { // 还有比赛要比 if (games &gt; 0) { let count = 0; for (const thisSide of shapes) { for (const thatSide of shapes) { count += winCaces(games - 1, [...stack, [thisSide, thatSide]]); } } return count; } else { const totalScore = stack .map(([thisSide, thatSide]) =&gt; compare(thisSide, thatSide)) .reduce((sum, score) =&gt; sum + score, 0); if (totalScore &gt; 0) { console.log(stack.map(pair =&gt; pair.join('vs')).join(', ')); return 1; } return 0; }}const count = winCaces(3);console.log('如上，一共' + count + '种获胜情况'); 分治在上一节递归中，我们知道了一种基于数学归纳的将复杂问题逐步简单化的方式，但是还有一些复杂问题可能无法通过逐步归纳的方式来简单化，比如二分查找、归并排序等等。这一节我们介绍另一种将复杂问题简单化的思想 —- 分治。 在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 这个技巧是很多高效算法的基础，如排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。 案例 5 归并排序归并排序是一种典型的使用分治思想的算法。它的核心步骤 “归并” 就是将两个有序的数组合并成一个有序的数组。归并排序就是将原数组分解成若干个长度为 1 的小数组，最后再归并成一个大数组的方法。 由于归并过程的复杂度为 $ O(n) $，分解的次数为 $ O(\\log_2{n}) $，归并排序的时间复杂度为 $ O(n\\log_2{n}) $。由于归并过程总是产生相同长度的数组，归并排序的空间复杂度为 $ O(n) $。 12345678910111213141516171819202122function mergeSort(array) { if (array.length &lt; 2) { return array; } const middle = Math.floor(array.length / 2); const left = mergeSort(array.slice(0, middle)); const right = mergeSort(array.slice(middle)); return merge(left, right);}function merge(a, b) { const c = []; let ia = 0; let ib = 0; while (ia &lt; a.length &amp;&amp; ib &lt; b.length) { c.push(a[ia] &lt;= b[ib] ? a[ia++] : b[ib++]); } return c.concat(ia &lt; a.length ? a.slice(ia) : b.slice(ib));}const sorted = mergeSort([1, 5, 4, 6, 7, 2, 4, 6, 7, 8, 1, 2, 4]);console.log(sorted); 位运算位运算包括：左移、右移、与、或、非、异或。 异或有以下性质：x ^ x = 0、0 ^ x = x。 位运算由于其性质，在解决一些问题时有奇效。 案例 6 使用位运算判断奇偶再一些语言中，位运算比取余运算要快得多，可以使用位运算来判断奇偶，来节省执行时间。 1const isOdd = number =&gt; (number &amp; 1) === 1; 案例 7 不使用额外空间来交换整型变量利用异或的特性，我们可以不使用额外的变量就可以交换两个变量的值。 $$\\begin{align}x &amp;= x_0, y = y_0 \\\\x &amp;= x \\oplus y = x_0 \\oplus y_0 \\\\y &amp;= x \\oplus y = x_0 \\oplus y_0 \\oplus y_0 = x_0 \\\\x &amp;= x \\oplus y = x_0 \\oplus y_0 \\oplus x_0 = y_0 \\\\\\end{align}$$ 12345function swap(arr, i, j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j];} 位的集合操作位数组可以用来描述一组相互独立的布尔状态，通常可以用整型来表示。 比如，带分类的碰撞检测。我们要让魔法飞弹不能与建筑物碰撞，只能与怪物碰撞。 我们让每一个类型包括两个位数组属性，一个表示自身的分类，一个表示可以碰撞的分类。 123456789101112131415161718192021222324252627282930class Collision { mask = 0; hitMask = 0; canHit(other) { return (this.hitMask &amp; other.mask) !== 0; }}const Bit = { Monster: 1 &lt;&lt; 0, Building: 1 &lt;&lt; 1, MagicBullet: 1 &lt;&lt; 2};// 怪物可以与其它怪物、建筑、魔法飞弹碰撞class Monster extends Collision { mask = Bit.Monster; hitMask = Bit.Monster &amp; Bit.Building &amp; Bit.MagicBullet;}// 建筑可以与其它建筑、怪物碰撞class Building extends Collision { mask = Bit.Building; hitMask = Bit.Monster &amp; Bit.Building;}// 魔法飞弹只能与怪物碰撞class MagicBullet extends Collision { mask = Bit.MagicBullet; hitMask = Bit.Monster;} 排列与组合排列与组合一般用于分析或者列出所有可能的情况，即穷举法。 排列（permutation），数学的重要概念之一。从 n 个不同元素中每次取出 m（1≤m≤n）个不同元素，排成一列，称为从 n 个元素中取出 m 个元素的无重复排列或直线排列，简称排列。从 n 个不同元素中取出 m 个不同元素的所有不同排列的个数称为排列种数或称排列数，记为 $ P_n^m $（或 $ A_n^m $）。 $$P_n^m = n(n-1)(n-2)…(n-m+1) = \\frac{n!}{(n-m)!}$$ 特别的，将 n 个元素全部取出来排列的排列数成为全排列，记为 $ P_n $。 $$P_n = n! $$ 重复排列（permutation with repetiton）是一种特殊的排列，从 n 个元素中可重复地选取 m 个元素，按照一定的顺序排成一列，称作从 n 个元素中取 m 个元素的可重复排列。重复排列的排列数为 $ n^m $。 组合（combination），数学的重要概念之一。从 n 个不同元素中每次取出 m 个不同元素（0≤m≤n），不管其顺序合成一组，称为从 n 个元素中不重复地选取 m 个元素的一个组合。所有这样的组合的总数称为组合数，记为 $ C_n^m $。 $$C_n^m = \\frac{P_n^m}{P_m} = \\frac{n!}{m!(n-m)!}$$ 基本性质： $$\\begin{align}&amp;C_n^m = C_n^{n-m} \\\\&amp;C_{n+1}^m = C_n^m + C_n^{m-1} \\\\&amp;\\sum_{k=0}^{n}{C_n^k} = 2^n \\\\\\end{align}$$ 重复组合（combination with repetiton）是一种特殊的组合。从 n 个不同元素中可重复地选取 m 个元素。不管其顺序合成一组，称为从 n 个元素中取 m 个元素的可重复组合。从 n 个不同元素中可重复地选出 m 个元素的不同组合种数记为 $ H_n^m $。 $$H_n^m = \\frac{(n+m-1)!}{m!(n-1)!}$$","link":"/2019/06/06/algorithm-basis/"},{"title":"Node.js 中的事件循环","text":"Node.js 中有一些用于稍后执行的函数，比如 setTimeout(fn, ms)，setImmediate(fn) 以及 process.nextTick(fn)。如何区分它们，将与 Node.js 的事件循环机制息息相关。 本文主要参考另一篇文章进行转述。 一些常见的误解 事件循环是 JS 引擎来处理的 最常见的误解就是，事件循环是 JavaScript 引擎（V8、SpiderMonkey 等）的一部分。实际上，事件循环只用到 JS 引擎来执行 JavaScript 代码。Node.js 的事件循环是由 libuv 来完成的。 有一个栈或者队列来管理回调函数 首先排除用栈，其次也不是一个单一的队列。这个过程是复杂的，有多个队列（比如数据结构中的队列）参与。 事件循环运行在一个单独的线程里面 因为一些错误的 Node.js 事件循环图，很多人认为有两个线程，一个执行 JavaScript 代码，另一个执行事件循环。事实上，这两个是在同一个线程执行的。 在 setTimeout 中有系统的参与 另一个非常大的误解是 setTimeout 的回调函数在给定的延迟完成之后被（可能是 OS 或者内核）推进一个队列。 setImmediate 将回调函数放在第一个位置 作为常见的事件循环描述只有一个队列，所以一些开发者认为 setImmediate 将回调放在工作队列的前面。然而这是不正确的。 事件循环的结构下图描述的是 Node.js 中的事件循环过程： 事件循环分为 6 个阶段，每个阶段负责特定的任务。每个阶段都有独立的队列（或其它用作队列的数据结构），JavaScript 代码可以在空闲/准备阶段之外的 5 个阶段执行。图中的 nextTick 队列与微任务队列不属于事件循环的一部分，而是在任何阶段都可以执行，它们有比事件循环更高的优先级。 计时器阶段（Timer） 计时器阶段是一个循环的开始，这个阶段处理计时器（setTimeout、setInterval）的回调。 计时器队列是一个最小堆，它用于保留计时器和其回调。计时器阶段会检查计时器队列中过期的计时器，并执行它们的回调。 I/O 回调阶段（Pending I/O Callbacks） 这个阶段执行 Pending Queue 中的回调。这些回调是在之前的操作中加入到队列的（一般是 I/O 操作完成时加入的）错误处理的回调也将在这里执行。 空闲/等待阶段（Idle, Prepare） 这个阶段主要执行 Node.js 的一些内部操作，暂时不讨论其内容。 轮询阶段（Poll） 这个阶段接受新传入的连接（建立 Socket 等等）和数据（读取文件等待）。这个阶段大致可以分成两个部分： 如果 Watch Queue 里面有任务，它们将依次被执行。 一旦队列空了，Node.js 就会等待新的连接或数据。等待的时间取决于多种因素（待会再看） 检查阶段（Check） 轮询阶段专门用于处理 setImmediate 设置的回调。 关闭回调（Close） 关闭回调都是在这里处理的，像一个清理的阶段。 nextTick 队列与微任务队列 nextTick 队列中保存 process.nextTick() 设置的回调。而微任务队列保存 Promise 中的回调。它们不属于事件循环（libuv）的一部分，而是 Node.js 的一部分。在 C/C++与 JavaScript 交叉的过程中，它们都是尽可能快地被调用（不一定是当前的回调完成时）。 事件循环的流程当你用 Node.js 执行一段 JavaScript 脚本时，Node.js 首先进行执行脚本前的准备（比如准备全局环境、初始化事件循环等），然后解析并执行代码（所有同步代码以及微任务将在这时候被执行），执行完代码，将检查循环是否还有事情要做（Alive），如果没有，将进入进程结束流程，否则将进入事件循环。 计时器阶段根据前面的描述，计时器阶段将检查过期的计时器并执行回调。 具体来说，计时器队列（最小堆）以时间升序来保存计时器。每次都检查堆顶的计时器是否过期，如果过期就取出队列并执行回调，否则直接进入下一个阶段（因为后面的计时器都一定没有过期）。 当然，事件循环的每个阶段执行的任务数量是有最大限制的，达到这个数量后，即使有过期的计时器也不会执行，直接进入下一阶段。 I/O 回调阶段I/O 回调阶段检查 Pending Queue 中是否有任务，如果有，依次执行，直到队列为空或者达到系统限制。 之后将进入空闲阶段（Idle），然后 Node.js 将做一些内部准备，并进入轮询阶段。 轮询阶段这个阶段首先检查 Watcher Queue 中是否有任务（比如文件读响应，Socket 连接请求、HTTP 连接请求等），如果有，将依次执行，直到队列为空或者达到系统限制。 如果没有要执行的回调，轮询阶段在某些条件下将等待一会儿。 如果关闭阶段、空闲阶段、I/O 回调阶段或者关闭阶段任意一个队列有任务在等待，则轮询阶段将等待 0ms，并进入检查阶段。 否则它将检查计时器队列的堆顶，并决定等待时间（如果已过期，则等待 0ms） 检查阶段这个阶段将执行被 setImmediate 设置的回调，直到队列为空或者达到系统限制。 关闭阶段这个阶段将执行处理关闭或者销毁的 close 回调。这个阶段完成后，将再次检查循环是否活着（还有任务要做）。如果没有，将退出事件循环，进入进程结束阶段；如果有，将再次进入计时器阶段。 nextTick 队列与微任务队列这两个队列会在一个阶段结束时尽可能快的运行。不像其他阶段，它们两个没有系统设置的最大限制，node 运行它们直到两个队列是空的。但是，nextTick 队列会比微任务队列有更高的任务优先级。 根据另一篇文章的解释，这两个队列会在每个阶段结束前按顺序执行，直到它们为空。 进程池（Thread Pool）一个普遍的误解是 Node.js 有一个处理所有异步操作的进程池。 实际上，进程池是 libuv 的一部分，但不属于事件循环机制的一部分。而且并不是每个任务都要被进程池处理。libuv 能够灵活运用操作系统的异步 API 来保持环境为事件驱动的。而操作系统的异步 API 无法处理的任务（比如：DNS 查询、文件读取等），将由进程池来处理。进程池默认有 4 个进程，可以通过环境变量 uv_threadpool_size 来设置它的进程数量（最多可设置 128 个）。 帮助理解的例子基础理解下面代码的打印顺序如何？ 123456setTimeout(() =&gt; { console.log('setTimeout');}, 0);setImmediate(() =&gt; { console.log('setImmediate');}); 你可能会认为是 ‘setTimeout’ 先被打印出来，或者 ‘setImmediate’ 先被打印出来。但是，这个例子的打印顺序是不确定的。因为在计时器阶段，可能不会检查到计时器过期。 首先，根据 Node.js 的文档，setTimeout 的延时小于 1ms 或者大于 2147483647ms 时，将重置为 1ms。进入计时器阶段时，会记录一个时间，然后根据执行代码时的系统性能表现，检查计时器时，可能已经经过了 1ms，也可能没有经过。所以在第一次循环 ‘setTimeout’ 不一定会被打印，而 ‘setImmediate’ 一定会被打印。 但是，如果这段代码位于 I/O 回调中的话，’setImmediate’ 一定会在 ‘setTimeout’ 之前被打印。 更好地理解计时器123456789101112let i = 0;const start = new Date();function foo() { i++; if (i &lt; 1000) { setImmediate(foo); } else { const end = new Date(); console.log('Execution time: ', end - start); }}foo(); 上面的例子是连续使用 setImmediate 设置回调，直到 i == 1000。在我的 Macbook Pro 上面用 Node.js 10.14.1 执行，大约需要 80ms。 把其中的 setImmediate 修改为 setTimeout： 123456789101112let i = 0;const start = new Date();function foo() { i++; if (i &lt; 1000) { setTimeout(foo, 0); } else { const end = new Date(); console.log('Execution time: ', end - start); }}foo(); 在同样的环境下执行修改后的代码，将需要约 1400ms 毫秒。 它们的差距在于，首先 setTimeout 至少会产生 1ms 的延时，其次 setTimeout 需要花一些时间来注册计时器，而计时器阶段的过期检查也需要一些开销。而再 setImmediate 的阶段，再回调中注册 setImmediate 将导致队列仍不为空，所以也不会跳出这一阶段（直到系统限制），将进行更少的循环，也节省了一些时间。 nextTick() 与计时器12345678910111213let i = 0;function foo() { i++; if (i &gt; 20) { return; } console.log('foo'); setTimeout(() =&gt; { console.log('setTimeout'); }, 0); process.nextTick(foo);}setTimeout(foo, 2); 上面的例子将输出 20 次 ‘foo’，再输出 20 次 ‘setTimeout’。2 秒后，连续进行nextTick() 调用，然后检查别的任务（setTimeout）。 所以是每个回调执行完之后，开始检查 nextTick 队列的吗？再看看下面的例子。 12345678910111213141516let i = 0;function foo() { i++; if (i &gt; 20) { return; } console.log('foo', i); setTimeout(() =&gt; { console.log('setTimeout', i); }, 0); process.nextTick(foo);}setTimeout(foo, 2);setTimeout(() =&gt; { console.log('Other setTimeout');}, 2); 这个例子很可能会在第一个 ‘foo’ 打印之后打印 ‘other setTimeout’。 相同的计时器分成一组，nextTick 队列会在这组回调执行完之后执行。 一些普遍的问题 JavaScript 代码是在哪里执行的？ 大多数人会认为事件循环有一个独立的线程执行，将回调推入一个队列，然后负责执行 JavaScript 的线程来依次执行。然而，事件循环和 JavaScript 的执行是同一个线程里的。所以，如果 JavaScript 代码不完成的话，事件循环不会向后走。 为什么有了 setTimeout(fn, 0) 还需要 setImmediate(fn)？ 因为 setTimeout(fn, 0) 的 0 不是 0ms，而是 1ms（因为至少要 1ms）。其次，setImmediate 可以减少额外的检查。而且 setImmediate 设置的回调将于轮询阶段的下一个阶段执行，因此用于 I/O 回调中，可以尽早执行。 为什么 setImmediate 与 process.nextTick 的意思相反？ 因为历史原因导致的命名问题。 如果在进程结束回调中使用 setTimeout 会如何？ 它也许会创建计时器，但是回调将不会被调用。因为这时已经结束了事件循环。","link":"/2019/05/27/node-event-loop/"},{"title":"理解 Node.js 中的垃圾回收机制","text":"虽然 Node.js 的学习曲线非常平坦，但是保持 Node.js 运行的机制非常复杂。为了避免一些性能缺陷，我们必须理解其机制。 这篇文章将介绍 Node.js 的内存管理方式。 V8 引擎是 Google 为 Chrome 浏览器而开发 JavaScript 引擎，但同时也可以脱离 Chrome 独立使用。Node.js 内部就是使用了 V8 引擎来执行 JavaScript 代码。 在 Node.js 中 V8 引擎负责编译并执行 JavaScript 代码、为 JavaScript 的变量和对象分配内存以及进行垃圾回收。 V8 的内存管理机制像 C 这样的语言是将内存管理全权交给开发者来管理，开发者来决定分配多少的内存并何时释放，一旦开发者忘记释放，那么这片内存将永远被占用，且无法使用。而在 JavaScript 中，内存管理是交给引擎来做的，开发者不必考虑何时去释放不再使用的内存。 在 V8 引擎中，是通过垃圾回收机制来管理内存的。垃圾回收机制通过定期检查来找出那些已经无法被访问到的对象来清楚它们使用的内存。 通过自动的垃圾回收机制，我们不需要再管理内存，可以更加专注于应用的逻辑。但是同时，如果我们对其机制不了解，就可能会写出具有缺陷的代码，造成内存泄漏。 V8 的内存分配结构V8 中为 JavaScript 所分配的内存空间称为常驻内存集（Resident Set），其中包括用于存放代码逻辑的代码段（Code Segment，这里是存放包含 JIT 指令处理过的特殊对象），用于存放局部变量或引用的栈（Stack）以及用于存放对象与闭包的堆（Heap）。 在 Node.js 中，可以通过内置 API 来获取内存使用信息： 12345console.log(process.memoryUsage());// { rss: 23752704,// heapTotal: 9682944,// heapUsed: 5774144,// external: 33920 } 其中： ‘rss’（Resident Set Size）代表常驻内存集的大小 ‘heapTotal’ 代表堆大小 ‘heapUsed’ 代表堆中已使用空间的大小（用来判断内存泄漏） ‘external’ 代表 V8 引擎内部的 C++对象所占用的空间 由于 V8 是为浏览器开发的引擎，不太可能会遇到使用大量内存的场景，所以它默认的可分配内存上线设置的不大，64 位系统下约为 1.4GB，32 位系统中约为 700MB。 V8 的垃圾回收机制回看 JavaScript 中的垃圾回收机制，一般分为两种：引用计数机制与标记清除机制。其中 IE6 使用的是引用计数机制，现代浏览器使用的都是标记清除机制。 引用计数机制（IE6 等）引用计数机制记录对每个对象的引用的数量，当数量为 0 时，引用计数机制就认为可以清除这个对象了。 引用计数机制有一个很严重的缺陷：循环引用导致的内存泄漏。 例如： 123456function showPitfall() { const a = {}; const b = {}; a.b = b; b.a = a;} 在这个例子中，a 和 b 对对方都有一个引用，因此在函数执行完后，它们的引用计数也不为 0，将永远不会被清除。 但其实我们经常在写隐含着循环引用的代码，例如： 1234const element = document.querySelector('#el');element.onclick = function onclick(event) { console.log('#el is clicked.');}; 这个例子中，onclick 函数形成了一个可以访问 element 的闭包，而 element 上又绑定了 onclick 这个函数，element 与闭包之间形成了循环引用。 标记清除机制（V8 等）标记清除算法在对象中添加一个标记，通过对可访问的对象设置标记来识别出那些不可被访问的对象。 通常标记清楚算法会选取一些根节点，比如 window 对象，然后将所有根节点及其子节点标记为活跃，所有从根节点可访问的对象都视为不可删除。 所有没有被标记的对象都是可以清除的。 现代浏览器的引擎通过不同的方法来优化这个机制，但本质都是一样的。 在这种机制下，内存泄漏通常是由于我们保存了不必要的引用。 比如： 不必要的全局变量，比如在宽松语法下意外声明的全局变量（未使用声明关键字或者不正确地使用 this 关键字） 12345function foo() { bar = 'This is an implicit global variable'; this.bar = 'This is an implicit global variable via this';}foo(); 忘记清除地计时器或者其他回调 12345678910function startSettingHTML() { const someData = getData(); setInterval(function() { const node = document.querySelector('#node'); if (node) { node.innerHTML = JSON.stringify(someData); } }, 1000);}startSettingHTML(); 这个例子中，计时器的回调函数产生了一个可以访问 someData 的闭包，由于计时器没有被清除，即使 #node 元素不再存在，这个回调不再有意义，someData 也不会被清除。 保留了 DOM 节点的引用 有时候为了方便使用，会在代码中保存对 DOM 节点的引用。如果你忘记清除该引用，那么由于子节点会保留父节点的引用，即使父节点从 DOM 树中移除，子节点这条链上的元素都无法被清除。（比如保留 tr 元素的引用，之后删掉整个 table，但是 table 还会一直在内存里） 12345678910111213window.inputs = {};window.forms = {};// ...forms.login = document.querySelector('#login-form');inputs.password = forms.login.querySelector('.password-input');inputs.password.onkeyup = validatePassword;// ...function onLogin() { forms.login.remove(); // forms is just like inputs, stores DOM elements. froms.login = null;}// 只要 inputs.password 不清除，#login-form 就一直无法清除 闭包 12345678910111213141516let theThing = null;let replaceThing = function() { let originalThing = theThing; let unused = function() { if (originalThing) { console.log('originalThings exists.'); } }; theThing = { longString: '*'.repeat(1000000), someMethod() { console.log('some message'); } };};setInterval(replaceThing, 1000); 这是个由微妙的方式导致内存泄漏的例子（Metero 的开发者发现了这个漏洞，并在这篇文章中有详细描述）。V8 可以识别闭包中是否使用了变量，但是这个例子中，unused 和 someMethod 共享了闭包作用域，而 unused 中使用了 originalThing，迫使 originalThing 处于活跃状态。 V8 的垃圾回收策略标记擦除机制会对所有可访问的对象进行标记，这在对象较多时是一个很耗时的操作，V8 通过分代管理内存的方式来降低这个消耗。 分代内存基于一种假设：大部分新生对象倾向于早死，无法存活多次 GC 周期；能够存活多个 GC 周期的对象都比较长寿。 V8 的分代内存管理就是将堆内存空间划分为新生代（New Generation）空间和老生代（Old Generation）空间，对它们采用不同的垃圾回收算法。 新生代的对象存活时间较短，为经历过 0 次或 1 次 GC 的对象。 老生代的对象存活时间较长，为经历过 2 次或以上 GC 的对象。 默认情况下，64 位系统下，新生代空间为 32MB，老生代空间为 1.4GB，32 位系统下，新生代空间为 16MB，老生代空间为 700MB。 将新生代中的对象转移到老生代的过程称为晋升。 新生代的内存管理算法1、分配方式 新生代存放的都是生存周期短的对象，分配内存也比较容易，只保存一个指向内存空间的指针，根据分配对象大小递增指针即可，当存储空间快要满时，进行一次垃圾回收。 2、垃圾回收算法 新生代采用 Scavenge 垃圾回收算法，算法实现时主要采用 Cheney 算法。 Cheney 算法将内存均分为两个 semispace，一块处于使用状态（称为 From 空间），一块处于闲置状态（称为 To 空间）。 Cheney 算法的过程如下： 从 From 空间分配对象，如果 From 空间被占满，则执行 Scavenge 算法进行垃圾回收。 检查 From 空间的存活对象，如果对象存活，检查是否满足晋升条件，如果满足则晋升到老生代，不满足则复制到 To 空间。 如果对象不存活，则释放其使用的空间。 完成上述过程后，反转 From 空间与 To 空间。 对象晋升条件对象晋升的条件有两个： 对象是否经历过 Scavenge 回收。如果已经经历过一次 Scavenge，则将对象晋升，否则复制到 To 空间。 To 空间的使用率是否超过限制（25%）。如果超过 25%的限制，则直接分配至老生代。设置 25% 的原因是，如果反转 semiplace 之后，空间占用比过高，会影响后续内存分配。 老生代的内存管理算法老生代与新生代不同，不适合用 Scavenge 算法进行垃圾回收： 老生代的存活对象的比例更高，复制存活对象的操作会很多 老生代的空间远大于新生代，采用 Scavenge 算法将空间分为两部分将造成很大的浪费。 老生代内存空间的垃圾回收有两种方式：标记清除（Mark Sweep）和标记合并（Mark Compact）。 1、标记清除 标记清除算法在标记阶段对死掉的对象进行标记，并且在回收阶段直接释放掉对应的内存空间。 标记清除算法只清除死掉的对象，Scavenge 算法只复制存活的对象，而在老生代中死对象的比例较低，新生代中存活对象的比例较低，所以这两种算法都能够较高效地进行垃圾回收。 但是，标记清除这种方式会产生内存空间碎片化（占用空间不连续）的问题。 2、标记合并 为了解决标记清除的空间碎片化问题，我们需要引入标记合并算法。 标记合并算法在标记阶段和标记清除一样，对死对象进行标记，在回收阶段，将存活的对象向内存空间的一端移动，然后直接将这部分之外的内存占用全部清除掉。 3、两者的结合 很明显，标记合并涉及到很多内存复制操作，效率要比标记清除低很多。 在 V8 中，老生代主要使用标记清除进行垃圾回收，只有当空间不足以从新生代晋级新对象的时候才会使用标记合并算法。 总结 Node.js 中的的垃圾回收就是 V8 的垃圾回收 V8 主要使用标记清除算法 V8 的堆分为两块：新生代与老生代 新生代存放没有或仅经历一次 GC 的对象，使用 Scavenge 算法进行 GC 老生代存放从新生代晋升的对象，结合标记清除与标记合并两种算法进行 GC","link":"/2019/06/21/nodejs-understanding-gc/"},{"title":"自己实现一个 Promise 类","text":"自从 ES6 引入的 Promise 将我们从回调地狱中解放了出来，ES7 提出的 async/await 特性更是进一步地简化了异步代码的编写。 那么我们就通过自己实现一个 Promise 类，来一窥其内部的奥秘（本文将遵照 Promise/A+ 规范实现 Promise，并且添加一些常用的函数） 本文将新的 Promise 类命名为 Future（参考 Dart 中与 Promise 对应的概念的名称） 本文为了模拟 Promise 的微任务，使用 Node.js 的 process.nextTick 函数来产生微任务。并且本文将使用 ES2015+ 语法来实现。 基本实现首先我们不考虑结果为 Promise 或者 thenable 的情况。 构造器首先我们知道，Promise 的构造器需要传入一个函数（我们称为 executor），这个函数有 resolve、reject 两个参数，分别用于将 Promise 的状态设为成功（fulfilled）或者失败（rejected），并且如果这个函数抛出错误，Promise 也将失败。而 Promise 一开始就具有待定（pending）状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 属性常量 */const state = Symbol();const result = Symbol();/* 状态常量 */const PENDING = Symbol();const REJECTED = Symbol();const FULFILLED = Symbol();/* 工具函数 */// 设置不可枚举属性const defineProperty = (obj, key, value) =&gt; Object.defineProperty(obj, key, { value, writable: true, configurable: false, enumerable: false });class Future { constructor(executor) { // 参数检查 if (typeof executor !== 'function') { throw new Error('Future executor undefined is not a function'); } // 设置状态、结果属性 defineProperty(this, state, PENDING); defineProperty(this, result, undefined); // 成功处理函数 const resolveFunction = value =&gt; { if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; } }; // 失败处理函数 const rejectFunction = reason =&gt; { if (this[state] === PENDING) { this[state] = REJECTED; this[result] = reason; } }; try { executor(resolveFunction, rejectFunction); } catch (err) { rejectFunction(err); } }} 这里简化了 “私有” 属性的声明，使用私有 Symbol 作为不可枚举属性的名称，可以防止外部模块访问（实际上，使用 Object.getOwnPropertySymbols 仍然可以得到这些 Symbol，但是需要额外的判断来确定 Symbol 的作用）。 then 方法我们知道，Promise 的 then 方法可以传入两个参数作为回调，分别处理成功和失败的情况，而这两个参数分别只有在类型为函数的情况下，才认为有效，其余情况会忽略。then 函数会返回一个新的 Promise，用于处理 then 的回调产生的结果（或者没有设置对应回调的情况下，处理原 Promise 的结果）。 为了使原 Promise 可以处理 then 的回调，我们定义两个队列用于存放回调。 1234567/* 属性常量 */const onFulfilledCallbacks = Symbol();const onRejectedCallbacks = Symbol();// @{Future.constructor} 在 Promise 的构造器中设置回调队列defineProperty(this, onFulfilledCallbacks, []);defineProperty(this, onRejectedCallbacks, []); 在对应的处理函数中，调用这些回调： 12345678910111213// 成功的时候，调用所有成功回调队列中的函数this[state] = FULFILLED;this[result] = value;this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result]));});// 失败的时候，调用所有失败回调队列中的函数this[state] = REJECTED;this[result] = reason;this[onRejectedCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result]));}); 做好这些准备，我们就可以开始实现 then 函数了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Future { // constructor(executor) { ... } then(onFulfilled, onRejected) { const newFuture = new Future((resolve, reject) =&gt; { // 设置原 Promise 成功处理函数 const onPrevFulfilled = value =&gt; { if (typeof onFulfilled !== 'function') { // 如果没有设置成功回调，则直接使用原 Promise 的成功结果 resolve(value); } else { // 如果设置了成功回调，则用成功的结果为参数调用回调 try { // 并以回调的结果为本次成功结果 resolve(onFulfilled(value)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; // 设置原 Promise 失败处理函数 const onPrevRejected = reason =&gt; { // 如果没有设置失败回调，则直接使用原 Promise 的失败结果 if (typeof onRejected !== 'function') { reject(reason); } else { // 如果设置了失败回调，则用失败的结果为参数调用回调 try { // 并以回调的结果为本次**成功**结果 resolve(onRejected(reason)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; if (this[state] === FULFILLED) { // 如果原 Promise 已经成功，直接调用成功处理函数 process.nextTick(() =&gt; { onPrevFulfilled(this[result]); }); } else if (this[state] === REJECTED) { // 如果原 Promise 已经失败，直接调用失败处理函数 process.nextTick(() =&gt; { onPrevRejected(this[result]); }); } else { // 如果原 Promise 仍然待定，则将处理函数加到原 Promise 的回调队列中 this[onFulfilledCallbacks].push(onPrevFulfilled); this[onRejectedCallbacks].push(onPrevRejected); } }); // 返回新创建的 Promise return newFuture; }} 这里 process.nextTick 用于模拟 then 回调的微任务执行优先级。 处理 thenable刚才的基本实现应该可以处理普通的结果了，现在我们要考虑将 Promise 或者 thenable 作为结果的情况。 thenable 其实就是定义了 then 方法的对象（或函数），对 thenable 的支持可以使得不同的 Promise 实现之间相互兼容。 只要对象可以成功提供 then 函数，我们就认为它是合法的 thenable，就可以把 then 当作 Promise 的 then 方法来使用。 根据以上描述，Promise 对象本身就是一个 thenable，那么其实我们只需要判断 thenable 即可。 支持 thenable 结果如果当前 Promise 的结果是 thenable，我们就等到它们的状态变为成功或失败，并将它们的结果设为当前 Promise 的结果。 根据 Promise/A+ 规范，executor 的 reject 回调用于设置失败原因，不需要处理 thenable 的情况。我们只需要修改成功处理函数（resolveFunction）来等待 thenable 的结果： 1234567891011121314151617181920212223242526272829// 成功处理函数const resolveFunction = value =&gt; { // 处理 thenable 的情况 // 首先判断是一个对象或函数 if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; // 取得 then 函数，并且将当前 Promise 的处理函数设置为回调 if (typeof then === 'function') { then.call(value, resolveFunction, rejectFunction); return; } } catch (err) { // 如果无法成功获得 then 函数，设置当前 Promise 为错误状态 rejectFunction(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 正确处理结果回调我们知道，resolveFunction 和 rejectFunction 只有最初调用的那个可以生效，我们一开始使用一个简单的有限状态机来控制状态转移。 但是由于加入了 thenable 的处理，状态设置的顺序和调用处理函数的顺序将可能会不同，我们将无法保证只有第一次调用能够生效。如果我们先 resolve 一个 thenable，再 resolve 一个普通结果，如上的处理方式会采用后面的普通结果；同理，如果先 resolve 一个 thenable，再抛出异常，我们会得到失败的结果。所以，我们需要另外的机制来保证只有第一次调用的处理函数才能生效。 首先，我们采用一个工具函数来包装这对处理函数，使得它们总共只能被调用一次。 12345678const once = (resolve, reject) =&gt; { let called = false; const callable = () =&gt; (called ? false : ((called = true), true)); return { resolve: value =&gt; (callable() ? resolve(value) : undefined), reject: reason =&gt; (callable() ? reject(reason) : undefined) };}; 我们修改构造器的最后一段，将处理过的函数丢给 executor： 123456const { resolve, reject } = once(resolveFunction, rejectFunction);try { executor(resolve, reject);} catch (err) { reject(err);} 这样就可以保证 executor 只能调用一次处理函数，之后再调用或者抛出异常都不再理会。 正确处理 thenable 嵌套但是 thenable 也可能会提供一个 thenable 作为结果，这时候对新的 thenable 的处理，我们是放在 resolveFunction 中的，回顾一下刚刚的代码： 12345678910111213141516171819202122232425// 成功处理函数const resolveFunction = value =&gt; { if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { then.call(value, resolveFunction, rejectFunction); return; } } catch (err) { rejectFunction(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 这里同样会产生上述回调处理顺序问题，所以我们需要保证 resolveFunction 中产生的回调，也只能执行一次。 1234567891011121314151617181920212223242526272829// 成功处理函数const resolveFunction = value =&gt; { // 使用带执行检查的函数作为回调 const callback = once(resolveFunction, rejectFunction); if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { // 修改这里的回调 then.call(value, callback.resolve, callback.reject); return; } } catch (err) { // 修改这里的错误处理函数 callback.reject(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 测试我们先安装 Promise/A+ 测试库： 1npm i -g promises-aplus-tests 然后加入以下代码，提供测试库需要的接口： 12345678910111213141516exports.resolved = value =&gt; new Future((resolve, reject) =&gt; { resolve(value); });exports.rejected = reason =&gt; new Future((resolve, reject) =&gt; { reject(reason); });exports.deferred = () =&gt; { const response = {}; response.promise = new Future((resolve, reject) =&gt; { response.resolve = resolve; response.reject = reject; }); return response;}; 接着执行测试（--bail 参数用于控制测试在第一次失败时终止）： 1promises-aplus-tests custom_promise.js --bail 我们发现，我们的实现不符合规范的第 2.3.1 条： 2.3.1: If promise and x refer to the same object, reject promise with a `TypeError’ as the reason. via return from a fulfilled promise 这一条是说，Promise 不能以他自己为结果，否则得抛出 TypeError，测试的情况为： 12345const promise = new Promise((resolve, reject) =&gt; { process.nextTick(() =&gt; { resolve(promise); });}); 这种情况下，Promise 会等待自己完成时才能完成，这是一个死锁。 我们在 resolveFunction 的开头增加一段检查，来完成这一条规范： 12345678const resolveFunction = value =&gt; { const callback = once(resolveFunction, rejectFunction); if (value === this) { callback.reject(new TypeError('Promise cannot resolve itself.')); return; } // ...}; 再次执行测试，我们会发现全部的测试都可以通过了。 最终通过测试的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* 属性常量 */const state = Symbol();const result = Symbol();const onFulfilledCallbacks = Symbol();const onRejectedCallbacks = Symbol();/* 状态常量 */const PENDING = Symbol();const REJECTED = Symbol();const FULFILLED = Symbol();/* 工具函数 */// 设置不可枚举属性const defineProperty = (obj, key, value) =&gt; Object.defineProperty(obj, key, { value, writable: true, configurable: false, enumerable: false });const once = (resolve, reject) =&gt; { let called = false; const callable = () =&gt; (called ? false : ((called = true), true)); return { resolve: value =&gt; (callable() ? resolve(value) : undefined), reject: reason =&gt; (callable() ? reject(reason) : undefined) };};class Future { constructor(executor) { // 参数检查 if (typeof executor !== 'function') { throw new Error('Future executor undefined is not a function'); } // 设置状态、结果属性 defineProperty(this, state, PENDING); defineProperty(this, result, undefined); // 设置回调队列 defineProperty(this, onFulfilledCallbacks, []); defineProperty(this, onRejectedCallbacks, []); // 成功处理函数 const resolveFunction = value =&gt; { try { // 使用带执行检查的函数作为回调 const callback = once(resolveFunction, rejectFunction); // 检查是否结果为自己本身 if (value === this) { callback.reject(new TypeError('Promise cannot resolve itself.')); return; } if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { then.call(value, callback.resolve, callback.reject); return; } } catch (err) { callback.reject(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); } } catch (err) { console.error(err.stack); } }; // 失败处理函数 const rejectFunction = reason =&gt; { try { if (this[state] === PENDING) { this[state] = REJECTED; this[result] = reason; this[onRejectedCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); } } catch (err) { console.error(err.stack); } }; const { resolve, reject } = once(resolveFunction, rejectFunction); try { executor(resolve, reject); } catch (err) { reject(err); } } then(onFulfilled, onRejected) { const newFuture = new Future((resolve, reject) =&gt; { // 设置原 Promise 成功处理函数 const onPrevFulfilled = value =&gt; { if (typeof onFulfilled !== 'function') { // 如果没有设置成功回调，则直接使用原 Promise 的成功结果 resolve(value); } else { // 如果设置了成功回调，则用成功的结果为参数调用回调 try { // 并以回调的结果为本次成功结果 resolve(onFulfilled(value)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; // 设置原 Promise 失败处理函数 const onPrevRejected = reason =&gt; { // 如果没有设置失败回调，则直接使用原 Promise 的失败结果 if (typeof onRejected !== 'function') { reject(reason); } else { // 如果设置了失败回调，则用失败的结果为参数调用回调 try { // 并以回调的结果为本次**成功**结果 resolve(onRejected(reason)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; if (this[state] === FULFILLED) { // 如果原 Promise 已经成功，直接调用成功处理函数 process.nextTick(() =&gt; { onPrevFulfilled(this[result]); }); } else if (this[state] === REJECTED) { // 如果原 Promise 已经失败，直接调用失败处理函数 process.nextTick(() =&gt; { onPrevRejected(this[result]); }); } else { // 如果原 Promise 仍然待定，则将处理函数加到原 Promise 的回调队列中 this[onFulfilledCallbacks].push(onPrevFulfilled); this[onRejectedCallbacks].push(onPrevRejected); } }); // 返回新创建的 Promise return newFuture; }} 添加常用的函数Promise.prototype.catch 和 Promise.prototype.finallycatch 方法类似于 then 方法，只是它只接受一个错误回调。我们可以通过使用 then 函数来达到它的效果。 123456class Future { // then(onFulfilled, onRejected) { ... } catch(onRejected) { return this.then(undefined, onRejected); }} finally 方法可以指定一个没有参数的回调，用于在 Promise 的状态发生变化时触发，finally 方法返回一个新的 Promise。 只有在回调抛出异常的情况下，新 Promise 会以这个异常为原因失败，否则新的 Promise 的结果将和原 Promise 一致。 同样，我们可以通过使用 then 函数来达到它的效果。 12345678910111213class Future { // then(onFulfilled, onRejected) { ... } finally(onFinally) { const callback = typeof onFinally === 'function' ? () =&gt; onFinally() : undefined; return this.then(callback, callback).then(() =&gt; { if (this[state] === REJECTED) { throw this[result]; } return this[result]; }); }} Promise.resolve 和 Promise.rejectPromise 的类方法 resolve 和 reject 用于构造一个确定结果的 Promise。 12345678class Future { static resolve(value) { return new Future((resolve, reject) =&gt; resolve(value)); } static reject(reason) { return new Future((resolve, reject) =&gt; reject(reason)); }} Promise.all 和 Promise.racePromise 的类方法 all 和 race 用于多个 Promise 的控制。 all 方法的参数为一个可迭代对象（Iterable，比如数组），返回一个 Promise。Promise 成功的结果将是一个新的数组。如果传入的数组里有 thenable，则将结果放到结果的对应位置，否则放数组元素本身。任意一个 thenable 的失败，都将导致整个结果失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Future { static all(iterable) { let pending = 0; return new Future((resolve, reject) =&gt; { const iterator = iterable &amp;&amp; iterable[Symbol.iterator]; if (!iterator || typeof iterator.next !== 'function') { throw new TypeError('argument must be iterable.'); } const values = []; for ( let item = iterator.next(), index = 0; !(item &amp;&amp; item.done); item = iterator.next(), index += 1 ) { if (item == null || typeof item !== 'object') { throw new TypeError('iterator.next() returned a non-object value'); } if ( (item.value !== null &amp;&amp; typeof item.value === 'object') || typeof item.value === 'function' ) { const then = item.value.then; if (typeof then === 'function') { pending += 1; const callback = value =&gt; { values[i] = value; pending -= 1; if (pending === 0) { resolve(values); } }; then.call(item.value, callback, reject); } else { values[i] = item.value; } } else { values[i] = item.value; } } if (pending === 0) { resolve(values); } }); }} race 方法的参数也为一个可迭代对象（Iterable，比如数组），返回一个 Promise。Promise 的结果将是数组元素中最快确定的结果（如果数组元素是 thenable，则需要等待它的结果，否则立即取出结果）。任意一个 thenable 的失败，都将导致整个结果失败。 123456789101112131415161718192021222324252627282930313233343536class Future { static race(iterable) { return new Promise((resolve, reject) =&gt; { const iterator = iterable &amp;&amp; iterable[Symbol.iterator]; if (!iterator || typeof iterator.next !== 'function') { throw new TypeError('argument must be iterable.'); } for ( let item = iterator.next(), index = 0; !(item &amp;&amp; item.done); item = iterator.next(), index += 1 ) { if (item == null || typeof item !== 'object') { throw new TypeError('iterator.next() returned a non-object value'); } if ( (item.value !== null &amp;&amp; typeof item.value === 'object') || typeof item.value === 'function' ) { const then = item.value.then; if (typeof then === 'function') { then.call(item.value, resolve, reject); } else { process.nextTick(() =&gt; { resolve(item.value); }); } } else { process.nextTick(() =&gt; { resolve(item.value); }); } } }); }} Promise.promisifypromisify 函数用于将标准回调风格异步函数转换成 Promise 风格异步函数，将会在函数列表末尾增加一个错误优先风格的回调（(err, value) =&gt; { ... }）来用于转换。 1234567891011121314class Future { static futurify(asyncFunctionWithCallback) { return (...args) =&gt; new Future((resolve, reject) =&gt; { asyncFunctionWithCallback(...args, (err, value) =&gt; { if (err) { reject(err); } else { resolve(value); } }); }); }} 总结到此，一个满足 Promise/A+ 规范的自定义 Promise 类就完成了，也顺便添加了一些常用的规范外的方法。","link":"/2019/05/30/node-custom-promise/"},{"title":"用矩阵求第 N 个斐波那契数","text":"编程求解第 N 个斐波那契数是一个经典问题，除了常规解法，本文将介绍几个较为特别的解法。 斐波那契数列的定义如下： $$\\begin{align}Fib_0 &amp;= 0 \\\\Fib_1 &amp;= 1 \\\\\\vdots \\\\Fib_n &amp;= Fib_{n-1} + Fib_{n-2} \\quad (n \\in \\mathbb Z^+, n \\geq 2) \\\\\\end{align}$$ 常规解法递归法最直观的方法是直接将斐波那契数列的定义写成对应的递归函数： 123456789function fib(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } return fib(n - 1) + fib(n - 2);} 根据 $ Fib_n = Fib_{n-1} + Fib_{n-2} $ 进行递归，最左侧的递归数高度为 $ n $，最右侧的递归数高度为 $ \\frac{n}{2} $，那么我们可以得出递归数的节点数量约为 $ \\frac{2^n}{2} = 2^{n-1} $，而递归树的高度为 $ n $。 所以递归法的时间复杂度为 $ O(2^n) $，空间复杂度为 $ O(n) $。 直接递归需要进行大量的重复计算，我们可以加入函数缓存来降低计算次数。 带函数缓存的递归解法如下： 12345678910111213function fib(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } if (!fib.cache[n]) { fib.cache[n] = fib(n - 1) + fib(n - 2); } return fib.cache[n];}fib.cache = []; 加入函数缓存后，对每一个重复位置的计算将只进行一次，因此时间复杂度降为 $ O(n) $，但是将多出 $ n $ 个数字的空间用于缓存结果，空间复杂度为 $ O(n) + O(n) = O(n) $。 迭代法 / 动态规划不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。 当然，因为斐波那契数列的公式比较简单，我们也可以简单地将递归的步骤直接转化为循环迭代，其逻辑与动态规划的方法一致。 动态规划的解法如下： 1234567function fib(n) { const dp = [0, 1]; for (let i = 2; i &lt;= n; i += 1) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n];} 该解法的时间复杂度与空间复杂度均为 $ O(n) $。 我们发现，每个状态的只与前两个状态相关，我们可以将储存状态的变量减少到 2 个来优化空间使用。 优化空间的动态规划解法如下： 123456789101112function fib(n) { if (n === 0) { return 0; } let prev = 0; // 保存前一个值 let curr = 1; // 保存当前值，初始化为 fib(1) // 迭代 n-1 次 while (--n &gt; 0) { [prev, curr] = [curr, prev + curr]; } return curr;} 优化后，动态规划解法的时间复杂度为 $ O(n) $，空间复杂度为 $ O(1) $。 非常规解法除了以上较为简单就可以想到的解法，如下方法虽然较难想到，但也是计算更加高效的算法。 斐波那契公式先由数学的方法求出斐波那契数列的通项。 我们设 $ Fib_n = a^n $，那么根据递推公式，我们可以得到 $ a^n = a^{n-1} + a^{n-2} $，约分一下可以得到 $ a^2 = a + 1 $ 即二次方程 $ a^2 - a - 1 = 0 $ 对二次方程求解可以得到： $$a = \\frac{1 \\pm \\sqrt 5}{2 \\sqrt 5}$$ 那么我们再设 $ Fib_n = A \\left( \\frac{1 + \\sqrt 5}{2 \\sqrt 5} * C \\right)^n + B \\left( \\frac{1 - \\sqrt 5}{2 \\sqrt 5} * C \\right)^n $ 代入数列前三项可以得到： $$\\begin{align}Fib_0 &amp;= A + B = 0 \\\\Fib_1 &amp;= \\frac{1 + \\sqrt 5}{2 \\sqrt 5} AC + \\frac{1 - \\sqrt 5}{2 \\sqrt 5} BC = 1 \\\\Fib_2 &amp;= \\frac{3 + \\sqrt 5}{10} AC^2 + \\frac{3 - \\sqrt 5}{10} BC^2 = 1 \\\\\\end{align}$$ 求解以上关于 $ A, B, C $ 的方程组可以得到： $$\\begin{align}A &amp;= \\frac{1}{\\sqrt 5} \\\\B &amp;= - \\frac{1}{\\sqrt 5} \\\\C &amp;= \\sqrt 5 \\\\\\end{align}$$ 代入 $ Fib_n = A \\left( \\frac{1 + \\sqrt 5}{2 \\sqrt 5} * C \\right)^n + B \\left( \\frac{1 - \\sqrt 5}{2 \\sqrt 5} * C \\right)^n $ 就可以得到斐波那契公式。 斐波那契公式： $$F_n = \\frac{1}{\\sqrt 5} * \\left[ \\left(\\frac{1 + \\sqrt 5}{2}\\right)^n - \\left(\\frac{1 - \\sqrt 5}{2}\\right)^n \\right]$$ 那么根据斐波那契公式，我们就可以编码求解了： 123456function fib(n) { const sqrt5 = Math.sqrt(5); const value = (Math.pow((1 + sqrt5) / 2, n) - Math.pow((1 - sqrt5) / 2, n)) / sqrt5; return Math.round(value);} 该方法的需要进行 1 次平方根与 2 次求幂操作，用二分法求平方根的复杂度为 $ O(log_2{n}) $，用快速幂方法求幂的复杂度为 $ O(log_2{n}) $，所以总体时间复杂度为 $ O(log_2{n}) $。同理，空间复杂度为 $ O(1) $。 但是由于涉及到浮点数计算，该方法可能会得到近似值而不是准确值。 Q-Matrix 方法Q-Matrix 方法是一种利用矩阵相乘特性来巧妙求解斐波那契数列的方式。公式如下： $$\\begin{bmatrix}F_{n+1} &amp; F_n \\\\F_n &amp; F_{n-1} \\\\\\end{bmatrix}= \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix}^n\\quad (n \\in \\mathbb Z^+)$$ 我们令 $ Q = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} $，则： $$Q^n = \\begin{bmatrix}F_{n+1} &amp; F_n \\\\F_n &amp; F_{n-1} \\\\\\end{bmatrix}\\quad (n \\in \\mathbb Z^+)$$ 我们可以用数学归纳法来证明上述公式成立，首先检验第一项满足条件： $$Q^1 = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} Fib_2 &amp; Fib_1 \\\\ Fib_1 &amp; Fib_0 \\\\ \\end{bmatrix}$$ 假设第 n-1 项满足条件，证明第 n 项也满足： $$\\begin{align}Q^n &amp;= Q^{n-1} Q \\\\ &amp;= \\begin{bmatrix}F_n &amp; F_{n-1} \\\\F_{n-1} &amp; F_{n-2} \\\\\\end{bmatrix} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} \\\\ &amp;= \\begin{bmatrix}F_n + F_{n-1} &amp; F_{n-1} + F_{n-2} \\\\F_{n-1} + F{n-2} &amp; F_{n-1} \\\\\\end{bmatrix} \\\\ &amp;= \\begin{bmatrix}F_{n+1} &amp; F_n \\\\F_n &amp; F_{n-1} \\\\\\end{bmatrix}\\end{align}$$ 由上述步骤即可证明对于 $ n \\in \\mathbb Z^+ $ 结论成立，反过来可得对于 $ n \\in \\mathbb Z^+, n \\geq 2 $，$ Fib_n = Q^{n-1}[0,0] $。 那么转换成代码即： 1234567891011function fib(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } const Q = [[1, 1], [1, 0]]; const powQ = pow2x2(Q, n - 1); return powQ[0][0];} 其中 pow2x2(mat, exp) 用于求 2x2 矩阵的正整数次幂。我们可以将快速幂方法延伸到矩阵求幂： 1234567891011121314151617181920function pow2x2(mat, exp) { let ret = [[1, 0], [0, 1]]; let tmp = mat; while (exp &gt; 0) { if ((exp &amp; 1) === 1) { ret = mul2x2(ret, tmp); } tmp = mul2x2(tmp, tmp); exp &gt;&gt;= 1; } return ret;}function mul2x2(A, B) { const C = [[0, 0], [0, 0]]; C[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0]; C[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1]; C[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0]; C[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1]; return C;} 这样 pow2x2(mat, exp) 的时间复杂度为 $ O(log_2{n}) $，空间复杂度为 $ O(1) $。 用 Q-Matrix 方法求斐波那契数只涉及一次矩阵求幂，那么它的的时间复杂度也为 $ O(log_2{n}) $，空间复杂度也为 $ O(1) $。 总结以上所述计算斐波那契数的方法复杂度比较： 方法 时间复杂度 空间复杂度 递归 $ O(2^n) $ or $ O(n)^{[1]} $ $ O(n) $ 动态规划 $ O(n) $ $ O(n) $ or $ O(1)^{[2]} $ 斐波那契公式 $ O(log_2{n}) $ $ O(1) $ Q-Matrix $ O(log_2{n}) $ $ O(1) $ 注 [1]：使用函数缓存优化递归执行时间 注 [2]：优化状态存储来减少空间占用 附录用二分法求平方根上一篇文章中有提及到用二分法求平方根，这里直接贴出代码： 1234567891011121314151617181920212223242526272829/** * @param {number} n 待求平方根的数 * @param {number} e 相对误差要求 * @param {number} limit 迭代次数限制 * @return {number} */function getSquareRootOf(n, e = 0.00000001, limit = 100000) { if (n &lt; 0) { return NaN; } if (n === 0 || n === 1) { return n; } let min = n &gt; 1 ? 1 : n; let max = n &gt; 1 ? n : 1; for (let times = 0; times &lt; limit; times += 1) { const middle = min + (max - min) / 2; const square = middle * middle; const diff = Math.abs(square / n - 1); // 相对精度 if (diff &lt; e) { return middle; } else if (square &gt; n) { max = middle; } else { min = middle; } } return min + (max - min) / 2;} 分析可知其时间复杂度为 $ O(log_2{n}) $，空间复杂度为 $ O(1) $。 用快速幂方法求幂根据正整数的二进制数表示法，我们可以得到下列规律： $$13 = 1101_2 = 2^3 + 2^2 + 2^0$$ 那么对于乘方我们可以得到如下规律： $$a^{13} = a^{1101_2} = a^{(2^3 + 2^2 + 2^0)} = a^{2^3} * a^{2^2} * a^{2^0}$$ 利用这个规律，我们可以用 $ O(log_2{n}) $ 次相乘就可以得到 $ a^n \\ (n \\in \\mathbb Z^+) $。 123456789101112function pow(num, exp) { let ret = 1; let tmp = num; // num ^ 1 while (exp &gt; 0) { if ((exp &amp; 1) === 1) { ret *= tmp; // ret *= num ^ (2 ^ (i - 1)) } tmp *= tmp; // num ^ (2 ^ i), i 为循环次数 exp &gt;&gt;= 1; } return ret;} 分析可知其时间复杂度为 $ O(log_2{n}) $，空间复杂度为 $ O(1) $。","link":"/2019/06/11/binets-fibonacci/"},{"title":"Rust学习笔记2 - 所有权","text":"本文是 Rust 学习笔记系列第二篇，参考 Rust 指南的第 4 章，涉及所有权、借用、切片。 所有权（Ownership）是 Rust 中最为独特的一个特性，它允许 Rust 在不需要垃圾回收机制的情况下保证内存安全。所有权机制是掌握 Rust 的关键。 所有权所有权是 Rust 的核心机制。所有权本身简单的，很容易解释的，但是对 Rust 其他的地方影响深远。 所有的程序都需要在运行时管理内存。有些语言提供了垃圾回收机制来不断查找不会被使用的内存；有些语言开发者必须自己处理内存的申请和释放。Rust 与以上两种都不同，通过编译器在编译期检查一系列所有权相关的规则来管理内存，而这些规则在运行时并不会带来额外的开销。 栈与堆在很多语言中，开发者不需要经常考虑栈和堆的问题。但是在系统编程语言中，值存储在栈中与堆中则会影响语言如何操作该值。 栈（Stack）和堆（Heap）都是的运行时可用内存的一部分，但是他们的结构是不同的。栈储存的值会以与创建相反的顺序销毁，即「后进先出」规则。所有在栈中存储的值都必须有已知且固定的尺寸。尺寸未知或者会被改变的值应该存储在堆中。相比于栈，堆比较宽松，向堆中存值的时候，首先申请固定尺寸的空间，内存分配器会在堆寻找一块相同尺寸的未被使用连续空间，标记为被使用，然后返回一个指向这段空间开始位置的指针。这个过程被称为「堆分配」，通常简称为「分配」。指针是一个已知固定尺寸的值，所有可以在栈中保存指针，但是访问实际数据的时候必须通过该指针读取实际内存。 要比喻的话，堆就像餐厅里的桌位分配。 栈中的值的访问要比堆快，因为既不需要在存值时寻找空闲位置，也不需要在读取时通过指针寻址。 当调用函数时，参数会传入函数，而函数中的局部变量则会分配在栈中，当函数执行结束时，这些局部变量会被释放。 而在堆中跟踪使用空间，最小化重复数据，清除无用数据则是所有权机制要处理的问题。一旦理解了所有权机制，就不需要再经常考虑堆和栈的问题了。 所有权规则Rust 的所有权规则有 3 条： 每个值都被一个变量所拥有，这个变量被称为「所有者」 一个值同时只能有一个所有者 一旦所有者脱离了作用域，值就会被释放 变量作用域变量的作用域是指在程序中可以访问该变量的范围。变量从其声明时有效，到其作用域结束时失效。 与其他语言中的作用域规则类似（比如 EcmaScript 6 的块级作用域）。 String 类型为了解释所有权规则，需要比标量类型、复合类型（这两种都是存储在栈中的）更加复杂的类型作为例子。 我们用 String 类型作为例子。我们已经知道字符串字面量（&quot;abc&quot;），但是字面量是不可变的。当我们需要处理可变的文本或者编译期不可知的文本时，我们就需要另一种类型 String，这种类型的数据会被分配在堆中，且允许存储编译期不可知的文本。可以通过字符串字面量来初始化 String 类型的值： 1let s = String::from(\"hello\"); :: 操作符允许我们将 from 函数放入 String 类型的命名空间，避免使用 string_from 之类的名字，也容易避免命名冲突。 String 类型的值可以是可变的： 12345let mut s = String::from(\"hello\");s.push_str(\", world!\");println!(\"{}\", s); 内存与分配字符串字面量是编译期已知的值，文本是直接硬编码进可执行程序的。所以使用字面量会快而有效率。但是这都是源于字面量的不可变性。 在 String 类型中，为了处理可变的文本，需要在堆中分配内存。这就表示： 内存必须在运行时申请 需要在用完之后释放这些内存 第一条，内存申请，已经通过 String::from 完成了，它的内部实现会申请需要的内存。这和其他的变成语言类似。 但是第二天就不一样了。在提供了 GC（垃圾回收器）的语言中，GC 会跟踪并在内存不再使用的时候，释放这段内存。但是如果没有 GC，我们就需要自己辨别内存在什么时候不会再被使用，并且用代码去释放内存。如何正确的做到这一点是一个历史难题。如果忘记释放，则会浪费内存。如果过早释放，则会导致值不可用。如果释放两次同样会导致 BUG。 Rust 采用第三种途径：当所有者脱离作用域（变量不再会被使用时）就释放掉对应的内存。 123{ let s = String::from(\"hello\"); // s定义好后就可用了} // 作用域结束，s不可用，String值所使用的内存被释放 当 s 脱离作用域是，Rust 会调用 drop， String 类型可以通过 drop 函数来定义如何释放内存。Rust 在块结束时会自动调用 drop。 这种模式极大的影响了 Rust 的代码书写。刚刚的例子看起来还很简单，但是更复杂的情况、要处理多个堆变量的时候，可能会产生非预期的结果。 变量与数据交互：移动多个变量处理同一个数据有多种不同的情况。 比如： 12let x = 5; // 把值5绑定给变量xlet y = x; // 复制x的值给y 由于 5 是标量类型，在栈中存储，值赋值给新的变量是直接复制的。 再看 String 的情况： 12let s1 = String::from(\"hello\");let s2 = s1; String 的文本数据储存在堆中，栈中会储存堆内存的指针、申请空间的尺寸、已使用空间的尺寸。将 s1 赋值给 s2 时，栈内存会被复制，而堆内存并不会被复制，也就是说 s1 与 s2 同时拥有同一片内存的指针。 之前讲过，Rust 对脱离作用域的变量自动调用 drop 函数，那这种情况下 s1 与 s2 共同指向的那块堆内存就会被释放两次。这被称为「双重释放」错误，是之前提到的一种一种内存安全缺陷。 为了保证内存安全，Rust 实际上还多做了一些事情，将 s1 赋值给 s2 时，会标记 s1 失效。这样，在 s1 脱离作用域时，Rust 就不会对它调用 drop 函数了。 12let s1 = String::from(\"hello\"); // s1 有效let s2 = s1; // s1 失效，s2 有效 其他语言里有深拷贝和浅拷贝的概念，Rust 中的做法看起来比较像浅拷贝，但是 Rust 同时会让前一个变量失效，这种行为可以叫做「移动」。 此外，Rust 不会自动进行「深拷贝」。所以任何自动进行的拷贝可以认为是开销较小的。 变量与数据交互：克隆如果我们确实需要进行深拷贝 String 的数据，我们可以调用它的 clone 方法。 12let s1 = String::from(\"hello\");let s2 = s1.clone(); 这种方式会进行堆内存的复制。 任何使用 clone 的场景可以认为是有一定开销的。 栈数据：拷贝还有一种情况是前面提到的例子： 12let x = 5; // 把值5绑定给变量xlet y = x; // 复制x的值给y 这种情况下不需要调用 clone，x 也仍然有效，并不是「移动」到了 y。 原因是整数是一种固定已知尺寸的类型，且完全存储在栈中，所以拷贝实际上可以非常快地完成。而且因为不会产生「双重释放」问题，也没有理由将 x 禁用掉。换言之这种情况不存在深拷贝/浅拷贝的区别。 Rust 有一种特殊的标记：Copy 特性（trait），用于描述类似整数这样的仅存储在栈的类型。如果一种类型有 Copy 特性，那赋值后，旧的变量依旧有效。Rust 不允许开发者让任何实现了 Drop 特性（或者其一部分实现了 Drop 特性）的类型被标记为 Copy 特性。如果任何类型在变量脱离作用域时需要执行额外代码且标记了 Copy 特性，就会产生编译错误。 任何标量类型和标量类型的复合类型都有 Copy 特性，任何不需要分配堆内存的类型都有 Copy 特性。比如： 所有整数类型、浮点数类型 布尔类型、字符类型 所有元素都具有 Copy 特性的元组 所有权与函数参数的传递和赋值一样，会导致移动或者拷贝。 123456789101112131415fn main() { let s = String::from(\"hello\"); // s进入了作用域 takes_ownership(s); // s移动进了函数，并在当前作用域失效 let x = 5; // x进入了作用域 makes_copy(x); // x需要进入函数，但是x是可复制的，所有x仍然有效} // x，s依次离开作用域，不需要dropfn takes_ownership(some_string: String) { // some_string进入作用域 println!(\"{}\", some_string);} // some_string离开作用域，`drop` 会被调用fn makes_copy(some_integer: i32) { // some_integer进入作用域 println!(\"{}\", some_integer);} // some_integer离开作用域，不需要drop 返回值与作用域函数返回值也会造成所有权转移 1234567891011121314151617fn main() { let s1 = gives_ownership(); // gives_ownership的返回值移动到了s1 let s2 = String::from(\"hello\"); // s2进入作用域 let s3 = takes_and_gives_back(s2); // s2移入了takes_and_gives_back，在当前作用域失效 // 且takes_and_gives_back的返回值移动到了s3} // s3, s2, s1 依次脱离作用域，s1和s3会被drop，s2不会被dropfn gives_ownership() -&gt; String { let some_string = String::from(\"hello\"); // some_string进入作用域 some_string // some_string作为返回值移出了函数，在当前作用域失效} // some_string脱离作用域，不会被dropfn takes_and_gives_back(a_string: String) -&gt; String { // a_string进入作用域 a_string // a_string作为返回值移出了函数，在当前作用域失效} // a_string脱离作用域，不会被drop 根据这些规则，我们来试一试获取字符串的长度并打印出来： 12345678910fn main() { let s1 = String::from(\"hello\"); let (s2, len) = calculate_length(s1); println!(\"The length of '{}' is {}.\", s2, len);}fn calculate_length(s: String) -&gt; (String, usize) { let length = s.len(); // len() returns the length of a String (s, length)} 可以看到，如果需要把字符串传到函数里，那么所有权会转移进去，然后我们用元组把字符和长度都传出来，才能够同时打印字符串和长度。 然而这样写是很繁琐的，所有传到函数里的内容如果还需要再用还得传出来。 我们可以用引用来解决这个问题。 引用与借用我们先看一下 Rust 里面如何用引用解决上面的问题： 123456789fn main() { let s1 = String::from(\"hello\"); let len = calculate_length(&amp;s1); // 向函数提供String的引用而不是它本身 println!(\"The length of '{}' is {}.\", s1, len);}fn calculate_length(s: &amp;String) -&gt; usize { // 接受String的引用 s.len()} Rust 中，&amp; 符号代表引用（References），可以在不影响所有权的情况下引用值。 引用的反操作是解引用（Dereferencing）用符号 * 表示。之后会介绍如何使用解引用。 我们再看一下上面的例子，所有权和内存的变化： 123456789fn main() { let s1 = String::from(\"hello\"); // s1进入作用域 let len = calculate_length(&amp;s1); // s1向calculate_length提供引用，所有权不变 println!(\"The length of '{}' is {}.\", s1, len);} // s1离开作用域，被dropfn calculate_length(s: &amp;String) -&gt; usize { // 拿到s的引用 s.len()} // s离开作用域，因为是引用，没有所有权，所以不进行drop 使用引用作为函数参数的行为就称为是「借用」（Borrowing）。 和变量一样，引用默认是不可变的。 如果我们尝试修改引用的内容，会得到如下错误： 12345678fn main() { let s = String::from(\"hello\"); change(&amp;s);}fn change(some_string: &amp;String) { some_string.push_str(\", world\");} 1error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference 可变引用我们可以用可变引用（&amp;mut）来达到修改引用的内容的目的。 12345678fn main() { let s = String::from(\"hello\"); change(&amp;mut s);}fn change(some_string: &amp;mut String) { some_string.push_str(\", world\");} 可变引用有一个很重要的限制：对同一个数据，在同一个作用域内同时只能有一个可变引用。 这个限制让可变性在一个非常受控的范围内。Rust 的新手可能会很不习惯，因为其他语言通常允许随时修改。 这个限制的好处就是我们可以在编译期间规避掉「数据竞争」的问题。数据竞争的出现条件如下： 有多个指针指向同一片数据 至少有一个指针用于写数据 没有同步访问数据的机制 数据竞争可能导致非预期的行为，并且由于其不确定性，很难去定位和修复问题。Rust 可以在编译期发现数据竞争并产生编译错误。 可以通过创建块来使用多个可变引用： 1234567let mut s = String::from(\"hello\");{ let r1 = &amp;mut s;} // r1在这里就走出作用域了，所以接下来可以创建另一个可变引用let r2 = &amp;mut s; 可变引用还有另一个限制：不能同时拥有可变引用和不可变引用。 因为当使用不可变引用时，我们不希望数据在使用过程中产生变化。因为不可变引用不会修改值，所以多个不可变引用是可以同时存在的。 悬挂引用在有指针的语言里，很容易错误地得到「悬挂引用」，即指针指向一片已经释放掉的内存。而 Rust 的编译期会保证不存在悬挂引用，它会保证数据本身的释放不会发生在引用释放之前。 引用的规则总结一下上述提及的引用的规则： 在任何时间点，只能拥有一个可变引用或者多个不可变引用 引用必须一直可用（不能出现数据先释放的情况） 切片另一个没有所有权的类型是「切片」（Slice）。切片允许引用连续的集合元素而不是整个集合。 考虑这样一个问题：写一个函数从字符串中找到第一个单词，如果找不到空格，就返回整个字符串。 1234567891011121314// 使用借用，因为我们不需要获取所有权// 由于还不知道如何表达字符串的一部分，所以先返回单词结束的位置fn first_word(s: &amp;String) -&gt; usize { let bytes = s.as_bytes(); // as_bytes可以将字符串转换为字节数组 // iter用于返回集合中的每个元素 // enumerate用于包装iter的结果，将每个元素转换为元组（下标 + 元素的引用） for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return i; } } s.len()} 上述函数存在一些问题： 123456789fn main() { let mut s = String::from(\"hello world\"); let word = first_word(&amp;s); // = 5 s.clear(); // 清空了字符串的内容，变成了 \"\" // 此处，单词结束的下标仍然是5，然而字符串的内容已经清空了} 管理这个下标和字符串数据的同步关系是很头疼的一件事。 我们可以用 Rust 的字符串切片来解决这个事情： 字符串切片字符串切片是对字符串的一部分的引用，看起来像这样： 123let s = String::from(\"hello world\");let hello = &amp;s[0..5];let world = &amp;s[6..11]; 切片的语法与引用类似，多出了中括号的部分（[0..5]）。切片使用中括号表示的范围来指定范围，第一个数字代表开始的位置，第二个数字为切片结束的位置+1。 切片的数据结构中会存储切片的开始位置以及切片的长度。 使用 Rust 的范围语法（..），从第一个元素开始可以省略第一个数字 0；以最后一个元素结束可以省略第二个数字： 123456789101112let s = String::from(\"hello\");// 下面每一组的表达式都是等价的let slice = &amp;s[0..2];let slice = &amp;s[..2];let slice = &amp;s[3..s.len()];let slice = &amp;s[3..];let slice = &amp;s[0..s.len()];let slice = &amp;s[..]; 注意：字符串切片必须在 UTF-8 有效边界处切断，如果在多字节字符中间切断会产生运行时错误。 了解了以上关于字符串切片的内容后，我们重写一下刚刚的函数： 12345678910fn first_word(s: &amp;String) -&gt; &amp;str { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return &amp;s[..i]; } } &amp;s[..]} 现在我们使用 first_word 的时候，我们会得到对 s 的部分内容的切片。 有了这个更直接的 API，并且编译期还会为我们保证其安全性（因为切片也是引用的一种，要遵循上面的引用的规则），如果我们在持有切片的情况下尝试修改数据，会产生编译错误。 字符串常量是切片回顾一下字符串常量。我们会发现它是字符串切片，引用了二进制程序数据的一部分。 字符串切片用于参数如果我们把 first_word 的参数类型改为字符串切片 &amp;str，我们就可以用于更广泛的场景了： 1234first_word(\"hello word\");let s = String::from(\"hello world\");first_word(&amp;s[..]); 其他类型的切片字符串切片只针对字符串。还有更加通用的切片类型： 12let a = [1, 2, 3, 4, 5];let s = &amp;a[1..3]; // &amp;[i32] 其他类型的切片可以表示为 &amp;[item_type]。原理和字符串切片是一样的。可以在其他所有的集合中使用这些切片。以后介绍向量（vectors）时会详细介绍这些集合。 总结所有权、借用、切片的概念用于在编译期保证内存安全。Rust 与其他系统编程语言一样允许控制内存，但是在所有者脱离作用域时自动清理数据的特性让我们不用再担心内存的释放问题。 所有权对 Rust 的其他部分影响深远，我们在介绍其他部分的时候再详细说明。","link":"/2020/10/27/learning-rust-2/"},{"title":"Rust学习笔记1 - 基础","text":"本文是 Rust 学习笔记系列第一篇，参考 Rust 指南的第 2 到 3 章，涉及变量、数据类型、函数、注释、控制流。 变量Rust 中用 let 关键字定义变量，变量默认都是不可变的，用 let mut 定义可变的变量。（可变变量必须显式使用 mut 声明，这是 Rust 从安全方面的考虑） 不可变的变量一旦初始化就不能再被改变。 12345let foo = 5; // 不可变let mut bar = 5; // 可变let x;x = 5; 常量和不可变变量类似，常量也是将一个不可变的值绑定到标识符。 常量用 const 关键字定义，无法用 mut 将常量定义为可变，且常量的类型必须显式指定。 1const MAX_POINTS: u32 = 100_000; Rust 的命名习惯是将常量定义为大写字母加下划线的风格 常量在程序执行过程中一直存在，在其定义的作用域中有效。 变量覆盖（Shadowing）Rust 可以在同一个作用于中定义相同名称的变量，然后先定义的变量将无法在被访问到。 123let x = 5;let x = x + 1;let x = x * 2; 变量覆盖与可变变量不同，当无意中在未使用 let 关键字的情况下为变量赋值时将产生编译错误。并且使用变量覆盖时可以换一个新的类型。 数据类型Rust 中所有的值都有类型，类型分为标量类型和复合类型。 Rust 是一种静态类型语言，也就是说 Rust 必须在编译期知道所有变量的类型。通常编译器可以从值或者其用法推断出类型，但是当有多种可能的类型时，就需要显式声明变量的类型了。 1let guess: u32 = \"42\".parse().expect(\"Not a number!\"); 标量类型（Scalar Type）标量类型代表一个单独的值。Rust 有 4 种基础标量类型：整数、浮点数、布尔值、字符。 整数整数类型可以用于表示不含小数部分的数字。根据是否有符号以及存储空间大小区别，分为以下 12 种变种： 长度 有符号 无符号 8 位 i8 u8 16 位 i16 u16 32 位 i32 u32 64 位 i64 u64 128 位 i128 u128 与当前运行环境的架构一致(32 位或 64 位) isize usize 所有的变种都具备有符号或无符号的约束，且有一个固定的存储空间大小。有符号的整数使用二进制补码的方式存储，有效值范围为 $-(2^{n-1})$ 到 $2^{n-1}-1$（$n$ 为存储空间位数）；无符号的整数有效值范围为 $0$ 到 $2^n-1$（$n$ 为存储空间位数）。 以下字面量可以用于表示整数： 字面量类型 例子 十进制 1024 十六进制 0x400 八进制 0o2000 二进制 0b10000000000 字节（仅用于 u8 类型） b'A' 除了字节字面量，其他的字面量都可以用整数变种名作为后缀，并且可以用_作为数字的分隔符，例如：1024u16，1_024。 如果不确定要用哪一种整数变种，可以让 Rust 使用默认的i32，即使是在 64 位系统中，也通常是运算最快的。isize 和 usize 的主要使用场景是作为某种集合的索引类型。 如果尝试给整数赋值超出有效范围的值，会导致整数溢出。Rust 在 debug 模式下溢出会崩溃，release 模式下溢出则不会产生崩溃，但是可能会与预期值不一致。 浮点数Rust 的浮点数分为两种：f32 和 f64。和整数一样，这两种类型仅在存储空间大小上有区别。默认的浮点数类型为 f64，因为在现代 CPU 中，32 位浮点数与 64 位浮点数运算速度相差无几，而 64 位可以提供更高的精度。 12let x = 2.0; // f64let y: f32 = 3.0; // f32 浮点数使用 IEEE-754 标准来表示，f32 为单精度浮点数，f64 为双精度浮点数。 数学运算Rust 为所有的数字类型提供数学基本运算：加减乘除与取余。 12345let sum = 5 + 10;let difference = 95.5 - 4.3;let product = 4 * 30;let quotient = 56.7 / 32.2;let remainder = 43 % 5; 布尔类型与大部分其他语言一样，Rust 的布尔值类型有两个可能值：true 和 false。布尔值使用 1 个字节的存储空间。 12let t = true;let f: bool = false; 布尔值主要用于条件判断，比如 if 表达式。 字符类型Rust 中的 char 类型是最基本的文本类型，字符字面量使用单引号（字符串则是双引号）： 123let c = 'z';let z = 'ℤ';let heart_eyed_cat = '😻'; Rust 的 char 类型使用 4 个字节存储，表示一个 Unicode 标量（UTF-32）。在 Rust 中字母变种、中文、日文、韩文、Emoji，零宽度空格都是一个有效的 char 值。Unicode 标量的有效范围为 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF。然而 Unicode 中并没有字符的概念，所以一般所说的字符可能和 char 会有出入。 复合类型（Compound Type）复合类型用于将多个值组合成一个类型。Rust 有两个基本复合类型：元组（tuple）与数组（array） 元组元组用于将多个值组合成一个类型，这些值可以是不同的类型。Rust 是一种静态类型语言，每个元组类型拥有固定个数的值，并且对应位置的值的类型也是确定的。 12345let tup: (i32, f64, u8) = (500, 6.4, 1);let tup = (500, 6.4, 1);let (x, y, z) = tup; // 通过解构取出元组中的值let x2 = tup.0; // 直接按位置取出元组中的值 数组与元组不同，数组的所有元素必须是同一种类型。与其他的一些语言不同，Rust 中的数组是固定长度的。 12345678let arr = [1, 2, 3, 4, 5];let arr: [i32; 5] = [1, 2, 3, 4, 5]; // 数组的类型语法：[type; length]// 另一种数组字面量，用于创建包含重复元素的数组let arr: [i32; 5] = [1; 5]; // 等同于 [1, 1, 1, 1, 1]let first = arr[0]; // 使用下标访问数组元素let second = arr[1]; 数组下标越界会产生编译错误。 函数Rust 中用 fn 关键字定义函数。最重要的函数是 main 函数，是整个程序的入口。 Rust 中函数和变量使用小写下划线的命名风格。 12345678fn main() { println!(\"Hello, world!\"); another_function();}fn another_function() { println!(\"Another function.\");} Rust 中的函数调用不关心函数定义的顺序。 函数的参数函数的参数必须显式指定类型。 12345678fn main() { another_function(5, 6);}fn another_function(x: i32, y: i32) { println!(\"The value of x is: {}\", x); println!(\"The value of y is: {}\", y);} 函数体，语句与表达式函数体由一系列的语句构成，可以由一个表达式结尾。Rust 是一种基于表达式的语言，能区分语句与表达式的区别尤为重要。 语句指的是执行某些动作的操作，并不返回值；而表达式会有一个值作为结果。 参数定义和函数体都是语句的一种。 123fn main() { // fn statement let y = 6; // let statement} 与其他语言不同，Rust 中赋值语句不产生结果，因此诸如 x = y = 5 的写法在 Rust 中行不通。 表达式可以是语句的一部分。 函数调用、宏调用、块都是表达式的一种。 12345678910fn main() { let x = 5; let y = { // block expression let x = 3; x + 1 // 结尾表达式，如果加`;`会变成语句 }; println!(\"The value of y is: {}\", y);} 块可以创建新的作用域，块表达式的值是其结尾表达式的值。 函数的返回值函数可以给调用自己的地方返回一个值，返回值没有名称，但是需要定义类型。在 Rust 中，函数的返回值是作为函数体的块的值（即结尾表达式的值），但是可以用 return 关键字提前返回结果。 12345678fn five() -&gt; i32 { 5}fn main() { let x = five(); println!(\"The value of x is: {}\", x);} 注释和其他一些语言一样，Rust 使用 // some words、/* some words */ 表示注释，还有一种文档注释，之后再说。 控制流if 表达式12345678910111213141516171819202122232425fn main() { let number = 3; if number &lt; 5 { println!(\"condition was true\"); } if number &lt; 5 { println!(\"condition was true\"); } else { println!(\"condition was false\"); } if number % 4 == 0 { println!(\"number is divisible by 4\"); } else if number % 3 == 0 { println!(\"number is divisible by 3\"); } else if number % 2 == 0 { println!(\"number is divisible by 2\"); } else { println!(\"number is not divisible by 4, 3, or 2\"); } let number_at_least_5 = if number &gt; 5 { 5 } else { number }} if 表达式的值为执行的那个块的值，if 语句的所有块的值类型必须一致。 循环Rust 有三种循环：loop、while、for。 loop 循环loop 关键字会循环执行一个块，直到使用 break 关键字中止循环。 12345fn main() { loop { println!(\"again!\"); }} loop 的返回值使用 break 关键字中止循环，break 后面接的值就是 loop 的值。 12345678910111213fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\"The result is {}\", result);} while 循环while 关键字会重复检查条件，当条件满足时，执行作为循环体的块，否则中止循环。 12345678910fn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index &lt; 5 { println!(\"the value is: {}\", a[index]); index += 1; }} while 循环没有返回值。 for 循环for 关键字会遍历一个集合 123456789101112fn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter() { println!(\"the value is: {}\", element); } for number in (1..4).rev() { println!(\"{}!\", number); } println!(\"LIFTOFF!!!\");} for 循环没有返回值。","link":"/2020/10/09/learning-rust-1/"},{"title":"JavaScript 中的继承与原型链","text":"对于使用过基于类的面向对象语言（如 Java 或 C++）的开发者而言，JavaScript 中的继承可能有些奇怪，因为它是动态的，并且没有类的概念。 尽管 JavaScript 基于原型的继承模型通常被认为是 JavaScript 弱点，但其实这比经典的基于类的模型要更加强大。 原型链JavaScript 的对象是动态的属性集合，其中有一个属性用于指向其原型对象。这种类似链表的结构被称为原型链。 根据 ECMAScript，[[Prototype]] 符号用于指向对象的原型。 从 ECMAScript 6 开始，可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 来访问对象的原型。而非标准属性 __proto__ 也用访问对象的原型。 这与构造函数的prototype属性不同。使用构造函数构造的实例对象的原型（[[Prototype]]）是构造函数的 prototype。Object.prototype 属性表示 Object 的原型对象，通常是原型链最后一层。 属性继承当访问一个对象的属性时，不仅会在该对象中查找属性，也会顺着原型链一层层地查找，直到找到一个名字匹配的属性或者达到原型链末尾。而设置对象的属性时，将直接在当前对象中创建或修改属性（除非该属性设置了 getter 或 setter）。 示例： 123456789101112131415161718192021222324252627282930313233const A = function() { this.a = 1; this.b = 2; this.c = 3; this.d = 4;};A.prototype.b = 5;Object.defineProperty(A.prototype, 'c', { get() { return 6; }});let d = 7;Object.defineProperty(A.prototype, 'd', { get() { return d; }, set(value) { d = value; }});const a = new A();// 原型链为 a { a: 1, b: 2 } -&gt; A.prototype { b: 4, c: 5, d: 7 } -&gt; Object.prototype -&gt; nullconsole.log(a.a); // 1console.log(a.b); // 2console.log(a.c); // 6console.log(a.d); // 4console.log(a.e); // undefinedconsole.log(A.prototype.b); // 5console.log(A.prototype.c); // 6console.log(A.prototype.d); // 4 注： a 中的 b 属性覆盖了原型上的 b 属性，这种情况叫做属性遮蔽（Property Shadowing）。 只定义 getter 的属性无法修改，也无法遮蔽。 定义了 setter 的属性将按照 setter 定义的方式去修改，不会进行遮蔽。 方法继承JavaScript 中其实并没有基于类的方法这一概念。在 JavaScript 中，我们把函数类型的属性称为方法。方法的继承和其他属性没有差别，包括属性遮蔽（这时候相当于方法的覆写）。 当继承的函数被调用时，this 指向当前对象，而不是继承的函数所在的原型对象。 示例： 123456789101112const parent = { val: 2, add(val) { this.val += val; }};const child = Object.create(parent); // 创建一个以 parent 为原型的对象child.val = 4;child.add(4);console.log(child.val); // 8console.log(parent.val); // 2 构造函数的 prototype 属性我们知道，JavaScript 中的函数也是对象的一种，函数也可以定义属性。而每一个函数都有一个特殊的属性 —- “prototype”，用于表示当这个函数用作构造函数时，所构造的对象的原型对象。 prototype 属性默认包括两个属性： “constructor” 属性，指向原来那个函数 “__proto__“ 属性，指向这个原型对象的原型（如之前所说，这是一个非标准属性） 通过不同方式创建对象并生成原型链使用字面量或者函数语法1234567891011121314const object = { a: 1 };// object// -&gt; Object.prototype { hasOwnProperty, ... }// -&gt; nullconst array = [2, 3, 4];// array// -&gt; Array.prototype { indexOf, forEach, ... }// -&gt; Object.prototype -&gt; nullconst func = () =&gt; 5;// func// -&gt; Function.prototype { call, bind, ...}// -&gt; Object.prototype -&gt; null 构造函数123456789101112function Graph() { this.vertices = []; this.edges = [];}Graph.prototype.addVertex = function(v) { this.vertices.push(v);};const g = new Graph();// g// -&gt; Graph.prototype { addVertex }// -&gt; Object.prototype -&gt; null Object.create1234567891011121314const a = { a: 1 };// a -&gt; Object.prototype -&gt; nullconst b = Object.create(a);// b -&gt; a -&gt; Object.prototype -&gt; nullconst c = Object.create(b);// c -&gt; b -&gt; a -&gt; Object.prototype -&gt; nullconst d = Object.create(null);// d -&gt; nulld.hasOwnProperty();// 报错，因为 d 没有继承 Object.prototype class 关键字ECMAScript 引入了一套新的关键字，可以让开发者用于使用基于类风格的语法来编写代码。但是这只是语法糖，其内部实现仍然是基于原型的。 这些关键字包括：class, constructor, static, extends 和 super。 12345678910111213141516171819202122232425262728class Rectangle { constructor(width, height) { this.width = width; this.height = height; } get area() { return this.width * this.height; }}class Square extends Rectangle { constructor(sideLength) { super(sideLength, sideLength); } get sideLength() { return this.width; } set sideLength(newValue) { this.width = newValue; this.height = newValue; }}const square = new Square(2);// square { width, height }// -&gt; Square.prototype { sideLength }// -&gt; Rectangle.prototype { area }// -&gt; Object.prototype -&gt; null 性能在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。 遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从 Object.prototype 继承的 hasOwnProperty 方法，或者使用 Object.keys()。 注意：检查属性是否为 undefined 是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了 undefined。 扩充原生对象的原型经常使用的一个错误实践是扩展 Object.prototype 或其他内置原型。 这种技术被称为猴子补丁并且会破坏封装。尽管一些流行的框架（如 Prototype.js）在使用该技术，但仍然没有足够好的理由使用附加的非标准方法来混入内置原型。 扩展内置原型的唯一理由是支持 JavaScript 引擎的新特性（polyfill），如 Array.forEach。 比较四种扩展原型链的方法 使用构造的实例 123456789101112function foo() {}foo.prototype = { foo: 'foo' };function bar() {}const proto = new foo();proto.bar = 'bar';bar.prototype = proto;const inst = new bar();// inst// -&gt; bar.prototype (proto) -&gt; foo.prototype// -&gt; Object.prototype -&gt; null 优点：支持目前以及所有可想象到的浏览器(IE5.5 都可以使用). 这种方法非常快，非常符合标准，并且充分利用 JIST 优化。 缺点：在初始化 foo 构造函数的过程中，可能会想设置一些实例属性，但是 foo 的构造器只会执行一次，可能会引发潜在的问题。 Object.create 12345678910function foo() {}foo.prototype = { foo: 'foo' };function bar() {}bar.prototype = Object.create(foo.prototype, { bar: { value: 'bar' } });const inst = new bar();// inst// -&gt; bar.prototype -&gt; foo.prototype// -&gt; Object.prototype -&gt; null 优点：支持所有流行的浏览器，包括 IE9 及以上。仅对原型进行一次修改，可以让浏览器进行更好的优化，也支持创建没有原型的对象。 缺点：IE8 及以下不可使用。使用第二个参数进行属性设置的时候可能会耗费大量时间，因为对每个属性的描述也是一个对象，对成百上千个属性的设置可能造成延迟。 Object.setPrototypeOf 12345678910function foo() {}foo.prototype = { foo: 'foo' };function bar() {}bar.prototype = Object.setPrototypeOf({ bar: 'bar' }, foo.prototype);const inst = new bar();// inst// -&gt; bar.prototype -&gt; foo.prototype// -&gt; Object.prototype -&gt; null 优点：支持所有流行的浏览器，包括 IE9 及以上。允许动态修改对象的原型，甚至给没有原型的对象设置原型。 缺点：应当被禁用，且会造成严重的性能问题。因为许多浏览器对原型进行优化，而动态修改原型打乱了这些优化，甚至导致浏览器重新编译并优化代码。且 IE8 及以下不可使用。 __proto__ 123456789101112const inst = { __proto__: { bar: 'bar', __proto__: { foo: 'foo', __proto__: Object.prototype } }};// inst// -&gt; bar.prototype -&gt; foo.prototype// -&gt; Object.prototype -&gt; null 优点：支持所有流行的浏览器，包括 IE11 及以上。允许动态修改对象的原型，甚至给没有原型的对象设置原型。而且给一个不是对象的值设置 __proto__ 属性会什么都不做而不会导致异常。 缺点：应当被禁用，且会造成严重的性能问题。因为许多浏览器对原型进行优化，而动态修改原型打乱了这些优化，甚至导致浏览器重新编译并优化代码。且 IE10 及以下不可使用。 动态性对于 Java 或 C++ 的开发者来说，JavaScript 可能会使人困惑，因为一切都是动态的，运行时的。 在构造函数的 prototype 中设置的属性可以共享给所有构造出来的实例。 而甚至在实例构造之后，仍可以修改 prototype 的属性，其修改将影响所有继承该原型的对象（除非属性被遮蔽）。 总结在编写使用它的复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的 JavaScript 特性兼容。","link":"/2019/06/12/js-inheritance/"},{"title":"Rust学习笔记3 - 结构体","text":"本文是 Rust 学习笔记系列第三篇，参考 Rust 指南的第 5 章，涉及结构体、方法。 结构体（struct）是一种自定义的数据类型，用于将多个相关值组织成一个有意义的组合。如果熟悉面向对象的语言，会发现它和对象的数据属性类似。 接下来我们会比较结构体与元组的差异，演示如何使用结构体，讨论如何定义方法与关联函数。 结构体的定义与实例化结构体和元组类似，可以由不同类型的数据组成，但是需要对每个部分的数据进行命名，这些命名的数据就被称为字段（fields）。 Rust 中，使用 struct 关键词和以下语法定义结构体： 123456struct User { username: String, email: String, sign_in_count: u64, active: bool,} 要使用定义好的结构体，我们需要为每个字段提供具体值来创建它的实例： 123456let u1 = User { email: String::from(\"someone@example.com\"), username: String::from(\"someone123\"), active: true, sign_in_count: 1,} 我们可以用点语法来访问结构体的字段（instance.field_name），并且如果实例是可变的，我们就可以修改字段的内容。 Rust 不允许结构体的部分字段可变，只能是结构体整体可变或者不可变。 实例化语法也是一种表达式，因此我们可以用如下写法的函数创建实例： 12345678fn build_user(email: String, username: String) -&gt; User { User { email: email, username: username, active: true, sign_in_count: 1, }} 结构体字段省略写法当结构体的字段名与数据的变量名一致时，可以省略变量名的部分： 12345678fn build_user(email: String, username: String) -&gt; User { User { email, username, active: true, sign_in_count: 1, }} 结构体更新语法从旧的结构体修改部分属性来创建新的结构体是很常见的写法，我们可以用结构体更新语法来完成： 12345678910111213let u2 = User { email: String::from(\"another@example.com\"), username: String::from(\"another567\"), active: u1.active, sign_in_count: u1.sign_in_count,}// 结构体更新语法let u2 = User { email: String::from(\"another@example.com\"), username: String::from(\"another567\"), ..u1} 使用元组结构体来创建不同的类型有一种结构体与元组类似，不为字段命名。元组结构体通常用于给元组类型命名，并且要与其他元组作区分时使用。 12345struct Color(i32, i32, i32);struct Point(i32, i32, i32);let black = Color(0, 0, 0);let origin = Point(0, 0, 0); 单位结构体有一种结构体与单位类型（()）类似，不包含任何字段。单位结构体在当需要对某种类型实现特性但不需要任何字段时很有用。 结构体数据的所有权在上面的结构体定义中，我们没有使用引用，因为我们想要结构体拥有字段的所有权，这样字段的有效期与结构体一致了。 但是在结构体中是可以使用引用类型的字段的，但是需要我们使用 Rust 的生命周期（lifetimes）功能，生命周期用于保证引用的数据在结构体使用过程中有效。 一个使用结构体的例子为了理解结构体的例子，我们写一个计算矩形面积的程序。 先从简单的变量开始写： 12345678910111213fn main() { let width1 = 30; let height1 = 50; println!( \"The area of the rectangle is {} square pixels.\", area(width1, height1) );}fn area(width: u32, height: u32) -&gt; u32 { width * height} area 用于计算长方形的面积，但是却传入了两个整数类型的参数，表意并不明确。将这两个整数组合起来更具有可读性和可维护性。 使用元组来重构之： 123456789101112fn main() { let rect1 = (30, 50); println!( \"The area of the rectangle is {} square pixels.\", area(rect1) );}fn area(rect: (u32, u32)) -&gt; u32 { rect.0 * rect.1} 在面积计算中弄混宽和高并没有什么问题，可是如果我们需要绘制长方形，就不能弄错了。我们可以用结构体来使字段含义更加明确： 1234567891011121314151617struct Rect { w: u32, h: u32,}fn main() { let rect1 = Rect { w: 30, h: 50 }; println!( \"The area of the rectangle is {} square pixels.\", area(&amp;rect1) );}fn area(rect: &amp;Rect) -&gt; u32 { rect.w * rect.h} 使用衍生特性来添加功能在调试程序时，如果能够打印出结构体的内容会很方便。 如果我们尝试打印结构体，我们会得到编译错误： 12let rect1 = Rect { w: 30, h: 50 };println!(\"rect1 is {}\", rect1); 12345error[E0277]: `Rect` doesn&apos;t implement `std::fmt::Display` = help: the trait `std::fmt::Display` is not implemented for `Rect` = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead = note: required by `std::fmt::Display::fmt` = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info) println! 宏可以做很多格式化的事情，默认情况下，{} 用于提示 println! 使用 Display 来格式化（输出终端用户普遍预期的内容），前面介绍的基本类型都已经实现了 Display，因为基本类型的预期输出是固定的。但是结构体应该输出什么内容是不确定的，因此结构体不会提供 Display。 接着阅读错误提示，我们可以看到有提示让我们换成 {:?} 来格式化，我们改过来试试： 12let rect1 = Rect { w: 30, h: 50 };println!(\"rect1 is {:?}\", rect1); 得到的仍然是编译错误： 12345error[E0277]: `Rect` doesn't implement `std::fmt::Debug` = help: the trait `std::fmt::Debug` is not implemented for `Rect` = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug` = note: required by `std::fmt::Debug::fmt` = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info) 我们可以看到有提示让我们使用 #[derive(Debug)]。 Rust 有提供输出调试信息的功能，但是需要显式地将该功能应用于我们的结构体，我们需要在结构体定义的前面加上 #[derive(Debug)] 标记。 12345678910#[derive(Debug)]struct Rect { w: u32, h: u32,}fn main() { let rect1 = Rect { w: 30, h: 50 }; println!(\"rect1 is {:?}\", rect1);} 可以打印出如下内容： 1rect1 is Rect { w: 30, h: 50 } 如果使用 {:#?} 则会打印： 1234rect1 is Rect { w: 30, h: 50,} 方法上面的 area 的含义已经很明显了：计算矩形的面积。但是我们需要将这个方法与 Rect 结构体结合地更加紧密，因为它不能用于其他的结构体。我们可以将它转换成方法。 方法（Methods）与函数类似：使用 fn 定义，拥有名称，参数，返回值，函数体。然而不同之处在于，方法是在结构体（或者枚举或特性对象）的上下文内定义的，而且第一个参数始终是 &amp;self，引用调用方法的结构体的实例。 定义方法1234567891011121314151617#[derive(Debug)]struct Rect { w: u32, h: u32,}impl Rect { fn area(&amp;self) -&gt; u32 { self.w * self.h }}fn main() { let rect1 = Rect { w: 30, h: 50 }; println!(\"rect1 is {:?}\", rect1); println!(\"area of rect1 is {}\", rect1.area());} 要在函数体的上下文中定义函数，需要使用 impl 块。要调用方法，我们需要用方法调用的语法，例如：rect1.area()。 在方法的定义中，我们使用 &amp;self 代替了 rect: &amp;Rect，因为通过上下文可以知道其类型。需要注意这里我们仍然需要使用引用。和函数类似，方法可以拿走调用者所有权，或者使用不可变引用，或者使用可变引用。这里我们使用不可变引用是因为我们不需要所有权，且不会修改数据。如果在方法中需要修改结构体数据，就需要可变引用（&amp;mut self）。 在 C 和 C++ 中，有两个不同的操作符用于调用方法：instance.method()、pointer-&gt;method()（等价于 (*pointer).method()） 然而在 Rust 中，没有与 -&gt; 等价的操作符。因为 Rust 有自动引用和解引用的特性。调用方法是少数几个用到这个特性的地方。当调用方法时，Rust 会自动使用 &amp; &amp;mut * 来让调用者符合方法的签名 给方法增加参数我们试着给 Rect 结构体增加新的方法，这个方法需要接受一个别的 Rect 实例，并且当调用方能够包含这另一个矩形时返回 true。 123456789impl Rect { fn area(&amp;self) -&gt; u32 { self.w * self.h } fn can_hold(&amp;self, other: &amp;Rect) -&gt; bool { self.w &gt; other.w &amp;&amp; self.h &gt; other.h }} 关联函数impl 块的另一个有用的功能是，我们可以在其中定义一些没有 self 参数的函数。这些被称为是「关联函数」（associated functions）。关联函数经常用于结构体的构造函数，比如我们可以给 Rect 增加一个正方形的构造函数： 12345678910impl Rect { fn square(size: u32) -&gt; Rect { Rect { w: size, h: size } }}fn main() { let sq1 = Rect::square(3); println!(\"area of sq1 is {}\", sq1.area());} 我们用 :: 操作符来调用结构体的关联函数（或者模块的命名空间）。 多个 impl 块结构体允许使用多个 impl 块，这和都写在一个 impl 块里是等价的。 目前并不会用到多个 impl 块，但是之后说到范型和特性时，会再提到。 总结结构体可以用于定义具有行业特定含义的自定义类型。使用结构体，可以将关联的代码组织在一起，并且与其他的部分不会产生命名冲突。","link":"/2020/11/06/learning-rust-3/"},{"title":"Rust学习笔记5 - 模块管理","text":"本文是 Rust 学习笔记系列第五篇，参考 Rust 指南的第 7 章，涉及使用包、箱子、模块来管理项目。 在编写大项目时，很难将整个项目完整的装到脑子里，所以如何组织代码就很重要了。通过合理聚集相关功能、拆分不同功能的代码，可以让我们能够定位特定功能的代码的位置。 到目前为止，我们都是在一个文件里写的示例。随着项目变大，就需要将代码拆分到不同的模块、不同的文件中去。一个包（package）可以包含多个可执行箱子（binary crates）和最多一个库箱子（library crate）。随着包变大，可以将一部分提取到单独的箱子中（会成为外部依赖）。对于多个不相关的包构成的非常大的项目，cargo 提供了工作空间（workspace）。 除了聚集和拆分功能，封装具体实现可以让我们在更高的层次复用代码：一旦实现了一个功能，其他的代码可以通过公开的接口来使用该功能，而不需要关心具体实现。公开的接口与私有的实现可以通过代码来自己决定。 另一个相关的概念是「作用域」：在代码所在的嵌套上下文中，有一系列的名称是「在作用域内」的。在编写、阅读或者编译代码时，开发者与编译器需要知道特定位置的特定名称是指代的什么项目（item）：变量、函数、结构体、枚举、模块、常量还是什么其他的。同一个作用域中，不能有多个项目拥有相同的名称。 Rust 提供了多种特性用于管理代码结构，包括哪些细节要暴露，哪些细节要隐藏，以及每个作用域都有哪些名称。这些特性有时候被统称为「模块系统」： 包（Packages）：Cargo 的特性，用于构建、测试、共享箱子 箱子（Crates）：一个模块树，用于生成一个库或者可执行文件 模块（Modules）与使用（use）：允许控制路径的组织、作用域、可见性 路径（Paths）：一种命名项目（item）的方式，比如结构体、函数或者模块 包和箱子首先我们介绍包（Package）和箱子（Crate），箱子代表一个库或者可执行文件。箱子的根是一个源文件，Rust 编译器从这个文件开始编译，并构建箱子的根模块（模块会在稍微后面一点介绍）。包由一个或者多个箱子组成。包里会有一个 Cargo.toml 文件用于描述如何构建这些箱子。 包的内容物由多个规则决定：包里面最多只能有一个库箱子，包里面可以有任意多个可执行箱子，包里面至少要有一个箱子（可以是库箱子或者可执行箱子）。 通过 cargo new &lt;name&gt; 命令可以创建新的包。我们实际执行一下看看会发生什么：它会创建一个文件夹，并在里面创建一些文件。 在创建的文件中，我们先介绍这两个： 12Cargo.tomlsrc/main.ts Cargo 会创建一个 Cargo.toml 文件，表示一个包。Cargo.toml 里面并没有提到 src/main.ts 文件，这是因为 Cargo 约定 src/main.rs 是与包同名的可执行箱子的根源文件。与之类似，Cargo 约定，如果包里面存在 src/lib.ts，那包里就存在一个与包同名的库箱子，且 src/lib.ts 就是这个箱子的根源文件。Cargo 会把这些根源文件传给 rustc 来构建库或者可执行文件。 这个例子里，我们只有 src/main.ts 文件。如果包里同时存在 src/main.ts 和 src/lib.ts，那这个包里就同时存在与包同名的可执行箱子与库箱子。通过在 src/bin/ 目录下添加源文件，可以增加新的二进制箱子，每个文件都构成一个可执行箱子。 箱子可以聚集相关的功能到一个作用域里，以便可以在多个项目中共享。通过把箱子引入到作用域，我们就可以使用该箱子的功能了。通过箱子来封装功能代码可以避免命名冲突。因为不同箱子之间不属于同一个作用域，相同的命名不会产生冲突。 说完包和箱子，我们再介绍一下模块和模块系统中的其他部分，“路径”（paths）可以为项目（item）命名、use 关键字可以将路径引入作用域、pub 关键字用于将项目公开化、以及 as 关键字、外部包等。 首先先介绍模块。 模块，控制作用域和可见性模块（Module）可以将箱子内部的代码分成多个部分，提供可读性与易用性。模块也可以控制其中的项目的可见性（privacy），让其是公开的（在外部也可以使用）或者私有的（内部实现细节，外部不可见）。 作为例子，我们写一个提供餐厅的功能的库箱子。我们先定义好函数的签名，先不写实现。 在餐厅里，顾客所在的区域称为前台，在这里领位带领顾客入座，服务员为顾客点单和收银，酒保制作饮品。后台是大厨、厨师、洗碗工、经理们工作的地方。 我们可以用 cargo new --lib restaurant 创建一个包含库箱子的包。 12345678910111213141516171819// 餐厅前台mod front_of_house { // 领位 mod hosting { // 让顾客排队 fn add_to_waitlist() {} // 让顾客入座 fn seat_at_table() {} } // 服务员 mod serving { // 点单 fn take_order() {} // 服务 fn serve_order() {} // 收银 fn take_payment() {} }} 这段代码可表示下面的模块结构： 123456789crate: front_of_house: hosting: add_to_waitlist: fn seat_at_table: fn serving: take_order: fn serve_order: fn take_payment: fn 模块树中包含一些嵌套关系、一些邻接关系。如果模块 A 包含在模块 B 中，我们就称模块 A 是模块 B 的子模块，模块 B 是模块 A 的父模块。整个模块树的根节点是一个名为 crate 的隐藏模块。 路径，引用模块树中的项目Rust 为了在模块树中找到项目，使用了与文件系统类似的路径（path）。 路径有两种形式： 绝对路径：从箱子的根开始，以箱子名或者字面量 crate 为前缀 相对路径：从当前模块开始，以 self、super 或者当前模块中的标识符为前缀 不管是绝对路径还是相对路径，都用 :: 连接多个标识符。 举个例子： 1234567891011121314151617// 餐厅前台mod front_of_house { // 领位 mod hosting { // 让顾客排队 fn add_to_waitlist() {} }}// 根模块（crate模块）中定义的公开函数pub fn eat_at_restaurant() { // 绝对路径 crate::front_of_house::hosting::add_to_waitlist(); // 相对路径 front_of_house::hosting::add_to_waitlist();} 在这个例子中，虽然路径的引用是正确的，但是会因为 hosting 模块并非公开的而在编译时报错。 模块不仅仅用于组织代码，也用于定义 Rust 的可见性边界：模块中封装的实现并不能被外界所使用。所以想让一些项目私有的话，可以用一个模块把它装在里面。 Rust 中所有项目（items）的默认可见性都是私有的。父模块不能使用子模块中私有的项目，但是子模块可以使用任意父模块的私有项目。因为子模块对外隐藏细节，但是它仍然位于父模块的作用域内。 使用 pub 关键字来公开路径我们需要让路径上的每个节点都是可见的，才能够最终访问到路径所指的项目： front_of_house 本来就是对 eat_at_restaurant 可见的 hosting 和 add_to_waitlist 则需要使用 pub 关键字来将其变为公开的 1234567891011121314151617// 餐厅前台mod front_of_house { // 领位 pub mod hosting { // 让顾客排队 pub fn add_to_waitlist() {} }}// 根模块（crate模块）中定义的公开函数pub fn eat_at_restaurant() { // 绝对路径 crate::front_of_house::hosting::add_to_waitlist(); // 相对路径 front_of_house::hosting::add_to_waitlist();} 使用 super 关键字开始的路径我们可以用 super 来从父模块开始构造路径，类似文件系统中的 .. 符号。 例如： 12345678910mod back_of_house { fn fix_incorrect_order() { cook_order(); super::serve_order(); } fn cook_order() {}}fn serve_order() {} 使结构体和枚举公开化我们也可以用 pub 将结构体和枚举变成公开的，但是这里会多一些细节。如果我们对结构体使用 pub 关键字，结构体本身会变为公开的，但是其字段仍然是私有的。我们可以根据需要对每个字段设置可见性。 例如： 12345678910111213141516171819202122232425mod back_of_house { pub struct Breakfast { pub toast: String, seasonal_fruit: String, } impl Breakfast { pub fn summer(toast: &amp;str) -&gt; Breakfast { Breakfast { toast: String::from(toast), seasonal_fruit: String::from(\"peaches\"), } } }}pub fn eat_at_restaurant() { let mut meal = back_of_house::Breakfast::summer(\"Rye\"); meal.toast = String::from(\"Wheat\"); // 这个会报错，因为 seasonal_fruit 在此处不可见 // meal.seasonal_fruit = String::from(\"blueberries\"); println!(\"I'd like {} toast please\", meal.toast);} 与结构体不同，将枚举公开化的话，其所有的变种都会变为公开的，我们只需要在 enum 关键字前面加上 pub 关键字即可。 使用 use 关键字将路径引入到作用域中使用路径来指代项目看起来要写比较长的串，用起来会比较繁琐且臃肿。我们可以用 use 关键字来指代路径，并将其名称引入到当前作用域中，这样就不需要每次使用时都通过路径来访问了。 例子： 12345678910111213141516// 餐厅前台mod front_of_house { // 领位 pub mod hosting { // 让顾客排队 pub fn add_to_waitlist() {} }}use crate::front_of_house::hosting;pub fn eat_at_restaurant() { hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();} use 关键字就有点像文件系统中的软链接。 使用 use 关键字的语言习惯下面这串代码与上面的功能完全一致，但是我们会习惯用上面的那一种。 12345678910111213141516// 餐厅前台mod front_of_house { // 领位 pub mod hosting { // 让顾客排队 pub fn add_to_waitlist() {} }}use crate::front_of_house::hosting::add_to_waitlist;pub fn eat_at_restaurant() { add_to_waitlist(); add_to_waitlist(); add_to_waitlist();} 引入函数时，我们习惯只引入目标函数的路径父节点，这样我们在使用时就需要从其父节点开始写，与那些本就定义在当前作用域中的项目区分开来。而引入结构体、枚举等其他项目时，我们习惯直接引入目标路径。这个习惯并没有什么特别的原因，仅仅因为开发者习惯阅读这样的代码。 有一个例外情况是，如果我们要引入多个同名的项目，我们就都引入其父节点。 使用 as 关键字为项目提供新的名称对于上面引入同名项目的问题，有另一个解决方法就是将其中一个在当前作用域中重命名，我们使用 as 关键字为其指定新的名称： 12345use std::fmt::Result;use std::io::Result as IoResult;fn function1() -&gt; Result {}fn function2() -&gt; IoResult&lt;()&gt; {} 使用 pub use 将名称重新导出1234567891011121314mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} }}// hosting 也将作为 crate 的公开成员导出pub use crate::front_of_house::hosting;pub fn eat_at_restaurant() { hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();} 使用外部包我们可以在 Cargo.toml 中添加一个依赖来引入外部的包： 12[dependencies]rand = \"0.5.5\" 这样会让 Cargo 从 crates.io 下载 rand 包和其所有的依赖，并让 rand 在项目中可用。 123456// 以 rand 开始的路径可以引用其包中的内容use rand::Rng;fn main() { let secret_number = rand::thread_rng().gen_range(1, 101);} 标准库 std 也是一个包外部的箱子，因为其内置于 Rust 语言，不需要在 Cargo.toml 中添加依赖。 使用嵌套路径来组合多个 use 语句12345use std::cmp::Ordering;use std::io;// 可以合并为use std::{cmp::Ordering, io}; 在嵌套路径中可以用 self 表示当前的路径： 12345use std::io;use std::io::Write;// 合并为use std::io::{self, Write}; 使用 * 引入如果我们要引入一个路径中的所有公开项目，我们可以在最后一节使用 * 来指代所有项目： 1use std::collections::*; 将模块拆分到多个文件中当模块变得很多时，需要将其代码写到单独的文件中，以便查找。 我们将 front_of_house 模块的代码移到 src/front_of_house.rs 中： 12345678910111213141516171819// src/front_of_house.rs// 领位pub mod hosting { // 让顾客排队 pub fn add_to_waitlist() {} // 让顾客入座 fn seat_at_table() {}}// 服务员mod serving { // 点单 fn take_order() {} // 服务 fn serve_order() {} // 收银 fn take_payment() {}} 然后将 src/lib.rs 的内容改为： 12345678910// src/lib.rsmod front_of_house;pub use crate::front_of_house::hosting;pub fn eat_at_restaurant() { hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();} 在 mod &lt;name&gt; 后面接 ; 会让 Rust 从同名的文件中加载该模块的内容。 我们再创建一个 src/front_of_house/hosting.rs 文件，把 hosting 模块的代码移进去： 123456// src/front_of_house/hosting.rs// 让顾客排队pub fn add_to_waitlist() {}// 让顾客入座fn seat_at_table() {} 然后修改 src/front_of_house.rs 的内容： 1234// src/front_of_house.rs// 领位pub mod hosting; 可以看到文件结构与模块树是一致的。 总结Rust 的模块系统可以让你用多个箱子与模块等来组织包里的代码。所有的内容都是默认私有的，对当前模块外部是不可见的。","link":"/2020/11/13/learning-rust-5/"},{"title":"Rust学习笔记4 - 枚举与模式匹配","text":"本文是 Rust 学习笔记系列第四篇，参考 Rust 指南的第 6 章，涉及枚举和模式匹配。 接下来我们会介绍「枚举」（enumerations, abbr. enums），通过列举所有可能的变种来定义的类型。首先会尝试定义和使用枚举。接下来会介绍一种特殊且有用的枚举 Option（表示有值或者无值）。然后会介绍如何使用 match 表达式来进行模式匹配。最后会介绍另一种用于枚举的方便简洁的机制 if let。 枚举在许多语言中都有涉及，但是几乎在每个语言中承载的功能都有所不同。Rust 的枚举类似于函数式语言（比如 F#、OCaml、Haskell）的代数数据类型。 定义枚举我们来考虑一种使用枚举的场景：IP 地址。IP 地址目前有两种格式：IPv4 和 IPv6。所以在程序中我们是可以将 IP 地址格式全部枚举出来的。 所有的 IP 地址都是 IPv4 或者 IPv6 其中一种。这使得 IP 很适合用枚举这种数据结构来表达。 我们来定义用于表示 IP 类型的枚举： 1234enum IPAddr { V4, V6,} 枚举值我们可以为枚举的两个变种创建实例： 12let four = IPAddr::V4;let six = IPAddr::V6; 枚举的变种在它自身的命名空间里，可以用 :: 操作符来访问到。 我们可以让函数参数接受枚举类型： 1234fn route(ip_kind: IPAddr) {}route(four);route(six); 使用枚举还有更多的好处。比如说我们需要一个表示 IP 地址的类型，按照目前为止介绍的内容，我们可以构造出类似这样的结构体： 12345678910111213141516171819enum IPAddrKind { V4, V6,}struct IPAddr { kind: IPAddrKind, address: String,}let home = IpAddr { kind: IpAddrKind::V4, address: String::from(\"127.0.0.1\"),};let loopback = IpAddr { kind: IpAddrKind::V6, address: String::from(\"::1\"),} 而实际上，我们可以用只使用枚举完成这样的定义： 1234567enum IPAddr { V4(String), V6(String),}let home = IPAddr::V4(String::from(\"127.0.0.1\"));let loopback = IPAddr::V6(String::from(\"::1\")); 我们可以直接在枚举中为每个变种定义关联数据，而且每个变种的关联数据类型可以不同。比如，我们可以将 IPv4 的数据定义为 4 个 u8 类型。 1234567enum IPAddr { V4(u8, u8, u8, u8), V6(String),}let home = IPAddr::V4(127, 0, 0, 1);let loopback = IPAddr::V6(String::from(\"::1\")); 我们再看另一个例子： 123456enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(u8, u8, u8),} 这个例子定义了四种不同数据类型的变种： Quit 没有关联数据 Move 有一个匿名结构体的关联数据 Write 有一个字符串的关联数据 ChangeColor 有三个整数的关联数据 这与直接定义如下四个结构体类似： 1234567struct QuitMessage;struct MoveMessage { x: i32, y: i32,}struct WriteMessage(String);struct ChangeColorMessage(u8, u8, u8); 但是如果使用结构体，就代表这些值都是不同的类型，就比较难定义一个通用的函数来接受这些值了。 枚举还有另一个与结构体相似的地方：枚举也可以定义方法和关联函数。 123456impl Message { fn call(&amp;self) {}}let m = Message::Write(String::from(\"hello\"));m.call(); 接下来我们看标准库中非常常见且有用的枚举：Option。 Option 枚举Option 是标准库中定义的枚举。它表示一个值有或者没有，是一个非常常见的场景。表达出一个值的有无，对于编译器来说，就可以分析你是否处理了所有的情况；这个功能可以避免在其他语言中常出现的 null 值问题。 编程语言的设计通常被认为是一个语言要包含哪些特性，然而不要包含哪些特性也是很重要的。Rust 不包含其他语言的 null 值特性。null 是一个表示没有值的值。在那些包含 null 值的语言里，通常变量会一直有两个状态：null 或者非 null。 null 值存在一个问题，如果你尝试把一个 null 值当作非 null 值来使用，会导致程序出错。而因为 null 值的普遍使用，使得这样的问题非常容易出现。 但是 null 值所表达的概念仍然很有用：一个值因为某些原因现在是无效的或者没有的。而问题不在于这个概念，而是具体的实现方式。因此 Rust 并不包含 null 值特性，而是用一个枚举来表达： 1234enum Option&lt;T&gt; { Some(T), None,} Option&lt;T&gt; 枚举非常常用，因此它被预置在了环境里，不需要自己引入。此外，它的变种 Some 和 None 也不需要 Option:: 前缀便可以使用。Option&lt;T&gt; 依然是一个标准的枚举，而 Some(T) 和 None 依然是枚举的变种。 &lt;T&gt; 是一个现在还没有介绍的特性：范型类型参数。现在，只需要知道它意味着 Some 的关联数据可以放入任何类型的数据。 1234let some_number = Some(5);let some_string = Some(\"a string\");let absent_number: Option&lt;i32&gt; = None; 如果我们使用 None，我们需要告诉编译期它是什么类型的，因为编译期无法推断出具体的范型类型。 因为 Option&lt;T&gt; 和 T 是两种不同的类型，Option&lt;T&gt; 并不能直接当作 T 来使用，这意味着我们需要判断 Option&lt;T&gt; 的值是哪一个变种。 现在，你不需要再担心 null 值问题了，因为如果需要用到 null 值，你必须显式使用 Option&lt;T&gt; 枚举，而在其他情况，根本不需要担心 null 值会出现。 如果要使用 Option&lt;T&gt;，就意味着你需要判断它的值到底值哪个变种，你会需要在它是 Some(T) 的情况下，取出 T 的值并使用，也会需要在它是 None 时，做一些处理。match 表达式是一种用于枚举的控制流程结构。 match 控制流程操作符Rust 的 match 表达式是一种功能非常强大控制流程，允许我们对一个值进行多种模式的比较，然后执行匹配的模式所对应的代码。模式可以是字面量，变量名，通配符等。后面会详细介绍每一种模式。match 强大的功能来自模式的表达能力，以及编译器会保证你要覆盖所有的可能性。 可以把 match 表达式想像成硬币分类器：硬币会跟随轨道向下滑动，并且会在第一个合适的洞掉下去。与之类似，match 会寻找第一个匹配的模式，然后所比较的值会填进这个模式，并执行对应的代码块。 我们可以用 match 来模拟硬币分类器的逻辑： 123456789101112131415161718enum Coin { Penny, // 1美分 Nickel, // 5美分 Dime, // 10美分 Quarter, // 25美分}fn value_in_cents(coin: Coin) -&gt; u8 { match coin { Coin::Penny =&gt; { println!(\"Lucky penny!\"); 1 }, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, }} 绑定值的模式模式的另一个有用的特性是它可以从匹配的值中提取部分值。 还是上面的例子，25 美分在不同的州是不一样的，我们可以尝试读取出它的州： 12345678910111213141516171819202122232425#[derive(Debug)] // Debug用于打印名字enum UsState { Alabama, Alaska, // --snip--}enum Coin { Penny, // 1美分 Nickel, // 5美分 Dime, // 10美分 Quarter(UsState), // 25美分}fn value_in_cents(coin: Coin) -&gt; u8 { match coin { Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; { println!(\"State quarter from {:?}!\", state); 25 } }} 匹配 Option&lt;T&gt;上面我们介绍了 Option 枚举，我们需要在当它有值时，取出其中的值来使用；在它没有值时，做一些其他操作。 我们写一个函数，接收一个 Option&lt;i32&gt;，在当它有值时，给值加一，并返回包含新值的 Option。 我们可以发现，用 match 能够以很简洁的代码写出这个函数： 123456fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; { match x { None =&gt; None, Some(i) =&gt; Some(i + 1), }} 匹配总是覆盖所有情况编译器会向我们保证 match 表达式总是能覆盖所有情况，如果我们只覆盖了部分情况，则会产生编译错误。 12345fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; { match x { Some(i) =&gt; Some(i + 1), }} 123error[E0004]: non-exhaustive patterns: `None` not covered = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms = note: the matched value is of type `std::option::Option&lt;i32&gt;` _ 占位符当我们不想遍历所有情况时，可以用 Rust 提供的通配模式。比如我们只想在 u8 值为 1, 3, 5, 7 时做一些操作，我们可以用 _ 来表示所有其他情况： 12345678let value = 0u8;match value { 1 =&gt; println!(\"one\"), 3 =&gt; println!(\"three\"), 5 =&gt; println!(\"five\"), 7 =&gt; println!(\"seven\"), _ =&gt; (),} 然而，如果我们只想在一种模式匹配时执行一些代码，match 就有点累赘了，这时候我们可以选择用 if let 用 if let 进行简练的流程控制if let 语法允许我们将 if 和 let 以一种简练的方式组合起来，让我们在符合某种模式时处理代码，并且忽略剩余的情况，比如上面那个 u8 的例子： 123456789101112let value = Some(0u8);// matchmatch value { Some(3) =&gt; println!(\"three\"), _ =&gt; ()}// if letif let Some(3) = value { println!(\"three\");} 我们再考虑上面那个分硬币的例子，如果我们在找到 25 美分时通知别人，而其他的硬币都计入计数，我们可以这样写： 123456789101112let mut count = 0;match coin { Coin::Quarter(state) =&gt; println!(\"State quarter from {:?}!\", state), _ =&gt; count += 1,}if let Coin::Quarter(state) = coin { println!(\"State quarter from {:?}!\", state);} else { count += 1;} 总结我们介绍了枚举的用法，并且介绍了使用 Option&lt;T&gt; 枚举来处理其他语言里 null 值的情况。 介绍了 match 和 if let 两种用于模式匹配的语法。","link":"/2020/11/09/learning-rust-4/"},{"title":"Rust学习笔记7 - 错误处理","text":"本文是 Rust 学习笔记系列第七篇，参考 Rust 指南的第 9 章，主要讲错误处理，将涉及 panic! 和 Result&lt;T, E&gt;。 Rust 对可靠性的保证也包括错误处理的部分。错误是在软件开发中无法避开的问题，Rust 提供了多种用于解决出错情况的特性。大部分情况下，Rust 会在编译时告知可能存在的问题，要求你在编译时就解决该问题。这些要求可以让你的程序变得更加健壮，因为它会确保你在发布代码之前可以发现问题并且采取合适的解决方法。 Rust 将错误分为两类：可恢复的错误与不可恢复的错误。可恢复的错误指可以合理的告知用户并且要求重试的错误，比如找不到文件；不可恢复的错误是缺陷的同义词，比如尝试数组下标越界等。 大部分语言不会区分这两者，通过异常（Exception）机制等方式提供统一的解决方法。但是 Rust 中没有实现异常，而是提供了 Result&lt;T, E&gt; 类型用于处理可恢复错误，用 panic! 宏来在遭遇不可恢复错误时，让程序中止。 不可恢复错误与 panic!有些情况下，当代码出错时，开发者没法解决这些问题。Rust 提供 panic! 宏用于应对这种场景。当执行到 panic! 宏时，程序会打印错误信息，释放并清理所使用的内存，然后结束进程。通常发生在检测出某种缺陷，并且开发者并不明确如何去解决这个错误的时候。 默认情况下，程序在 panic 时，会释放栈（按顺序弹出栈空间，并清理所使用的数据），但是这个过程也是一个不小的开销。另一种方法是就是立即中止执行。那些被程序所占用的内存需要由操作系统来清理。如果需要让编译出的二进制文件尽量小，可以在 Cargo.toml 的 [profile] 节中添加 panic = 'abort' 配置，比如 ： 12[profile.release]panic = 'abort' 我们可以在程序中直接使用 panic!： 123fn main() { panic!(\"Oops!\");} 执行代码会得到如下输出： 123456$ cargo run Compiling panic_example v0.1.0 (/projects/panic_example) Finished dev [unoptimized + debuginfo] target(s) in 0.45s Running `target/debug/panic_example`thread &apos;main&apos; panicked at &apos;Ooops!&apos;, src/main.rs:2:5note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 查看 panic! 发生的调用栈如果发生的 panic 并不是由我们自己编写的 panic! 触发的，我们就需要通过调用栈来查找到底是哪里导致的这个问题。 12# 通过设置变量 RUST_BACKTRACE=1 可以让程序打印出详细的调用栈RUST_BACKTRACE=1 cargo run 可恢复的错误与 Result大部分错误并没有严重到需要程序中止。有时候函数执行失败时，其原因可以轻易地理解并做出应对。比如当找不到文件时，可能会尝试创建一个文件，而不是让程序中止。 Result 的定义如下： 123456enum Result&lt;T, E&gt; { // 表示成功的结果，包括T类型的数据 Ok(T), // 表示失败的结果，包括E类型的原因 Err(E),} 我们来试试文件读取的代码： 12345678910111213use std::fs::File;fn main() { // 这时候 f 是 Result 类型的 let f = File::open(\"hello.txt\"); let f = match f { // 如果成功，将打开的文件赋值给新的变量 f Ok(file) =&gt; file, // 如果失败，就直接中止程序 Err(error) =&gt; panic!(\"Cannot open the file: {:?}\", error), };} 匹配不同错误类型File::open 返回的结果中，错误为标准库提供的 io::Error 类型。其中 kind 方法可以得到一个 io::ErrorKind 枚举类型的值，可以用于判断错误原因。 我们尝试更详细的例子： 123456789101112131415161718192021222324use std::fs::File;use std::io::ErrorKind;fn main() { let f = File::open(\"hello.txt\"); let f = match f { Ok(file) =&gt; file, // 如果打开失败，匹配 kind() 的结果 Err(error) =&gt; match error.kind() { // 如果原因是找不到文件，尝试创建文件 ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") { // 如果创建成功，则返回创建的文件 Ok(created_file) =&gt; created_file, // 否则中止程序 Err(create_err) =&gt; panic!(\"Problem creating the file {:?}\", create_err), }, // 如果是其他原因，中止程序 other_error =&gt; panic!(\"Problem opening the file: {:?}\", other_error), }, }; println!(\"File: {:?}\", f);} 出错时中止的快捷方法：unwrap 与 expect使用 match，我们可以正常进行错误判断，并根据不同情况进行处理，不过这些 panic! 稍微有点繁琐。Result&lt;T, E&gt; 类型中有一些函数可以帮我们简化这个任务。 123456789use std::fs::File;fn main() { // unwrap会在成功时直接返回结果数据，失败时直接panic，输出标准的信息 let f = File::open(\"hello.txt\").unwrap(); // expect会在成功时直接返回结果数据，失败时直接panic，以参数传入的字符串开头 let f = File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");} 传递错误有时候你实现了一个函数，但是并不想在函数内部决定如何处理错误，而是交给调用者来处理，这时候我们需要将错误传递到函数外面。 123456789101112131415161718192021222324use std::fs::File;use std::io;use std::io::Read;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; { let f = File::open(\"hello.txt\"); // 要调用 `read_to_string`，文件必须是可变的 let mut f = match f { Ok(file) =&gt; file, // 打开文件出错时，函数直接返回错误结果 Err(e) =&gt; return Err(e), }; let mut s = String::new(); match f.read_to_string(&amp;mut s) { // 读取成功时，返回成功的字符串 Ok(_) =&gt; Ok(s), // 读取失败时，返回错误结果 Err(e) =&gt; Err(e), }} 传递错误的快捷方法：?下面的例子和刚刚那个一样，只是使用了 ? 来快捷传递错误。 1234567891011fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; { // 打开文件成功时返回文件，失败时直接让函数返回错误结果 let mut f = File::open(\"hello.txt\")?; let mut s = String::new(); // 读取到字符串，失败时直接让函数返回错误结果 f.read_to_string(&amp;mut s)?; // 返回成功读取的字符串 Ok(s)} 利用 ?，我们甚至可以将代码简化为： 12345678910fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; { let mut s = String::new(); // 打开文件，失败时直接让函数返回错误结果 // 打开成功时，调用 read_to_string 方法 File::open(\"hello.txt\")?.read_to_string(&amp;mut s)?; // 返回成功读取的字符串 Ok(s)} ? 只能用于返回 Result\b 的函数中（或者其他实现了 Try 特性的类型），在其他的函数中，还得写代码判断 Result 的结果。 1234567891011121314151617use std::fs::File;use std::io;use std::io::Read;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; { let mut f = File::open(\"hello.txt\")?; let mut s = String::new(); f.read_to_string(&amp;mut s)?; Ok(s)}fn main() { // 这里使用 ? 会导致编译错误 let f = read_username_from_file()?; println!(\"File: {:?}\", f);} 不过，main 函数是比较特殊的，它的返回值类型有一定的约束。其中 () 和 Result&lt;T, E&gt; 都是允许的返回类型。 我们可以这样修改 main，让它里面可以使用 ?： 12345678910111213141516171819use std::error::Error;use std::fs::File;use std::io;use std::io::Read;fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; { let mut f = File::open(\"hello.txt\")?; let mut s = String::new(); f.read_to_string(&amp;mut s)?; Ok(s)}fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let f = read_username_from_file()?; println!(\"File: {:?}\", f); Ok(())} 这里 Box&lt;dyn Error&gt; 类型被称为是特性对象，这里我们只需要知道它可以指代任意类型的错误。 到底要不要 panic!所以我们到底啥时候该调用 panic!，啥时候返回 Result 呢？调用 panic! 会使一个可恢复的问题变成不可恢复的错误，所以通常情况下，我们会选择返回 Result。但是在少数情况下，使用 panic! 更加合适。 示例代码、原型代码、测试代码当为了说明一些概念而编写示例时，进行完善的错误处理会让例子更加复杂。这时候使用 unwrap 或者 except 来简单提示此处可能会产生错误会更好些。 与之类似，当你在原型代码中尚未决定如何处理一些错误时，可以先使用 unwrap 或者 except 来表示此处会产生错误，在后面再通过具体的处理代码来替换掉即可。 在测试中，panic! 是测试失败的标志。即使不是测试的目标，也可以用 unwrap 或者 except 来让错误不可恢复。 当你比编译器了解更多信息时另一种适合使用 unwrap 的场景是，你有一些其他的逻辑可以保证 Result 只会是 Ok 的。但是编译器可能不知道这些逻辑，他仍然会要求你处理错误情况。 比如： 1234use std::net::IpAddr;// 这里我们知道 127.0.0.1 是有效的IP地址，但是编译器只会识别为一般的字符串。let home: IpAddr = \"127.0.0.1\".parse().unwrap(); 错误处理指南建议在可能导致程序进入「错误的状态」时使用 panic!，「错误的状态」是指某些假设、保证、约定、等式不成立的状态，比如无效的值、自相矛盾的值、缺失的值等等传入程序、并满足以下某些条件： 「错误的状态」并不是预期偶尔发生的情况 这之后的代码需要依赖正确的状态执行 没有好的方式将其转换为所使用的类型 如果某人使用了你的代码，并且传入某些无效的值，最好的选择就是使用 panic! 告诉他代码中存在缺陷，并让其修复该问题。类似地，在调用外部代码时失去控制导致无效状态产生时，也经常使用 panic!。 然而，如果失败结果也是预期结果之一时，使用 Result 就更加合适了，比如，解析某种格式的数据或者 HTTP 请求达到频率限制。这些都是程序所预期的错误场景，需要在程序中有明确处理逻辑。 当代码对某些值执行操作时，应该首先验证这些值是否有效，否则抛出 panic!。这主要是出于安全考虑：尝试在无效的数据上进行操作会使代码暴露出漏洞。这也是标准库会在你尝试越界访问内存时使用 panic! 的原因。函数通常存在一些约束：函数的行为仅在满足特定条件的情况下保证正常。当这些约束被打破时应该抛出 panic!，因为这属于调用方的代码缺陷，调用方的开发者需要修复这个问题。函数的约束应该在 API 文档中描述清楚。 然而，在函数中加入大量的错误检查逻辑有些啰嗦且烦人。幸好，我们可以依赖 Rust 的类型系统（编译器的类型检查）来完成大多数检查。如果函数有特定的参数类型，那么编译器会为你保证传入的参数值有正确的类型。如果是某个确切类型而不是 Option，那么程序的预期就是有正确类型的值，而不是没有值，就不需要再处理 Some 或者 None 的情况了。 创建自定义的类型用于验证1234567891011121314151617181920// 创建猜数字的结构，用于保存数值pub struct Guess { // value不是公开的，所以模块外部无法使用 Guess { value } 来构造 value: i32,}impl Guess { // 创建示例时，会为我们检查数值的范围 pub fn new(value: i32) -&gt; Guess { if value &lt; 1 || value &gt; 100 { panic!(\"Guess value must be between 1 and 100, got {}.\", value); } Guess { value } } // 这样在函数外部使用 value() 函数得到的值就一定是 1-100 的数字了 pub fn value(&amp;self) -&gt; i32 { self.value }} 这样我们只要把相应的函数的参数约束为 Guess 类型，我们就一定能够得到 1 - 100 的数字。 总结Rust 中错误处理相关的功能是设计来帮助你编写健壮的代码的。 panic! 宏将标志你的程序将进入无法处理的状态，会中止程序执行，而不是尝试继续在该状态下执行。Result 枚举使用 Rust 的类型系统来代表程序中可能执行失败，但是可以进行相应的恢复处理的情况。可以使用 Result 来告诉调用方存在一些错误的情况需要处理，使用 panic! 来告诉调用方他的调用不满足函数的约束/使用前提，可以活用 Rust 的类型系统来直接约束函数的参数。","link":"/2020/11/29/learning-rust-7/"},{"title":"Rust学习笔记6 - 常用集合类型","text":"本文是 Rust 学习笔记系列第六篇，参考 Rust 指南的第 8 章，涉及向量（vector）、字符串（string）和哈希表（hash map）。 使用向量储存一组数据首先我们介绍向量类型 Vec&lt;T&gt;。向量允许我们在一个数据结构中存储多个值，并且多个值存储在邻接的内存中。向量只能存储相同类型的值。 创建新的向量12345// 因为无法推断元素的类型，要注明类型let vec1: Vec&lt;i32&gt; = Vec::new();// 可以用 vec! 来创建含有元素的向量let vec2: vec![1, 2, 3]; 修改向量12345678// 可以从下面的方法调用推导元素类型，所以此处可以省略类型标注let vec1 = Vec::new();vec1.push(5);vec1.push(6);vec1.push(7);vec1.push(8);vec1.push(9); 销毁向量的同时会销毁元素和其他的结构体一样，向量在脱离作用域时，会被销毁。 当向量被销毁时，存储在里面的值也会被销毁，当你引用了一些元素时，这会变的比较复杂。 读取向量的元素123456789101112131415let v = vec![1, 2, 3, 4, 5];// 当下标超出范围时，会产生paniclet third: &amp;i32 = &amp;v[2];println!(\"The third element is {}\", third);// 可以安全地判断元素是否存在match v.get(2) { Some(third) =&gt; println!(\"The third element is {}\", third), None =&gt; println!(\"There is no third element.\"),};if let Some(third) = v.get(2) { println!(\"The third element is {}\", third);} 对向量元素的引用仍然满足之前所介绍的所有权与借用规则。 12345678910let mut v = vec![1, 2, 3, 4, 5];// 不可变借用let first = &amp;v[0];// 可变借用v.push(6);// 不可变借用的作用域跨越了可变借用，产生编译错误println!(\"The first element is: {}\", first); 这段代码看起来好像没有问题，向向量中添加一个元素，怎么会影响第一个元素呢？这与向量的实现方式有关系，向量添加元素时，可能会需要分配新的内存地址，并且将所有元素都拷贝过去，这时候对任意元素的引用都将会出问题。 遍历向量的元素使用 for 循环可以获取向量每个元素的不可变引用： 1234let v = vec![100, 32, 57];for i in &amp;v { println!(\"{}\", i);} 也可以对可变向量使用 for 循环，获取可变引用： 12345678// 需要是可变向量let mut v = vec![100, 32, 57];// 要对向量的可变引用遍历for i in &amp;mut v { // 要修改元素，需要使用解引用 *i += 50;} 配合枚举来存储多种类型的数据1234567891011enum SpreadsheetCell { Int(i32), Float(f64), Text(String),}let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\"blue\")), SpreadsheetCell::Float(10.12),]; 使用字符串存储 UTF-8 编码的文本Rust 新手通常会卡在字符串上，因为：Rust 倾向于暴露所有可能的问题，字符串类型比预期更加复杂，以及 UTF-8 编码，这三个问题揉在一起，会让问题看起来很复杂。 我们在介绍集合类型时介绍字符串，因为字符串被设计成是字节的数组，加上一些以将字节解释为文本为基础来提供功能的方法。 什么是字符串首先我们需要定义清楚什么是“字符串”。Rust 在语言核心中只有一种字符串类型：字符串切片 str，通常以借用的形式 &amp;str 出现。之前我们介绍了字符串切片，它是对储存在其他地方的 UTF-8 编码的字符串数据的引用。字符串字面量是字符串切片的一种，存储在程序的二进制文件中。Rust 的标准库中的 String 类型，是一种可变的、有所有权的 UTF-8 编码的字符串类型。Rust 开发者提及字符串时，通常指这两者，而不是其中一种。 Rust 标准库中也有一些其他的字符串类型，比如 OsString、OsStr、CString 和 CStr。其他的库可能会提供更多的字符串存储方案。 创建字符串123456789101112// 创建空的可变字符串let mut s = String::new();// 使用已有的切片创建Stringlet data = \"initial contents\";let s = data.to_string();// 字符串字面量也可以直接创建Stringlet s = \"initial contents\".to_string();// 也可以String::from方法创建let s = String::from(\"initial contents\"); 因为字符串是 UTF-8 编码的，我们可以放入任何正确编码的文本数据，比如中文、Unicode 表情符号等。 修改字符串使用 push_str 和 push 追加文本12345678let mut s = String::from(\"foo\");s.push_str(\"bar\"); // 追加字符串s.push('l'); // 追加字符let mut s1 = String::from(\"foo\");let s2 = \"bar\";s1.push_str(s2); // 不需要所有权println!(\"s2 is {}\", s2); // 可以正常借用 使用 + 操作符或者 format! 宏拼接文本123let s1 = String::from(\"Hello, \");let s2 = String::from(\"world!\");let s3 = s1 + &amp;s2; // s1产生了移动，之后就不可用了 s1 要用移动、s2 要用引用的原因在于 + 操作符使用了字符串的 add 方法，而该方法的签名是： 1fn add(self, s: &amp;str) -&gt; String {} 实际在标准库中，add 方法是使用范型定义的。 123456789let s1 = String::from(\"tic\");let s2 = String::from(\"tac\");let s3 = String::from(\"toe\");// 对于更多元素的拼接，就比较复杂了let s = s1 + \"-\" + &amp;s2 + \"-\" + &amp;s3;// 使用 format! 宏可以简化let s = format!(\"{}-{}-{}\", s1, s2, s3); 使用下标访问字符串在很多其他语言中，使用下标访问字符串的字符是有效的且很常见的。但是在 Rust 中，无法使用数字下标获取字符串中的字符。 字符串的内部表示String 类型是对 Vec&lt;u8&gt; 类型的封装。 12345// 英文字母由单字节组成，所以看起来还很正常let hello = String::from(\"Hola\"); // [b'H', b'o', b'l', b'a'];// 中文字符由多字节组成，一个字符并不对应一个字节let hello = String::from(\"你好\"); 所以对应下标位置的字节并不对应字符。 字节、字符、字形簇另一个问题是 UTF-8 编码在 Rust 的角度下有三个不同的视图：字节、字符（Unicode 标量）、字形簇（字形簇最接近所谓的字母）。 比如印度的梵文词「नमस्ते」： 123456789// 字节表示let bytes = [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,224, 165, 135];// 字符表示let chars = ['न', 'म', 'स', '्', 'त', 'े'];// 字形簇表示let graphs = [\"न\", \"म\", \"स्\", \"ते\"]; 而最终 Rust 不允许使用下标访问字符串的原因在于，下标访问应该具有 O(1) 的复杂度。而在字符串中这是不可能保证的，因为必须从头开始遍历字符串来数有多少个有效字符。 字符串切片虽然不允许下标访问，Rust 还是允许我们使用切片语法获取字符串的切片，只是如果我们的切片的开始或结束位置不在字符边界上，就会造成 panic（导致程序崩溃）。 遍历字符串的方法幸运的是，我们仍然可以通过其他方式来遍历字符串： 1234567891011// 可以遍历所有2个字符for c in \"你好\".chars() { println!(\"{}\", c);}// 可以遍历所有6个字节for c in \"你好\".bytes() { println!(\"{}\", c);}// Rust标准库中不提供字形簇的遍历方法 使用哈希映射存储关联的键与值最后一个要介绍的常用集合是哈希映射（hash map）。HashMap&lt;K, V&gt; 类型存储 K 类型的键与 V 类型的值的映射。哈希映射使用哈希函数来决定键与值如何存放在内存中。这种数据结构在很多语言中都有实现，只是名称有所不同：哈希、映射、对象、哈希表、字典、关联数组等。 哈希映射通常用于希望通过一个标记而不是下标来寻找数据的场合。 创建新的哈希映射12345678910// 由于哈希映射并不如字符串或者向量那样常用，所以并没有自动引入到上下文中// 需要手动进行引入use std::collections::HashMap;// 与向量类似，哈希映射所有的键需要是相同类型，所有的值需要是相同类型// 与向量类似，此处可以通过下面的方法调用来推断键与值的类型let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.insert(String::from(\"Yellow\"), 50); 还可以通过迭代其他集合的方式来创建哈希映射： 12345678use std::collections::HashMap;let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")];let initial_scores = vec![10, 50];// 这里需要注明类型，因为 collect() 方法可以返回多种类型的结果let mut scores: HashMap&lt;_, _&gt; = teams.into_iter().zip(initial_scores.into_iter()).collect(); 哈希映射与所有权对于 i32 这种实现了 Copy 特性的类型，值可以复制到哈希映射中。而对于其他的类型，比如String，值会移动到哈希映射中。 1234567891011use std::collections::HashMap;let field_name = String::from(\"Color\");let field_value = String::from(\"Blue\");let mut map = HashMap::new();map.insert(field_name, field_value);// 这里会产生编译错误，因为field_name, field_value已经失去了所有权println!(\"{} -&gt; {}\", field_name, field_value); 如果我们将引用插入到哈希映射中，就不会产生移动。但是被引用的数据必须在哈希映射有效时始终保持有效（有关 Rust 的 “生命周期” 特性）。 访问哈希映射中的值12345678910111213141516171819use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.insert(String::from(\"Yellow\"), 50);let team_name = String::from(\"Red\");// get() 方法返回一个 Option，需要手动判断里面有没有值if let Some(score) = scores.get(&amp;team_name) { println!(\"{} -&gt; {}\", team_name, score);} else { println!(\"{} -- None\", team_name);}// 可以使用 for 循环来遍历哈希映射的每一对数据for (key, value) in &amp;scores { println!(\"{} -&gt; {}\", key, value);} 更新哈希映射中的值123456789101112131415161718192021222324252627use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);// insert会覆盖已有的值scores.insert(String::from(\"Blue\"), 25);// entry() 方法返回一个 Entry 枚举，表示对于指定的键有没有对应的数据// 同时其 or_insert() 方法，可以让我们在值不存在时，插入一个数据scores.entry(String::from(\"blue\")) .or_insert(50);// 基于已有值更新的方法：let text = \"hello world wonderful world\";let mut map = HashMap::new();for word in text.split_whitespace() { // 读取单词个数，如果没有就插入0，并返回个数 let count = map.entry(word).or_insert(0); // 解引用，并更新数据 *count += 1;} 哈希函数默认情况下，HashMap 使用一种密码学安全的哈希函数（siphash），可以帮我们抵御 DoS 攻击。这并不是最快的哈希函数，但是它带来的安全性是值得通过一部分性能去换取的。如果觉得默认的哈希函数太慢，可以通过实现 BuildHasher 特性来自定义哈希函数，或者使用成熟的第三方库。 总结向量、字符串、哈希映射可以提供关于存储、访问、修改数据的大部分功能。我们只了解了其一部分的用法，更多的用法需要通过标准库 API 文档来深入学习。","link":"/2020/11/26/learning-rust-6/"},{"title":"Rust的安全性设计","text":"Rust 是一门可以帮助我们编写高性能且高可用的程序的语言。Rust 的语言设计中包含了很多关于性能和可靠性的考虑，这次简单介绍一部分关于可靠性（安全性）的设计考虑。 Rust 语言Rust 是一门强类型的编译型语言，专注于性能和可靠性方面。 Rust 可以用于开发命令行工具、WEB 服务、DevOps 工具、嵌入式设备、音视频分析与转码、数字货币、生物信息学、搜索引擎、物联网应用、机器学习。Firefox 浏览器大部分组成都是使用 Rust 开发的。 Rust 提供了一整套开发工具包：包管理工具 Cargo、代码格式化工具、用于 IDE 集成的 RLS（Rust Language Server）。 Rust 会比其他大多数语言增加更多的约束，通过编译器检查这些约束，来在前期保证一定的可靠性。 Rust 在语法和类型的设计上，更倾向于时刻提醒开发者关于可靠性的选择。 Rust 的很多语法的设计都是基于默认更加安全的方式来设计的，比如：变量默认不可变、引用默认不可变、模块内部默认不可见等。 类型安全类型安全是所有强类型语言共有的特性，然而与大部分语言不同，Rust 中没有 null，你必须通过 Option&lt;T&gt; 类型来处理可能空值的情况。 12345// result可能是一个Result实例或者是nullResult result = Example.getResult();// 如果 result 是 null，这一段会怎么样？System.out.println(\"Got result: \" + result.toString()); 12345678910// get_result() 如果可能产生空的结果，那他必须返回 Option&lt;Result&gt;let result = Example.get_result();// 直接使用会产生编译错误\bprintln!(\"Got result: {}\", result);// 必须要进一步判断才能使用if let Some(result) = result { \bprintln!(\"Got result: {}\", result);} 内存安全说到内存管理就得说到垃圾回收，说到垃圾回收，除了开发者自己管理内存，常见的自动回收方式可能就是引用计数、标记擦除等方法，大部分都会产生 Stop-The-World 问题（针对这个问题，有些语言给出了优化的 GC 机制）。 如果由开发者自己管理内存，那么开发者的水平和开发时的精神状态，将直接与程序的健壮性相关 如果使用主流的 GC 机制，那么就无法避免 GC 中的多余开销（比如计数、标记，移动内存等） 内存管理从根本上来说是为了解决内存安全的问题： 如果内存没有在使用却没有释放，将造成无用的内存占用，长时间运行容易造成内存占用越来越大，最终无法导致性能极度下降或者无法保持程序执行 如果内存仍然在使用却提前释放，将导致多个数据使用同一片内存，将导致无法预期的错误或者是安全问题 Rust 通过增加更加严格的约束，从规则上面规避这些内存问题，并且由于这些约束是编译时检查，不会造成运行时多余的开销。 Rust 增加的规则被称为是所有权（Ownership），其规则为 3 条： 每个值都有一个所有者，通常是一个变量 每个值同时都只能有一个所有者 当所有者的生命周期结束时（变量的作用域结束时），所拥有的值会被释放（内存被回收） 123fn some() { let s = String::from(\"hello\"); // 分配了新的堆空间} // 变量s将不存在，其所拥有的堆空间将立即被释放 引用、数据竞争问题通过引用的方式，可以在不影响所有权的情况下，使用其他所有者所持有的值，但是引用同样存在约束，这是为了避免「数据竞争」问题，对引用的约束是： 在任意的时间点，每个值只能拥有一个可变引用，或者多个不可变引用 当引用存在时，所有者不能先被释放（即不允许存在「悬挂引用」） 在引用的问题上，Rust 还提供了生命周期范型来解决更加复杂的引用问题（引用传递时的生命周期问题）。 线程安全当程序存在多个线程时，会存在一些问题： 竞争条件：多个线程尝试访问同一个数据，其顺序无法预期 死锁：多个线程等待对方完成执行，导致这些线程无法继续执行 只会在特定的执行顺序下产生的缺陷，难以稳定地重现和修复 Rust 中，线程无法使用别的线程中的数据，除非在创建线程时，将数据的所有权移交给这个线程（同时原本的线程将失去所有权）。 多个线程间可以通过消息通道来传递数据，或者通过信号量来协同多个线程的执行。 还有其他的方式来允许更加复杂的线程数据访问。 错误处理Rust 语言中的错误被分为了两类：不可恢复错误（panic）与可恢复错误（用 Result 来表示结果）。 其中，不可恢复错误是指程序陷入了非预期的状态，通常出现在以非预期的参数来调用函数时。 而可恢复错误是指程序可以预见的问题，以 Result 来表示可能失败的结果，提示开发者需要处理错误情况。","link":"/2020/11/29/safety-designs-of-rust/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"OOJS","slug":"OOJS","link":"/tags/OOJS/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"Performance","slug":"Performance","link":"/tags/Performance/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Fibonnaci","slug":"Fibonnaci","link":"/tags/Fibonnaci/"},{"name":"Matrix","slug":"Matrix","link":"/tags/Matrix/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"}]}