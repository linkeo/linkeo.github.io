{"pages":[],"posts":[{"title":"JavaScript 的 new 操作符","text":"JavaScript 的 new 操作符都做了些什么？如何用一个函数来模拟 new 呢？ 官方文档官方文档第一段中的说法： new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象（即 {}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤 1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this 。 官方文档在 “描述” 章节中的说法： 当代码 new Foo(...) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 要点根据上面两段描述，可以整理出以下要点： 使用 new 来调用时，构造函数的上下文的 this 是一个新创建的对象，继承自构造函数的原型（prototype） 当构造函数的返回值是一个对象的时候，返回这个对象，否则返回用作 this 的那个对象 根据这两个要点，可以用函数来表示 new 操作符的逻辑。 函数表示12345678function newOperator(Constructor, args) { const thisValue = Object.create(Constructor.prototype); const returnValue = Constructor.apply(thisValue, args); if (typeof returnValue === 'object' &amp;&amp; returnValue !== null) { return returnValue; } return thisValue;} 相关要点创建一个继承自特定对象的新对象最简单粗暴的方式是，创建一个对象，并且将原型指向继承的那个对象： 12const newObject = {};newObject.__proto__ = parentObject; 不过 JavaScript 不推荐直接使用 __proto__（下面会说），并且为我们提供了这样一个函数： 1Object.create(proto, [propertiesObject]); 参数： proto - 作为新创建对象的原型的对象 propertiesObject - 可选参数。如果提供，将作为 Object.defineProperties() 的参数来使用 不推荐直接使用 __proto__来自官方文档的警告： 警告：通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性, 这种行为在每一个 JavaScript 引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 obj.__proto__ = ... 语句上, 它还会影响到所有继承来自该 [[Prototype]] 的对象，如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]。相反, 创建一个新的且可以继承 [[Prototype]] 的对象，推荐使用 Object.create()。 警告：当Object.prototype.__proto__ 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在 ECMAScript 2015 规范中被标准化为传统功能，以确保 Web 浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。 Object.prototype 的 __proto__ 属性是一个访问器属性（一个 getter 函数和一个 setter 函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 null)。 简单来说，官方不推荐直接修改或者访问 __proto__ 属性，修改会有性能问题，如果要创建包含继承关系的对象，推荐用 Object.create()，如果要访问原型，建议只使用 Object.getPrototypeOf()。","link":"/2019/05/22/js-new-operator/"},{"title":"JavaScript 中的相等性判断","text":"JavaScript 中提供了三种不同的值比较操作： 严格相等（”Strict Equality Comparison”, or “Identity”）：=== 宽松相等（”Abstract Equality Comparision”, or “Loose Equality”）：== 同值判断（”SameValue”）：Object.is（ECMAScript 2015 新特性） 而 ECMAScript 2015 中的相等算法则分为四种： 非严格相等比较（==） 严格相等比较（===），用于 Array.prototype.indexOf，Array.prototype.lastIndexOf 以及 switch...case 同值（Object.is） 同值零（”SameValueZero”），用于 %TypedArray% 和 ArrayBuffer 的构造函数，Map 和 Set 操作，以及 ECMAScript 2016 中的 String.prototype.includes 中 简而言之， == 将进行类型转换并比较 === 不会进行类型转换，比较两个值是否相同（如果类型不同，则总是返回 false） Object.is 的行为与 === 相同，但是对于 NaN，-0 和 +0 进行了特殊处理，Object.is(+0, -0) 为 false，而 Object.is(NaN, NaN) 为 true（根据 IEEE 754, 使用 == 或 === 比较两个 NaN 结果将为 false） “SameValueZero” 与 Object.is 类似，但认为 -0 和 +0 是相等的 而以上这些比较，虽然结果有所区别，但均属于判断两个值是否相同。对于两个不同的非原始对象，以上判断的结果都是 false。 严格相等 ===全等操作符（===）比较两个值是否相等，被比较的值不会进行隐式类型转换，判断逻辑如下： 如果两个值具有不同的类型，则不全等 如果两个值具有相同的类型和值，且不为 number 类型，则全等 如果两个值都是 number 类型，且不为 NaN，且数值相等，则全等 如果两个值都是 NaN，则不全等 如果两个值分别为 +0 和 -0，则全等 在日常使用中 === 几乎总是正确的。 对于数字之外的类型，全等操作符有明确的定义：一个值只与自身相等。 对于数字类型，定义稍加修改： 浮点数 0 是不分正负的，因为除了特定的数学问题，大部分情况都不关心 0 值的正负 浮点数包含 NaN 值，来表示定义不明确的数学问题的解（比如：正负无穷相加），=== 认为 NaN 和任何值都不相等，包括它自己 x !== x 成立的唯一条件就是 x 为 NaN，因此可以用来做 NaN 值判断 ECMA 规范中的定义：Section 11.9.6, The Strict Equality Algorithm 非严格相等 ==相等操作符（==）比较两个值是否相等，比较前将被比较的值转换为相同类型（等式的一边或两边都可能进行转换），然后进行 === 比较。相等操作符满足交换律。判断逻辑如下： 具有不同类型时： 如果两个值为 null 或 undefined，则相等 如果一个值为 null 或 undefined，另一个值为 number 或 string 或 boolean，则不相等 如果一个值为 null 或 undefined，另一个值为 object，则对 object 进行 “IsFalsy” 判断 如果一个值为 object，另一个值为 number 或 string，则对 object 进行 “ToPrimitive” 转换并判断是否全等 如果一个值为 object，另一个值为 boolean，则将 boolean 转换为 number 并对 object 进行 “ToPrimitive” 转换并判断是否全等 如果一个值为 number，另一个值为 string 或 boolean，则将另一个值转换为 number 并判断是否全等 如果一个值为 string，另一个值为 boolean，则都转换为 number 来判断 注： “ToPrimitive” 通过尝试调用 toString() 和 valueOf() 来将对象转换为原始值 转换为 number 的逻辑与一元 + 运算符相同 “IsFalsy” 判断：大部分浏览器允许非常窄的一类对象在某种情况下充当 undefined，仅当这种情况下，”IsFalsy” 判断为 true 有些开发者认为，最好永远都不要使用 ==，因为 == 的结果难以预测，且会进行隐式类型转换，=== 更加容易预测并更加快速。 ECMA 规范中的定义：Section 11.9.3, The Abstract Equality Algorithm 同值相等（”SameValue”）同值相等（”SameValue”）用于判断两个对象是否在任何情况下功能上是相同的，判断逻辑如下： 如果两个值具有不同的类型，则不同值相等 如果两个值具有相同的类型和值，且不为 number 类型，则同值相等 如果两个值都是 number 类型，且不为 NaN，且数值相等，则同值相等 如果两个值都是 NaN，则同值相等（与 === 相反） 如果两个值分别为 +0 和 -0，则不同值相等（与 === 相反） 比如 Object.defineProperty 在试图修改不可变属性的时候，如果值发生变化就会抛出异常，而值没有变化的话则什么都不做。这时就是用同值相等来判断值是否发生了变化。 1234567891011Object.defineProperty(Number, 'NEGATIVE_ZERO', { value: -0, writable: false, configurable: false, enumerable: false});function attemptMutation(v) { Object.defineProperty(Number, 'NEGATIVE_ZERO', { value: v });}attemptMutation(-0); // 不发生任何事情attemptMutation(+0); // 将抛出异常 这个算法在 ES5 中仅用于 JS 引擎的内部，ES6 中通过 Object.is 暴露了这个算法。 ECMA 规范中的定义：Section 9.12, The SameValue Algorithm 同值零相等（”SameValueZero”）同值零相等（”SameValueZero”）与同值相等类似，只是它认为 +0 和 -0 是相等的。 什么时候使用 Object.is？总的来说，除了对待 NaN 的方式不同，Object.is 与 === 的唯一区别就是对待 -0 和 +0 的不同。 下面这些方法和操作符会区别对待 -0 和 +0： 一元负号（Unary -） 一元负号在表达式的使用可能会无意识产生 -0，比如：obj.mass * - obj.velocity，如果 obj.mass 为 0，则会得到一个 -0 Math.atan2 Math.ceil Math.pow Math.round 这些函数即使参数中没有 -0，都有可能产生 -0 的结果 Math.floor Math.max Math.min Math.sin Math.sqrt Math.tan 这些函数当参数中有 -0 时，有可能产生 -0 的结果 ~ &lt;&lt; &gt;&gt; 这些操作符内部都使用了 ToInt32 算法。因为内部的 Int32 类型不区分 0 的正负，-0 在进行了这些操作后，不会保留负号。 因此在未考虑到 0 的符号的情况下使用 Object.is 可能得不到预期的效果。","link":"/2019/05/23/js-equality-and-sameness/"},{"title":"重新介绍 JavaScript（一）","text":"为什么会有这一篇 “重新介绍” 呢？因为 JavaScript 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤为必要。 本篇涉及类型、变量、运算符、对象以及数组。 与大多数编程语言不同，JavaScript 没有输入或输出的概念。它是一个在主机环境（host environment）下运行的脚本语言，任何与外界沟通的机制都是由主机环境提供的。浏览器是最常见的主机环境，但在非常多的其他程序中也包含 JavaScript 解释器，如 Adobe Acrobat、Photoshop、SVG 图像、Yahoo! 的 Widget 引擎，以及 Node.js 之类的服务器端环境。JavaScript 的实际应用远不止这些，除此之外还有 NoSQL 数据库（如开源的 Apache CouchDB）、嵌入式计算机，以及包括 GNOME （注：GNU/Linux 上最流行的 GUI 之一）在内的桌面环境等等。 —- JavaScript Reference 概览JavaScript 是一种面向对象的动态语言，包含了类型、运算符、内置对象和方法。语法源于 Java 和 C 语言。和 Java 的主要区别在于 JavaScript 不支持类，类的概念在 JavaScript 中通过对象原型与继承的方式来实现。JavaScript 支持函数式编程，因为 JavaScript 中函数也是一种对象，可以保存在变量中并当作参数传递。 类型JavaScript 的类型包括： Number（数字） String（字符串） Boolean（布尔值） Symbol（符号，ES6 新增的类型） Object（对象） Function（函数） Array（数组） Date（日期） RegExp（正则表达式） null（空值） undefined（未定义） 数字JavaScript 采用 IEEE 754 双精度 64 位数字表示法，并且不区分整数和浮点数类型，所有数字均为浮点数值（但是在具体实现时，整数通常被视为 32 位整型变量），所以在进行计算时需要特别注意，比如： 10.1 + 0.2 = 0.30000000000000004 JavaScript 的算数运算符包括加（+）、减（-）、乘（*）、除（/）、取余（%）以及乘方（**，ES7 新增的操作符）。 JavaScript 内置的 Math 对象用于处理更多的数学函数和常数。 可以使用内置函数 parseInt() 将字符串转换为整型。该函数的第二个参数表示字符串所表示数字的基（进制）： 12parseInt('123', 10); // 123parseInt('010', 10); // 10 如果调用时没有提供第二个参数（字符串所表示数字的基），则会根据字符串来确定进制，但是 2013 年以前的 JavaScript 实现会返回一个意外的结果： 12parseInt('010'); // 8parseInt('0x10'); // 16 因为旧版本的 JavaScript 会认为 '0' 开头的数字字符串是八进制，而新版本只会认为 '0o'开头的数字字符串是八进制。 还有其它方法可以将字符串转换成数字：一元加号 +、以及 Number 函数，它们两个的效果是一样的。 parseInt 和 parseFloat 方法会尝试逐个解析字符串中的字符，直到遇上一个无法被解析成数字的字符，然后返回该字符前所有数字字符组成的数字。而一元加号 + 和 Number 函数则是如果字符串中包含无法解析成数字的字符，结果都将会是 NaN。 字符串JavaScript 中的字符串是一串 Unicode 字符的序列。更准确地说，是 UTF-16 编码单元的序列，而每个 Unicode 字符由 1 或 2 个编码单元来表示。 字符串的方法无法区分 Unicode 字符，只能按照 UTF-16 编码单元来拆分字符串： 12const t = '😄😂';t.split('') === ['�', '�', '�', '�']; 而把字符串当作迭代器来使用的话，就可以根据 Unicode 字符来迭代字符串了： 12const t = '😄😂';[...t] === ['😄', '😂']; 其它类型JavaScript 中的 null 和 undefined 是不同的，前者代表空值（non-value），必须使用 null 关键字访问，后者是 “未定义” 类型的对象，表示未初始化的值，也就是尚未分配的值。 所有值都可以转换为布尔值，可能在判断中隐式转换或者使用 Boolean 函数显式转换，布尔值的转换规则为： false、0、空字符串 ''、NaN、null 和 undefined 被转换为 false 其它值都被转换为 true 变量在 JavaScript 中，可以通过 let、const 或 var 关键字来声明新变量。 let 语句可以声明一个块级作用域的变量，并可以使用一个值来初始化该变量。 12345let a;{ let name = 'Simon';}a = name; // 抛出异常，因为这里不可访问 name 变量 const 语句用于定义一个不可变的常量（对于对象类型的值，对象的成员仍然可能是可修改的）。const 语句必须指定一个值来初始化变量。 var 是最常见的声明变量的关键字。它没有其他两个关键字的种种限制。这是因为它是传统上在 JavaScript 声明变量的唯一方法。使用 var 声明的变量在它所声明的整个函数都是可见的。 JavaScript 与其他语言的（如 Java）的重要区别是在 JavaScript 中语句块（blocks）是没有作用域的，只有函数有作用域。因此如果在一个复合语句中（如 if 控制结构中）使用 var 声明一个变量，那么它的作用域是整个函数（复合语句在函数中）。 但是从 ES6 开始将有所不同的， let 和 const 关键字允许你创建块作用域的变量。 运算符二元加号 + 可以用来连接字符串，如果你用一个字符串加上一个数字（或其他值），那么操作数都会被首先转换为字符串。通过与空字符串相加，可以将某个变量快速转换成字符串类型。 对象JavaScript 的对象可以简单理解成键值对，与其它语言的一些概念类似： Python 中的字典 Perl 和 Ruby 的 Hash C/C++ 中的哈希表 Java 中的 HashMap PHP 中的关联数组 JavaScript 中，几乎一切都是对象，所以 JavaScript 程序必然与大量的散列表查找操作有着千丝万缕的联系，而散列表擅长的正是高速查找。 数组JavaScript 中的数组是一种特殊的对象。它的工作原理与普通对象类似（以数字为属性名，但只能通过 [] 来访问），但数组还有一个特殊的属性 —— length（长度）属性。这个属性的值通常比数组最大索引大 1。 注意，Array.length 并不总是等于数组中元素的个数，如下所示： 123var a = ['dog', 'cat', 'hen'];a[100] = 'fox';a.length; // 101 记住：数组的长度是比数组最大索引值多一的数。 数组的 push、pop、shift、unshift 方法可以数组头尾添加或删除元素（取出元素）。 数组的 splice(index, deleteCount, ...insertItems) 方法可以在数组指定位置删除或添加多个元素。 数组的 sort([cmpfn]) 方法可以依据 cmpfn 返回的结果进行排序，如果未指定比较函数则按字符顺序比较（即使元素是数字）。","link":"/2019/05/24/js-re-introduction-1/"},{"title":"JavaScript 中的闭包（Closures）","text":"什么是闭包？哪里用得到闭包？ 闭包是函数和声明该函数的词法环境的组合。 什么是闭包？ 闭包是函数和声明该函数的词法环境的组合。 —- JavaScript Reference 词法作用域考虑如下情况： 123456789function init() { var name = 'Mozilla'; // name 是 init 函数的局部变量 // displayName() 是一个内部函数，是一个闭包 function displayName() { console.log(name); // 使用了外部函数中的变量 } displayName();}init(); 这个例子说明词法作用域的范围，函数的词法作用域包括了函数自身的作用域以及定义该函数的位置的作用域。也就是说，函数可以访问在其上层作用域中定义的变量。 作用域对象每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。这与那些保存的所有全局变量和函数的全局对象（global object）类似，但仍有一些很重要的区别，第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；第二，与全局对象（在浏览器里面是当做 window 对象来访问的）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有可以遍历当前的作用域对象里面属性的方法。 一个闭包就是一个函数和其外层函数的作用域对象的组合。 闭包再看一下这个例子： 123456789function makeFunc() { var name = 'Mozilla'; function displayName() { console.log(name); } return displayName;}var myFunc = makeFunc();myFunc(); 在这个例子中，内部函数并没有直接执行，而是被外部函数返回。这个例子在 JavaScript 中是可行的。但是在一些其它的编程语言中，函数中的局部变量仅函数的其执行期可用，一旦函数执行完毕，函数中的局部变量将被销毁。但其实变量销毁的逻辑其实是一样的，都为了节省内存，在变量不可再被访问时，进行销毁。（比如这些语言的局部变量一定是在函数执行完毕就无法再被访问了，又比如一些语言的引用计数方式的 GC） 由于 JavaScript 中的函数会形成闭包，闭包可以访问其外层作用域，所以只要这些函数还能被访问到，外层作用域的变量就不会被销毁。由于我们还持有 myFunc（等同于 displayName，一个可以访问 name 变量的闭包），所以 name 变量不会被销毁。 下面是一个更有意思的例子： 1234567891011function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 在这个例子中，add5 和 add10 共享函数定义，但是各自有不同的词法环境。add5 的环境中，x 为 5，而 add10 中，x 为 10。 闭包的用处闭包是一个很有用的特性，因为他可以将函数和其定义的环境联系起来。这个面向对象编程中，对象允许将其方法和其属性与其它方法联系起来有些相像。 函数工厂在上面那个例子中，我们可以看到闭包的一种用法：函数工厂。根据不同参数，创建行为具有相同规则但是又不相同的函数，例如创建可以修改字体大小的函数，并且绑定到不同事件上面去： 123456789function fontSizeSetter(size) { return function() { document.body.style.fontSize = size + 'px'; };}document.getElementById('font-size-12').onClick = fontSizeSetter(12);document.getElementById('font-size-14').onClick = fontSizeSetter(14);document.getElementById('font-size-16').onClick = fontSizeSetter(16); 模拟私有变量与方法JavaScript 不像 Java 等一些其它语言，JavaScript 无法定义私有的变量或方法（即只能被同一个类访问的变量或方法）。 但是通过闭包，我们可以模拟相同的效果。例如： 123456789101112131415161718192021222324var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } };})();console.log(Counter.value()); // 0Counter.increment();Counter.increment();console.log(Counter.value()); // 2Counter.decrement();console.log(Counter.value()); // 1 这个例子中，Counter 对象有三个方法：increment、decrement 和 value，并且除了这三个方法，没有地方再可以访问 privateCounter 与 changeBy。 像这种通过闭包来定义公共函数，并使其可以访问私有变量和函数的方式，通常被称为模块模式（Module Pattern）。 再举一个更加面向对象一些的例子： 123456789101112131415161718192021222324function Counter(initValue) { var privateCounter = initValue || 0; return { increment() { privateCounter += 1; return this; }, decrement() { privateCounter -= 1; return this; }, get value() { return privateCounter; } };}const counter1 = new Counter();counter1.increment().increment().value; // 2counter1.decrement().value; // 1const counter2 = new Counter(counter1.value);counter2.increment().value; // 2counter2.increment().decrement().value; // 2 运用 class 语法的版本： 123456789101112131415161718class Counter { constructor(initValue = 0) { let privateCounter = initValue; function makeChainableChanger(value) { return function() { privateCounter += value; return this; }; } return { increment: makeChainableChanger(1), decrement: makeChainableChanger(-1), get value() { return privateCounter; } }; }} 闭包的常见错误在 ECMAScript 2015 引入 let 关键字之前，在循环中有一个常见的闭包创建问题。 示例如下： 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 这个例子中，每个循环创建了一个闭包，由于在循环中被创建，这 3 个闭包共享了相同的词法环境（循环的词法环境），在这些闭包被调用时，循环早已结束，词法环境中的 item 已经指向了 helpText 的最后一项。 解决这个问题有很多种办法，比如可以通过引入更多闭包解决： 123456789101112131415161718192021222324function showHelp(help) { document.getElementById('help').innerHTML = help;}function showHelpCallback(item) { return function() { showHelp(item.help); };}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = showHelpCallback(item); }}setupHelp(); 或者使用匿名闭包： 12345678910111213141516171819202122function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { (function() { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; })(); }}setupHelp(); 而更好的方法是，使用 let 关键词将变量声明到块作用域（循环的块作用域是每一次循环独立的）而不是整个循环上。（所以在很多项目的规范中，要求永远不要使用 var 关键词） 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { const helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (let i = 0; i &lt; helpText.length; i++) { let item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 性能考量 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。 —- JavaScript Reference 考虑以下示例： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; };} 在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();}MyObject.prototype.getName = function() { return this.name;};MyObject.prototype.getMessage = function() { return this.message;};","link":"/2019/05/23/js-closures/"},{"title":"Node.js 中的事件循环","text":"Node.js 中有一些用于稍后执行的函数，比如 setTimeout(fn, ms)，setImmediate(fn) 以及 process.nextTick(fn)。如何区分它们，将与 Node.js 的事件循环机制息息相关。 本文主要参考另一篇文章进行转述。 一些常见的误解 事件循环是 JS 引擎来处理的 最常见的误解就是，事件循环是 JavaScript 引擎（V8、SpiderMonkey 等）的一部分。实际上，事件循环只用到 JS 引擎来执行 JavaScript 代码。Node.js 的事件循环是由 libuv 来完成的。 有一个栈或者队列来管理回调函数 首先排除用栈，其次也不是一个单一的队列。这个过程是复杂的，有多个队列（比如数据结构中的队列）参与。 事件循环运行在一个单独的线程里面 因为一些错误的 Node.js 事件循环图，很多人认为有两个线程，一个执行 JavaScript 代码，另一个执行事件循环。事实上，这两个是在同一个线程执行的。 在 setTimeout 中有系统的参与 另一个非常大的误解是 setTimeout 的回调函数在给定的延迟完成之后被（可能是 OS 或者内核）推进一个队列。 setImmediate 将回调函数放在第一个位置 作为常见的事件循环描述只有一个队列，所以一些开发者认为 setImmediate 将回调放在工作队列的前面。然而这是不正确的。 事件循环的结构下图描述的是 Node.js 中的事件循环过程： 事件循环分为 6 个阶段，每个阶段负责特定的任务。每个阶段都有独立的队列（或其它用作队列的数据结构），JavaScript 代码可以在空闲/准备阶段之外的 5 个阶段执行。图中的 nextTick 队列与微任务队列不属于事件循环的一部分，而是在任何阶段都可以执行，它们有比事件循环更高的优先级。 计时器阶段（Timer） 计时器阶段是一个循环的开始，这个阶段处理计时器（setTimeout、setInterval）的回调。 计时器队列是一个最小堆，它用于保留计时器和其回调。计时器阶段会检查计时器队列中过期的计时器，并执行它们的回调。 I/O 回调阶段（Pending I/O Callbacks） 这个阶段执行 Pending Queue 中的回调。这些回调是在之前的操作中加入到队列的（一般是 I/O 操作完成时加入的）错误处理的回调也将在这里执行。 空闲/等待阶段（Idle, Prepare） 这个阶段主要执行 Node.js 的一些内部操作，暂时不讨论其内容。 轮询阶段（Poll） 这个阶段接受新传入的连接（建立 Socket 等等）和数据（读取文件等待）。这个阶段大致可以分成两个部分： 如果 Watch Queue 里面有任务，它们将依次被执行。 一旦队列空了，Node.js 就会等待新的连接或数据。等待的时间取决于多种因素（待会再看） 检查阶段（Check） 轮询阶段专门用于处理 setImmediate 设置的回调。 关闭回调（Close） 关闭回调都是在这里处理的，像一个清理的阶段。 nextTick 队列与微任务队列 nextTick 队列中保存 process.nextTick() 设置的回调。而微任务队列保存 Promise 中的回调。它们不属于事件循环（libuv）的一部分，而是 Node.js 的一部分。在 C/C++与 JavaScript 交叉的过程中，它们都是尽可能快地被调用（不一定是当前的回调完成时）。 事件循环的流程当你用 Node.js 执行一段 JavaScript 脚本时，Node.js 首先进行执行脚本前的准备（比如准备全局环境、初始化事件循环等），然后解析并执行代码（所有同步代码以及微任务将在这时候被执行），执行完代码，将检查循环是否还有事情要做（Alive），如果没有，将进入进程结束流程，否则将进入事件循环。 计时器阶段根据前面的描述，计时器阶段将检查过期的计时器并执行回调。 具体来说，计时器队列（最小堆）以时间升序来保存计时器。每次都检查堆顶的计时器是否过期，如果过期就取出队列并执行回调，否则直接进入下一个阶段（因为后面的计时器都一定没有过期）。 当然，事件循环的每个阶段执行的任务数量是有最大限制的，达到这个数量后，即使有过期的计时器也不会执行，直接进入下一阶段。 I/O 回调阶段I/O 回调阶段检查 Pending Queue 中是否有任务，如果有，依次执行，直到队列为空或者达到系统限制。 之后将进入空闲阶段（Idle），然后 Node.js 将做一些内部准备，并进入轮询阶段。 轮询阶段这个阶段首先检查 Watcher Queue 中是否有任务（比如文件读响应，Socket 连接请求、HTTP 连接请求等），如果有，将依次执行，直到队列为空或者达到系统限制。 如果没有要执行的回调，轮询阶段在某些条件下将等待一会儿。 如果关闭阶段、空闲阶段、I/O 回调阶段或者关闭阶段任意一个队列有任务在等待，则轮询阶段将等待 0ms，并进入检查阶段。 否则它将检查计时器队列的堆顶，并决定等待时间（如果已过期，则等待 0ms） 检查阶段这个阶段将执行被 setImmediate 设置的回调，直到队列为空或者达到系统限制。 关闭阶段这个阶段将执行处理关闭或者销毁的 close 回调。这个阶段完成后，将再次检查循环是否活着（还有任务要做）。如果没有，将退出事件循环，进入进程结束阶段；如果有，将再次进入计时器阶段。 nextTick 队列与微任务队列这两个队列会在一个阶段结束时尽可能快的运行。不像其他阶段，它们两个没有系统设置的最大限制，node 运行它们直到两个队列是空的。但是，nextTick 队列会比微任务队列有更高的任务优先级。 根据另一篇文章的解释，这两个队列会在每个阶段结束前按顺序执行，直到它们为空。 进程池（Thread Pool）一个普遍的误解是 Node.js 有一个处理所有异步操作的进程池。 实际上，进程池是 libuv 的一部分，但不属于事件循环机制的一部分。而且并不是每个任务都要被进程池处理。libuv 能够灵活运用操作系统的异步 API 来保持环境为事件驱动的。而操作系统的异步 API 无法处理的任务（比如：DNS 查询、文件读取等），将由进程池来处理。进程池默认有 4 个进程，可以通过环境变量 uv_threadpool_size 来设置它的进程数量（最多可设置 128 个）。 帮助理解的例子基础理解下面代码的打印顺序如何？ 123456setTimeout(() =&gt; { console.log('setTimeout');}, 0);setImmediate(() =&gt; { console.log('setImmediate');}); 你可能会认为是 ‘setTimeout’ 先被打印出来，或者 ‘setImmediate’ 先被打印出来。但是，这个例子的打印顺序是不确定的。因为在计时器阶段，可能不会检查到计时器过期。 首先，根据 Node.js 的文档，setTimeout 的延时小于 1ms 或者大于 2147483647ms 时，将重置为 1ms。进入计时器阶段时，会记录一个时间，然后根据执行代码时的系统性能表现，检查计时器时，可能已经经过了 1ms，也可能没有经过。所以在第一次循环 ‘setTimeout’ 不一定会被打印，而 ‘setImmediate’ 一定会被打印。 但是，如果这段代码位于 I/O 回调中的话，’setImmediate’ 一定会在 ‘setTimeout’ 之前被打印。 更好地理解计时器123456789101112let i = 0;const start = new Date();function foo() { i++; if (i &lt; 1000) { setImmediate(foo); } else { const end = new Date(); console.log('Execution time: ', end - start); }}foo(); 上面的例子是连续使用 setImmediate 设置回调，直到 i == 1000。在我的 Macbook Pro 上面用 Node.js 10.14.1 执行，大约需要 80ms。 把其中的 setImmediate 修改为 setTimeout： 123456789101112let i = 0;const start = new Date();function foo() { i++; if (i &lt; 1000) { setTimeout(foo, 0); } else { const end = new Date(); console.log('Execution time: ', end - start); }}foo(); 在同样的环境下执行修改后的代码，将需要约 1400ms 毫秒。 它们的差距在于，首先 setTimeout 至少会产生 1ms 的延时，其次 setTimeout 需要花一些时间来注册计时器，而计时器阶段的过期检查也需要一些开销。而再 setImmediate 的阶段，再回调中注册 setImmediate 将导致队列仍不为空，所以也不会跳出这一阶段（直到系统限制），将进行更少的循环，也节省了一些时间。 nextTick() 与计时器12345678910111213let i = 0;function foo() { i++; if (i &gt; 20) { return; } console.log('foo'); setTimeout(() =&gt; { console.log('setTimeout'); }, 0); process.nextTick(foo);}setTimeout(foo, 2); 上面的例子将输出 20 次 ‘foo’，再输出 20 次 ‘setTimeout’。2 秒后，连续进行nextTick() 调用，然后检查别的任务（setTimeout）。 所以是每个回调执行完之后，开始检查 nextTick 队列的吗？再看看下面的例子。 12345678910111213141516let i = 0;function foo() { i++; if (i &gt; 20) { return; } console.log('foo', i); setTimeout(() =&gt; { console.log('setTimeout', i); }, 0); process.nextTick(foo);}setTimeout(foo, 2);setTimeout(() =&gt; { console.log('Other setTimeout');}, 2); 这个例子很可能会在第一个 ‘foo’ 打印之后打印 ‘other setTimeout’。 相同的计时器分成一组，nextTick 队列会在这组回调执行完之后执行。 一些普遍的问题 JavaScript 代码是在哪里执行的？ 大多数人会认为事件循环有一个独立的线程执行，将回调推入一个队列，然后负责执行 JavaScript 的线程来依次执行。然而，事件循环和 JavaScript 的执行是同一个线程里的。所以，如果 JavaScript 代码不完成的话，事件循环不会向后走。 为什么有了 setTimeout(fn, 0) 还需要 setImmediate(fn)？ 因为 setTimeout(fn, 0) 的 0 不是 0ms，而是 1ms（因为至少要 1ms）。其次，setImmediate 可以减少额外的检查。而且 setImmediate 设置的回调将于轮询阶段的下一个阶段执行，因此用于 I/O 回调中，可以尽早执行。 为什么 setImmediate 与 process.nextTick 的意思相反？ 因为历史原因导致的命名问题。 如果在进程结束回调中使用 setTimeout 会如何？ 它也许会创建计时器，但是回调将不会被调用。因为这时已经结束了事件循环。","link":"/2019/05/27/node-event-loop/"},{"title":"自己实现一个 Promise 类","text":"自从 ES6 引入的 Promise 将我们从回调地狱中解放了出来，ES7 提出的 async/await 特性更是进一步地简化了异步代码的编写。 那么我们就通过自己实现一个 Promise 类，来一窥其内部的奥秘（本文将遵照 Promise/A+ 规范实现 Promise，并且添加一些常用的函数） 本文将新的 Promise 类命名为 Future（参考 Dart 中与 Promise 对应的概念的名称） 本文为了模拟 Promise 的微任务，使用 Node.js 的 process.nextTick 函数来产生微任务。并且本文将使用 ES2015+ 语法来实现。 基本实现首先我们不考虑结果为 Promise 或者 thenable 的情况。 构造器首先我们知道，Promise 的构造器需要传入一个函数（我们称为 executor），这个函数有 resolve、reject 两个参数，分别用于将 Promise 的状态设为成功（fulfilled）或者失败（rejected），并且如果这个函数抛出错误，Promise 也将失败。而 Promise 一开始就具有待定（pending）状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 属性常量 */const state = Symbol();const result = Symbol();/* 状态常量 */const PENDING = Symbol();const REJECTED = Symbol();const FULFILLED = Symbol();/* 工具函数 */// 设置不可枚举属性const defineProperty = (obj, key, value) =&gt; Object.defineProperty(obj, key, { value, writable: true, configurable: false, enumerable: false });class Future { constructor(executor) { // 参数检查 if (typeof executor !== 'function') { throw new Error('Future executor undefined is not a function'); } // 设置状态、结果属性 defineProperty(this, state, PENDING); defineProperty(this, result, undefined); // 成功处理函数 const resolveFunction = value =&gt; { if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; } }; // 失败处理函数 const rejectFunction = reason =&gt; { if (this[state] === PENDING) { this[state] = REJECTED; this[result] = reason; } }; try { executor(resolveFunction, rejectFunction); } catch (err) { rejectFunction(err); } }} 这里简化了 “私有” 属性的声明，使用私有 Symbol 作为不可枚举属性的名称，可以防止外部模块访问（实际上，使用 Object.getOwnPropertySymbols 仍然可以得到这些 Symbol，但是需要额外的判断来确定 Symbol 的作用）。 then 方法我们知道，Promise 的 then 方法可以传入两个参数作为回调，分别处理成功和失败的情况，而这两个参数分别只有在类型为函数的情况下，才认为有效，其余情况会忽略。then 函数会返回一个新的 Promise，用于处理 then 的回调产生的结果（或者没有设置对应回调的情况下，处理原 Promise 的结果）。 为了使原 Promise 可以处理 then 的回调，我们定义两个队列用于存放回调。 1234567/* 属性常量 */const onFulfilledCallbacks = Symbol();const onRejectedCallbacks = Symbol();// @{Future.constructor} 在 Promise 的构造器中设置回调队列defineProperty(this, onFulfilledCallbacks, []);defineProperty(this, onRejectedCallbacks, []); 在对应的处理函数中，调用这些回调： 12345678910111213// 成功的时候，调用所有成功回调队列中的函数this[state] = FULFILLED;this[result] = value;this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result]));});// 失败的时候，调用所有失败回调队列中的函数this[state] = REJECTED;this[result] = reason;this[onRejectedCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result]));}); 做好这些准备，我们就可以开始实现 then 函数了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Future { // constructor(executor) { ... } then(onFulfilled, onRejected) { const newFuture = new Future((resolve, reject) =&gt; { // 设置原 Promise 成功处理函数 const onPrevFulfilled = value =&gt; { if (typeof onFulfilled !== 'function') { // 如果没有设置成功回调，则直接使用原 Promise 的成功结果 resolve(value); } else { // 如果设置了成功回调，则用成功的结果为参数调用回调 try { // 并以回调的结果为本次成功结果 resolve(onFulfilled(value)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; // 设置原 Promise 失败处理函数 const onPrevRejected = reason =&gt; { // 如果没有设置失败回调，则直接使用原 Promise 的失败结果 if (typeof onRejected !== 'function') { reject(reason); } else { // 如果设置了失败回调，则用失败的结果为参数调用回调 try { // 并以回调的结果为本次**成功**结果 resolve(onRejected(reason)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; if (this[state] === FULFILLED) { // 如果原 Promise 已经成功，直接调用成功处理函数 process.nextTick(() =&gt; { onPrevFulfilled(this[result]); }); } else if (this[state] === REJECTED) { // 如果原 Promise 已经失败，直接调用失败处理函数 process.nextTick(() =&gt; { onPrevRejected(this[result]); }); } else { // 如果原 Promise 仍然待定，则将处理函数加到原 Promise 的回调队列中 this[onFulfilledCallbacks].push(onPrevFulfilled); this[onRejectedCallbacks].push(onPrevRejected); } }); // 返回新创建的 Promise return newFuture; }} 这里 process.nextTick 用于模拟 then 回调的微任务执行优先级。 处理 thenable刚才的基本实现应该可以处理普通的结果了，现在我们要考虑将 Promise 或者 thenable 作为结果的情况。 thenable 其实就是定义了 then 方法的对象（或函数），对 thenable 的支持可以使得不同的 Promise 实现之间相互兼容。 只要对象可以成功提供 then 函数，我们就认为它是合法的 thenable，就可以把 then 当作 Promise 的 then 方法来使用。 根据以上描述，Promise 对象本身就是一个 thenable，那么其实我们只需要判断 thenable 即可。 支持 thenable 结果如果当前 Promise 的结果是 thenable，我们就等到它们的状态变为成功或失败，并将它们的结果设为当前 Promise 的结果。 根据 Promise/A+ 规范，executor 的 reject 回调用于设置失败原因，不需要处理 thenable 的情况。我们只需要修改成功处理函数（resolveFunction）来等待 thenable 的结果： 1234567891011121314151617181920212223242526272829// 成功处理函数const resolveFunction = value =&gt; { // 处理 thenable 的情况 // 首先判断是一个对象或函数 if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; // 取得 then 函数，并且将当前 Promise 的处理函数设置为回调 if (typeof then === 'function') { then.call(value, resolveFunction, rejectFunction); return; } } catch (err) { // 如果无法成功获得 then 函数，设置当前 Promise 为错误状态 rejectFunction(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 正确处理结果回调我们知道，resolveFunction 和 rejectFunction 只有最初调用的那个可以生效，我们一开始使用一个简单的有限状态机来控制状态转移。 但是由于加入了 thenable 的处理，状态设置的顺序和调用处理函数的顺序将可能会不同，我们将无法保证只有第一次调用能够生效。如果我们先 resolve 一个 thenable，再 resolve 一个普通结果，如上的处理方式会采用后面的普通结果；同理，如果先 resolve 一个 thenable，再抛出异常，我们会得到失败的结果。所以，我们需要另外的机制来保证只有第一次调用的处理函数才能生效。 首先，我们采用一个工具函数来包装这对处理函数，使得它们总共只能被调用一次。 12345678const once = (resolve, reject) =&gt; { let called = false; const callable = () =&gt; (called ? false : ((called = true), true)); return { resolve: value =&gt; (callable() ? resolve(value) : undefined), reject: reason =&gt; (callable() ? reject(reason) : undefined) };}; 我们修改构造器的最后一段，将处理过的函数丢给 executor： 123456const { resolve, reject } = once(resolveFunction, rejectFunction);try { executor(resolve, reject);} catch (err) { reject(err);} 这样就可以保证 executor 只能调用一次处理函数，之后再调用或者抛出异常都不再理会。 正确处理 thenable 嵌套但是 thenable 也可能会提供一个 thenable 作为结果，这时候对新的 thenable 的处理，我们是放在 resolveFunction 中的，回顾一下刚刚的代码： 12345678910111213141516171819202122232425// 成功处理函数const resolveFunction = value =&gt; { if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { then.call(value, resolveFunction, rejectFunction); return; } } catch (err) { rejectFunction(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 这里同样会产生上述回调处理顺序问题，所以我们需要保证 resolveFunction 中产生的回调，也只能执行一次。 1234567891011121314151617181920212223242526272829// 成功处理函数const resolveFunction = value =&gt; { // 使用带执行检查的函数作为回调 const callback = once(resolveFunction, rejectFunction); if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { // 修改这里的回调 then.call(value, callback.resolve, callback.reject); return; } } catch (err) { // 修改这里的错误处理函数 callback.reject(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 测试我们先安装 Promise/A+ 测试库： 1npm i -g promises-aplus-tests 然后加入以下代码，提供测试库需要的接口： 12345678910111213141516exports.resolved = value =&gt; new Future((resolve, reject) =&gt; { resolve(value); });exports.rejected = reason =&gt; new Future((resolve, reject) =&gt; { reject(reason); });exports.deferred = () =&gt; { const response = {}; response.promise = new Future((resolve, reject) =&gt; { response.resolve = resolve; response.reject = reject; }); return response;}; 接着执行测试（--bail 参数用于控制测试在第一次失败时终止）： 1promises-aplus-tests custom_promise.js --bail 我们发现，我们的实现不符合规范的第 2.3.1 条： 2.3.1: If promise and x refer to the same object, reject promise with a `TypeError’ as the reason. via return from a fulfilled promise 这一条是说，Promise 不能以他自己为结果，否则得抛出 TypeError，测试的情况为： 12345const promise = new Promise((resolve, reject) =&gt; { process.nextTick(() =&gt; { resolve(promise); });}); 这种情况下，Promise 会等待自己完成时才能完成，这是一个死锁。 我们在 resolveFunction 的开头增加一段检查，来完成这一条规范： 12345678const resolveFunction = value =&gt; { const callback = once(resolveFunction, rejectFunction); if (value === this) { callback.reject(new TypeError('Promise cannot resolve itself.')); return; } // ...}; 再次执行测试，我们会发现全部的测试都可以通过了。 最终通过测试的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* 属性常量 */const state = Symbol();const result = Symbol();const onFulfilledCallbacks = Symbol();const onRejectedCallbacks = Symbol();/* 状态常量 */const PENDING = Symbol();const REJECTED = Symbol();const FULFILLED = Symbol();/* 工具函数 */// 设置不可枚举属性const defineProperty = (obj, key, value) =&gt; Object.defineProperty(obj, key, { value, writable: true, configurable: false, enumerable: false });const once = (resolve, reject) =&gt; { let called = false; const callable = () =&gt; (called ? false : ((called = true), true)); return { resolve: value =&gt; (callable() ? resolve(value) : undefined), reject: reason =&gt; (callable() ? reject(reason) : undefined) };};class Future { constructor(executor) { // 参数检查 if (typeof executor !== 'function') { throw new Error('Future executor undefined is not a function'); } // 设置状态、结果属性 defineProperty(this, state, PENDING); defineProperty(this, result, undefined); // 设置回调队列 defineProperty(this, onFulfilledCallbacks, []); defineProperty(this, onRejectedCallbacks, []); // 成功处理函数 const resolveFunction = value =&gt; { try { // 使用带执行检查的函数作为回调 const callback = once(resolveFunction, rejectFunction); // 检查是否结果为自己本身 if (value === this) { callback.reject(new TypeError('Promise cannot resolve itself.')); return; } if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { then.call(value, callback.resolve, callback.reject); return; } } catch (err) { callback.reject(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); } } catch (err) { console.error(err.stack); } }; // 失败处理函数 const rejectFunction = reason =&gt; { try { if (this[state] === PENDING) { this[state] = REJECTED; this[result] = reason; this[onRejectedCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); } } catch (err) { console.error(err.stack); } }; const { resolve, reject } = once(resolveFunction, rejectFunction); try { executor(resolve, reject); } catch (err) { reject(err); } } then(onFulfilled, onRejected) { const newFuture = new Future((resolve, reject) =&gt; { // 设置原 Promise 成功处理函数 const onPrevFulfilled = value =&gt; { if (typeof onFulfilled !== 'function') { // 如果没有设置成功回调，则直接使用原 Promise 的成功结果 resolve(value); } else { // 如果设置了成功回调，则用成功的结果为参数调用回调 try { // 并以回调的结果为本次成功结果 resolve(onFulfilled(value)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; // 设置原 Promise 失败处理函数 const onPrevRejected = reason =&gt; { // 如果没有设置失败回调，则直接使用原 Promise 的失败结果 if (typeof onRejected !== 'function') { reject(reason); } else { // 如果设置了失败回调，则用失败的结果为参数调用回调 try { // 并以回调的结果为本次**成功**结果 resolve(onRejected(reason)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; if (this[state] === FULFILLED) { // 如果原 Promise 已经成功，直接调用成功处理函数 process.nextTick(() =&gt; { onPrevFulfilled(this[result]); }); } else if (this[state] === REJECTED) { // 如果原 Promise 已经失败，直接调用失败处理函数 process.nextTick(() =&gt; { onPrevRejected(this[result]); }); } else { // 如果原 Promise 仍然待定，则将处理函数加到原 Promise 的回调队列中 this[onFulfilledCallbacks].push(onPrevFulfilled); this[onRejectedCallbacks].push(onPrevRejected); } }); // 返回新创建的 Promise return newFuture; }} 添加常用的函数Promise.prototype.catch 和 Promise.prototype.finallycatch 方法类似于 then 方法，只是它只接受一个错误回调。我们可以通过使用 then 函数来达到它的效果。 123456class Future { // then(onFulfilled, onRejected) { ... } catch(onRejected) { return this.then(undefined, onRejected); }} finally 方法可以指定一个没有参数的回调，用于在 Promise 的状态发生变化时触发，finally 方法返回一个新的 Promise。 只有在回调抛出异常的情况下，新 Promise 会以这个异常为原因失败，否则新的 Promise 的结果将和原 Promise 一致。 同样，我们可以通过使用 then 函数来达到它的效果。 12345678910111213class Future { // then(onFulfilled, onRejected) { ... } finally(onFinally) { const callback = typeof onFinally === 'function' ? () =&gt; onFinally() : undefined; return this.then(callback, callback).then(() =&gt; { if (this[state] === REJECTED) { throw this[result]; } return this[result]; }); }} Promise.resolve 和 Promise.rejectPromise 的类方法 resolve 和 reject 用于构造一个确定结果的 Promise。 12345678class Future { static resolve(value) { return new Future((resolve, reject) =&gt; resolve(value)); } static reject(reason) { return new Future((resolve, reject) =&gt; reject(reason)); }} Promise.all 和 Promise.racePromise 的类方法 all 和 race 用于多个 Promise 的控制。 all 方法的参数为一个可迭代对象（Iterable，比如数组），返回一个 Promise。Promise 成功的结果将是一个新的数组。如果传入的数组里有 thenable，则将结果放到结果的对应位置，否则放数组元素本身。任意一个 thenable 的失败，都将导致整个结果失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Future { static all(iterable) { let pending = 0; return new Future((resolve, reject) =&gt; { const iterator = iterable &amp;&amp; iterable[Symbol.iterator]; if (!iterator || typeof iterator.next !== 'function') { throw new TypeError('argument must be iterable.'); } const values = []; for ( let item = iterator.next(), index = 0; !(item &amp;&amp; item.done); item = iterator.next(), index += 1 ) { if (item == null || typeof item !== 'object') { throw new TypeError('iterator.next() returned a non-object value'); } if ( (item.value !== null &amp;&amp; typeof item.value === 'object') || typeof item.value === 'function' ) { const then = item.value.then; if (typeof then === 'function') { pending += 1; const callback = value =&gt; { values[i] = value; pending -= 1; if (pending === 0) { resolve(values); } }; then.call(item.value, callback, reject); } else { values[i] = item.value; } } else { values[i] = item.value; } } if (pending === 0) { resolve(values); } }); }} race 方法的参数也为一个可迭代对象（Iterable，比如数组），返回一个 Promise。Promise 的结果将是数组元素中最快确定的结果（如果数组元素是 thenable，则需要等待它的结果，否则立即取出结果）。任意一个 thenable 的失败，都将导致整个结果失败。 123456789101112131415161718192021222324252627282930313233343536class Future { static race(iterable) { return new Promise((resolve, reject) =&gt; { const iterator = iterable &amp;&amp; iterable[Symbol.iterator]; if (!iterator || typeof iterator.next !== 'function') { throw new TypeError('argument must be iterable.'); } for ( let item = iterator.next(), index = 0; !(item &amp;&amp; item.done); item = iterator.next(), index += 1 ) { if (item == null || typeof item !== 'object') { throw new TypeError('iterator.next() returned a non-object value'); } if ( (item.value !== null &amp;&amp; typeof item.value === 'object') || typeof item.value === 'function' ) { const then = item.value.then; if (typeof then === 'function') { then.call(item.value, resolve, reject); } else { process.nextTick(() =&gt; { resolve(item.value); }); } } else { process.nextTick(() =&gt; { resolve(item.value); }); } } }); }} Promise.promisifypromisify 函数用于将标准回调风格异步函数转换成 Promise 风格异步函数，将会在函数列表末尾增加一个错误优先风格的回调（(err, value) =&gt; { ... }）来用于转换。 1234567891011121314class Future { static futurify(asyncFunctionWithCallback) { return (...args) =&gt; new Future((resolve, reject) =&gt; { asyncFunctionWithCallback(...args, (err, value) =&gt; { if (err) { reject(err); } else { resolve(value); } }); }); }} 总结到此，一个满足 Promise/A+ 规范的自定义 Promise 类就完成了，也顺便添加了一些常用的规范外的方法。","link":"/2019/05/30/node-custom-promise/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"OOJS","slug":"OOJS","link":"/tags/OOJS/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"}]}