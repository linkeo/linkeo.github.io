{"pages":[{"title":"","text":"/* latin-ext */ @font-face { font-family: 'Source Code Pro'; font-style: normal; font-weight: 400; src: local('Source Code Pro'), local('SourceCodePro-Regular'), url(/fonts/sourcecodepro/v9/HI_SiYsKILxRpg3hIP6sJ7fM7PqlM-vWnsUnxlC9.woff2) format('woff2'); unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* latin */ @font-face { font-family: 'Source Code Pro'; font-style: normal; font-weight: 400; src: local('Source Code Pro'), local('SourceCodePro-Regular'), url(/fonts/sourcecodepro/v9/HI_SiYsKILxRpg3hIP6sJ7fM7PqlPevWnsUnxg.woff2) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; } /* cyrillic-ext */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKcg72nU6AF7xm.woff2) format('woff2'); unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F; } /* cyrillic */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKew72nU6AF7xm.woff2) format('woff2'); unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116; } /* greek-ext */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKcw72nU6AF7xm.woff2) format('woff2'); unicode-range: U+1F00-1FFF; } /* greek */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKfA72nU6AF7xm.woff2) format('woff2'); unicode-range: U+0370-03FF; } /* latin-ext */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKcQ72nU6AF7xm.woff2) format('woff2'); unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* latin */ @font-face { font-family: 'Ubuntu'; font-style: normal; font-weight: 400; src: local('Ubuntu Regular'), local('Ubuntu-Regular'), url(/fonts/ubuntu/v13/4iCs6KVjbNBYlgoKfw72nU6AFw.woff2) format('woff2'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; }","link":"/fonts/css.css"},{"title":"","text":"/*! * Font Awesome Free 5.4.1 by @fontawesome - https://fontawesome.com * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) */ .fa,.fab,.fal,.far,.fas { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; display: inline-block; font-style: normal; font-variant: normal; text-rendering: auto; line-height: 1 } .fa-lg { font-size: 1.33333em; line-height: .75em; vertical-align: -.0667em } .fa-xs { font-size: .75em } .fa-sm { font-size: .875em } .fa-1x { font-size: 1em } .fa-2x { font-size: 2em } .fa-3x { font-size: 3em } .fa-4x { font-size: 4em } .fa-5x { font-size: 5em } .fa-6x { font-size: 6em } .fa-7x { font-size: 7em } .fa-8x { font-size: 8em } .fa-9x { font-size: 9em } .fa-10x { font-size: 10em } .fa-fw { text-align: center; width: 1.25em } .fa-ul { list-style-type: none; margin-left: 2.5em; padding-left: 0 } .fa-ul>li { position: relative } .fa-li { left: -2em; position: absolute; text-align: center; width: 2em; line-height: inherit } .fa-border { border: .08em solid #eee; border-radius: .1em; padding: .2em .25em .15em } .fa-pull-left { float: left } .fa-pull-right { float: right } .fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left { margin-right: .3em } .fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right { margin-left: .3em } .fa-spin { animation: fa-spin 2s infinite linear } .fa-pulse { animation: fa-spin 1s infinite steps(8) } @keyframes fa-spin { 0% { transform: rotate(0deg) } to { transform: rotate(1turn) } } .fa-rotate-90 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\"; transform: rotate(90deg) } .fa-rotate-180 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\"; transform: rotate(180deg) } .fa-rotate-270 { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\"; transform: rotate(270deg) } .fa-flip-horizontal { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\"; transform: scaleX(-1) } .fa-flip-vertical { transform: scaleY(-1) } .fa-flip-horizontal.fa-flip-vertical,.fa-flip-vertical { -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\" } .fa-flip-horizontal.fa-flip-vertical { transform: scale(-1) } :root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270 { -webkit-filter: none; filter: none } .fa-stack { display: inline-block; height: 2em; line-height: 2em; position: relative; vertical-align: middle; width: 2em } .fa-stack-1x,.fa-stack-2x { left: 0; position: absolute; text-align: center; width: 100% } .fa-stack-1x { line-height: inherit } .fa-stack-2x { font-size: 2em } .fa-inverse { color: #fff } .fa-500px:before { content: \"\\f26e\" } .fa-accessible-icon:before { content: \"\\f368\" } .fa-accusoft:before { content: \"\\f369\" } .fa-acquisitions-incorporated:before { content: \"\\f6af\" } .fa-ad:before { content: \"\\f641\" } .fa-address-book:before { content: \"\\f2b9\" } .fa-address-card:before { content: \"\\f2bb\" } .fa-adjust:before { content: \"\\f042\" } .fa-adn:before { content: \"\\f170\" } .fa-adversal:before { content: \"\\f36a\" } .fa-affiliatetheme:before { content: \"\\f36b\" } .fa-air-freshener:before { content: \"\\f5d0\" } .fa-algolia:before { content: \"\\f36c\" } .fa-align-center:before { content: \"\\f037\" } .fa-align-justify:before { content: \"\\f039\" } .fa-align-left:before { content: \"\\f036\" } .fa-align-right:before { content: \"\\f038\" } .fa-alipay:before { content: \"\\f642\" } .fa-allergies:before { content: \"\\f461\" } .fa-amazon:before { content: \"\\f270\" } .fa-amazon-pay:before { content: \"\\f42c\" } .fa-ambulance:before { content: \"\\f0f9\" } .fa-american-sign-language-interpreting:before { content: \"\\f2a3\" } .fa-amilia:before { content: \"\\f36d\" } .fa-anchor:before { content: \"\\f13d\" } .fa-android:before { content: \"\\f17b\" } .fa-angellist:before { content: \"\\f209\" } .fa-angle-double-down:before { content: \"\\f103\" } .fa-angle-double-left:before { content: \"\\f100\" } .fa-angle-double-right:before { content: \"\\f101\" } .fa-angle-double-up:before { content: \"\\f102\" } .fa-angle-down:before { content: \"\\f107\" } .fa-angle-left:before { content: \"\\f104\" } .fa-angle-right:before { content: \"\\f105\" } .fa-angle-up:before { content: \"\\f106\" } .fa-angry:before { content: \"\\f556\" } .fa-angrycreative:before { content: \"\\f36e\" } .fa-angular:before { content: \"\\f420\" } .fa-ankh:before { content: \"\\f644\" } .fa-app-store:before { content: \"\\f36f\" } .fa-app-store-ios:before { content: \"\\f370\" } .fa-apper:before { content: \"\\f371\" } .fa-apple:before { content: \"\\f179\" } .fa-apple-alt:before { content: \"\\f5d1\" } .fa-apple-pay:before { content: \"\\f415\" } .fa-archive:before { content: \"\\f187\" } .fa-archway:before { content: \"\\f557\" } .fa-arrow-alt-circle-down:before { content: \"\\f358\" } .fa-arrow-alt-circle-left:before { content: \"\\f359\" } .fa-arrow-alt-circle-right:before { content: \"\\f35a\" } .fa-arrow-alt-circle-up:before { content: \"\\f35b\" } .fa-arrow-circle-down:before { content: \"\\f0ab\" } .fa-arrow-circle-left:before { content: \"\\f0a8\" } .fa-arrow-circle-right:before { content: \"\\f0a9\" } .fa-arrow-circle-up:before { content: \"\\f0aa\" } .fa-arrow-down:before { content: \"\\f063\" } .fa-arrow-left:before { content: \"\\f060\" } .fa-arrow-right:before { content: \"\\f061\" } .fa-arrow-up:before { content: \"\\f062\" } .fa-arrows-alt:before { content: \"\\f0b2\" } .fa-arrows-alt-h:before { content: \"\\f337\" } .fa-arrows-alt-v:before { content: \"\\f338\" } .fa-assistive-listening-systems:before { content: \"\\f2a2\" } .fa-asterisk:before { content: \"\\f069\" } .fa-asymmetrik:before { content: \"\\f372\" } .fa-at:before { content: \"\\f1fa\" } .fa-atlas:before { content: \"\\f558\" } .fa-atom:before { content: \"\\f5d2\" } .fa-audible:before { content: \"\\f373\" } .fa-audio-description:before { content: \"\\f29e\" } .fa-autoprefixer:before { content: \"\\f41c\" } .fa-avianex:before { content: \"\\f374\" } .fa-aviato:before { content: \"\\f421\" } .fa-award:before { content: \"\\f559\" } .fa-aws:before { content: \"\\f375\" } .fa-backspace:before { content: \"\\f55a\" } .fa-backward:before { content: \"\\f04a\" } .fa-balance-scale:before { content: \"\\f24e\" } .fa-ban:before { content: \"\\f05e\" } .fa-band-aid:before { content: \"\\f462\" } .fa-bandcamp:before { content: \"\\f2d5\" } .fa-barcode:before { content: \"\\f02a\" } .fa-bars:before { content: \"\\f0c9\" } .fa-baseball-ball:before { content: \"\\f433\" } .fa-basketball-ball:before { content: \"\\f434\" } .fa-bath:before { content: \"\\f2cd\" } .fa-battery-empty:before { content: \"\\f244\" } .fa-battery-full:before { content: \"\\f240\" } .fa-battery-half:before { content: \"\\f242\" } .fa-battery-quarter:before { content: \"\\f243\" } .fa-battery-three-quarters:before { content: \"\\f241\" } .fa-bed:before { content: \"\\f236\" } .fa-beer:before { content: \"\\f0fc\" } .fa-behance:before { content: \"\\f1b4\" } .fa-behance-square:before { content: \"\\f1b5\" } .fa-bell:before { content: \"\\f0f3\" } .fa-bell-slash:before { content: \"\\f1f6\" } .fa-bezier-curve:before { content: \"\\f55b\" } .fa-bible:before { content: \"\\f647\" } .fa-bicycle:before { content: \"\\f206\" } .fa-bimobject:before { content: \"\\f378\" } .fa-binoculars:before { content: \"\\f1e5\" } .fa-birthday-cake:before { content: \"\\f1fd\" } .fa-bitbucket:before { content: \"\\f171\" } .fa-bitcoin:before { content: \"\\f379\" } .fa-bity:before { content: \"\\f37a\" } .fa-black-tie:before { content: \"\\f27e\" } .fa-blackberry:before { content: \"\\f37b\" } .fa-blender:before { content: \"\\f517\" } .fa-blender-phone:before { content: \"\\f6b6\" } .fa-blind:before { content: \"\\f29d\" } .fa-blogger:before { content: \"\\f37c\" } .fa-blogger-b:before { content: \"\\f37d\" } .fa-bluetooth:before { content: \"\\f293\" } .fa-bluetooth-b:before { content: \"\\f294\" } .fa-bold:before { content: \"\\f032\" } .fa-bolt:before { content: \"\\f0e7\" } .fa-bomb:before { content: \"\\f1e2\" } .fa-bone:before { content: \"\\f5d7\" } .fa-bong:before { content: \"\\f55c\" } .fa-book:before { content: \"\\f02d\" } .fa-book-dead:before { content: \"\\f6b7\" } .fa-book-open:before { content: \"\\f518\" } .fa-book-reader:before { content: \"\\f5da\" } .fa-bookmark:before { content: \"\\f02e\" } .fa-bowling-ball:before { content: \"\\f436\" } .fa-box:before { content: \"\\f466\" } .fa-box-open:before { content: \"\\f49e\" } .fa-boxes:before { content: \"\\f468\" } .fa-braille:before { content: \"\\f2a1\" } .fa-brain:before { content: \"\\f5dc\" } .fa-briefcase:before { content: \"\\f0b1\" } .fa-briefcase-medical:before { content: \"\\f469\" } .fa-broadcast-tower:before { content: \"\\f519\" } .fa-broom:before { content: \"\\f51a\" } .fa-brush:before { content: \"\\f55d\" } .fa-btc:before { content: \"\\f15a\" } .fa-bug:before { content: \"\\f188\" } .fa-building:before { content: \"\\f1ad\" } .fa-bullhorn:before { content: \"\\f0a1\" } .fa-bullseye:before { content: \"\\f140\" } .fa-burn:before { content: \"\\f46a\" } .fa-buromobelexperte:before { content: \"\\f37f\" } .fa-bus:before { content: \"\\f207\" } .fa-bus-alt:before { content: \"\\f55e\" } .fa-business-time:before { content: \"\\f64a\" } .fa-buysellads:before { content: \"\\f20d\" } .fa-calculator:before { content: \"\\f1ec\" } .fa-calendar:before { content: \"\\f133\" } .fa-calendar-alt:before { content: \"\\f073\" } .fa-calendar-check:before { content: \"\\f274\" } .fa-calendar-minus:before { content: \"\\f272\" } .fa-calendar-plus:before { content: \"\\f271\" } .fa-calendar-times:before { content: \"\\f273\" } .fa-camera:before { content: \"\\f030\" } .fa-camera-retro:before { content: \"\\f083\" } .fa-campground:before { content: \"\\f6bb\" } .fa-cannabis:before { content: \"\\f55f\" } .fa-capsules:before { content: \"\\f46b\" } .fa-car:before { content: \"\\f1b9\" } .fa-car-alt:before { content: \"\\f5de\" } .fa-car-battery:before { content: \"\\f5df\" } .fa-car-crash:before { content: \"\\f5e1\" } .fa-car-side:before { content: \"\\f5e4\" } .fa-caret-down:before { content: \"\\f0d7\" } .fa-caret-left:before { content: \"\\f0d9\" } .fa-caret-right:before { content: \"\\f0da\" } .fa-caret-square-down:before { content: \"\\f150\" } .fa-caret-square-left:before { content: \"\\f191\" } .fa-caret-square-right:before { content: \"\\f152\" } .fa-caret-square-up:before { content: \"\\f151\" } .fa-caret-up:before { content: \"\\f0d8\" } .fa-cart-arrow-down:before { content: \"\\f218\" } .fa-cart-plus:before { content: \"\\f217\" } .fa-cat:before { content: \"\\f6be\" } .fa-cc-amazon-pay:before { content: \"\\f42d\" } .fa-cc-amex:before { content: \"\\f1f3\" } .fa-cc-apple-pay:before { content: \"\\f416\" } .fa-cc-diners-club:before { content: \"\\f24c\" } .fa-cc-discover:before { content: \"\\f1f2\" } .fa-cc-jcb:before { content: \"\\f24b\" } .fa-cc-mastercard:before { content: \"\\f1f1\" } .fa-cc-paypal:before { content: \"\\f1f4\" } .fa-cc-stripe:before { content: \"\\f1f5\" } .fa-cc-visa:before { content: \"\\f1f0\" } .fa-centercode:before { content: \"\\f380\" } .fa-certificate:before { content: \"\\f0a3\" } .fa-chair:before { content: \"\\f6c0\" } .fa-chalkboard:before { content: \"\\f51b\" } .fa-chalkboard-teacher:before { content: \"\\f51c\" } .fa-charging-station:before { content: \"\\f5e7\" } .fa-chart-area:before { content: \"\\f1fe\" } .fa-chart-bar:before { content: \"\\f080\" } .fa-chart-line:before { content: \"\\f201\" } .fa-chart-pie:before { content: \"\\f200\" } .fa-check:before { content: \"\\f00c\" } .fa-check-circle:before { content: \"\\f058\" } .fa-check-double:before { content: \"\\f560\" } .fa-check-square:before { content: \"\\f14a\" } .fa-chess:before { content: \"\\f439\" } .fa-chess-bishop:before { content: \"\\f43a\" } .fa-chess-board:before { content: \"\\f43c\" } .fa-chess-king:before { content: \"\\f43f\" } .fa-chess-knight:before { content: \"\\f441\" } .fa-chess-pawn:before { content: \"\\f443\" } .fa-chess-queen:before { content: \"\\f445\" } .fa-chess-rook:before { content: \"\\f447\" } .fa-chevron-circle-down:before { content: \"\\f13a\" } .fa-chevron-circle-left:before { content: \"\\f137\" } .fa-chevron-circle-right:before { content: \"\\f138\" } .fa-chevron-circle-up:before { content: \"\\f139\" } .fa-chevron-down:before { content: \"\\f078\" } .fa-chevron-left:before { content: \"\\f053\" } .fa-chevron-right:before { content: \"\\f054\" } .fa-chevron-up:before { content: \"\\f077\" } .fa-child:before { content: \"\\f1ae\" } .fa-chrome:before { content: \"\\f268\" } .fa-church:before { content: \"\\f51d\" } .fa-circle:before { content: \"\\f111\" } .fa-circle-notch:before { content: \"\\f1ce\" } .fa-city:before { content: \"\\f64f\" } .fa-clipboard:before { content: \"\\f328\" } .fa-clipboard-check:before { content: \"\\f46c\" } .fa-clipboard-list:before { content: \"\\f46d\" } .fa-clock:before { content: \"\\f017\" } .fa-clone:before { content: \"\\f24d\" } .fa-closed-captioning:before { content: \"\\f20a\" } .fa-cloud:before { content: \"\\f0c2\" } .fa-cloud-download-alt:before { content: \"\\f381\" } .fa-cloud-moon:before { content: \"\\f6c3\" } .fa-cloud-sun:before { content: \"\\f6c4\" } .fa-cloud-upload-alt:before { content: \"\\f382\" } .fa-cloudscale:before { content: \"\\f383\" } .fa-cloudsmith:before { content: \"\\f384\" } .fa-cloudversify:before { content: \"\\f385\" } .fa-cocktail:before { content: \"\\f561\" } .fa-code:before { content: \"\\f121\" } .fa-code-branch:before { content: \"\\f126\" } .fa-codepen:before { content: \"\\f1cb\" } .fa-codiepie:before { content: \"\\f284\" } .fa-coffee:before { content: \"\\f0f4\" } .fa-cog:before { content: \"\\f013\" } .fa-cogs:before { content: \"\\f085\" } .fa-coins:before { content: \"\\f51e\" } .fa-columns:before { content: \"\\f0db\" } .fa-comment:before { content: \"\\f075\" } .fa-comment-alt:before { content: \"\\f27a\" } .fa-comment-dollar:before { content: \"\\f651\" } .fa-comment-dots:before { content: \"\\f4ad\" } .fa-comment-slash:before { content: \"\\f4b3\" } .fa-comments:before { content: \"\\f086\" } .fa-comments-dollar:before { content: \"\\f653\" } .fa-compact-disc:before { content: \"\\f51f\" } .fa-compass:before { content: \"\\f14e\" } .fa-compress:before { content: \"\\f066\" } .fa-concierge-bell:before { content: \"\\f562\" } .fa-connectdevelop:before { content: \"\\f20e\" } .fa-contao:before { content: \"\\f26d\" } .fa-cookie:before { content: \"\\f563\" } .fa-cookie-bite:before { content: \"\\f564\" } .fa-copy:before { content: \"\\f0c5\" } .fa-copyright:before { content: \"\\f1f9\" } .fa-couch:before { content: \"\\f4b8\" } .fa-cpanel:before { content: \"\\f388\" } .fa-creative-commons:before { content: \"\\f25e\" } .fa-creative-commons-by:before { content: \"\\f4e7\" } .fa-creative-commons-nc:before { content: \"\\f4e8\" } .fa-creative-commons-nc-eu:before { content: \"\\f4e9\" } .fa-creative-commons-nc-jp:before { content: \"\\f4ea\" } .fa-creative-commons-nd:before { content: \"\\f4eb\" } .fa-creative-commons-pd:before { content: \"\\f4ec\" } .fa-creative-commons-pd-alt:before { content: \"\\f4ed\" } .fa-creative-commons-remix:before { content: \"\\f4ee\" } .fa-creative-commons-sa:before { content: \"\\f4ef\" } .fa-creative-commons-sampling:before { content: \"\\f4f0\" } .fa-creative-commons-sampling-plus:before { content: \"\\f4f1\" } .fa-creative-commons-share:before { content: \"\\f4f2\" } .fa-creative-commons-zero:before { content: \"\\f4f3\" } .fa-credit-card:before { content: \"\\f09d\" } .fa-critical-role:before { content: \"\\f6c9\" } .fa-crop:before { content: \"\\f125\" } .fa-crop-alt:before { content: \"\\f565\" } .fa-cross:before { content: \"\\f654\" } .fa-crosshairs:before { content: \"\\f05b\" } .fa-crow:before { content: \"\\f520\" } .fa-crown:before { content: \"\\f521\" } .fa-css3:before { content: \"\\f13c\" } .fa-css3-alt:before { content: \"\\f38b\" } .fa-cube:before { content: \"\\f1b2\" } .fa-cubes:before { content: \"\\f1b3\" } .fa-cut:before { content: \"\\f0c4\" } .fa-cuttlefish:before { content: \"\\f38c\" } .fa-d-and-d:before { content: \"\\f38d\" } .fa-dashcube:before { content: \"\\f210\" } .fa-database:before { content: \"\\f1c0\" } .fa-deaf:before { content: \"\\f2a4\" } .fa-delicious:before { content: \"\\f1a5\" } .fa-deploydog:before { content: \"\\f38e\" } .fa-deskpro:before { content: \"\\f38f\" } .fa-desktop:before { content: \"\\f108\" } .fa-dev:before { content: \"\\f6cc\" } .fa-deviantart:before { content: \"\\f1bd\" } .fa-dharmachakra:before { content: \"\\f655\" } .fa-diagnoses:before { content: \"\\f470\" } .fa-dice:before { content: \"\\f522\" } .fa-dice-d20:before { content: \"\\f6cf\" } .fa-dice-d6:before { content: \"\\f6d1\" } .fa-dice-five:before { content: \"\\f523\" } .fa-dice-four:before { content: \"\\f524\" } .fa-dice-one:before { content: \"\\f525\" } .fa-dice-six:before { content: \"\\f526\" } .fa-dice-three:before { content: \"\\f527\" } .fa-dice-two:before { content: \"\\f528\" } .fa-digg:before { content: \"\\f1a6\" } .fa-digital-ocean:before { content: \"\\f391\" } .fa-digital-tachograph:before { content: \"\\f566\" } .fa-directions:before { content: \"\\f5eb\" } .fa-discord:before { content: \"\\f392\" } .fa-discourse:before { content: \"\\f393\" } .fa-divide:before { content: \"\\f529\" } .fa-dizzy:before { content: \"\\f567\" } .fa-dna:before { content: \"\\f471\" } .fa-dochub:before { content: \"\\f394\" } .fa-docker:before { content: \"\\f395\" } .fa-dog:before { content: \"\\f6d3\" } .fa-dollar-sign:before { content: \"\\f155\" } .fa-dolly:before { content: \"\\f472\" } .fa-dolly-flatbed:before { content: \"\\f474\" } .fa-donate:before { content: \"\\f4b9\" } .fa-door-closed:before { content: \"\\f52a\" } .fa-door-open:before { content: \"\\f52b\" } .fa-dot-circle:before { content: \"\\f192\" } .fa-dove:before { content: \"\\f4ba\" } .fa-download:before { content: \"\\f019\" } .fa-draft2digital:before { content: \"\\f396\" } .fa-drafting-compass:before { content: \"\\f568\" } .fa-dragon:before { content: \"\\f6d5\" } .fa-draw-polygon:before { content: \"\\f5ee\" } .fa-dribbble:before { content: \"\\f17d\" } .fa-dribbble-square:before { content: \"\\f397\" } .fa-dropbox:before { content: \"\\f16b\" } .fa-drum:before { content: \"\\f569\" } .fa-drum-steelpan:before { content: \"\\f56a\" } .fa-drumstick-bite:before { content: \"\\f6d7\" } .fa-drupal:before { content: \"\\f1a9\" } .fa-dumbbell:before { content: \"\\f44b\" } .fa-dungeon:before { content: \"\\f6d9\" } .fa-dyalog:before { content: \"\\f399\" } .fa-earlybirds:before { content: \"\\f39a\" } .fa-ebay:before { content: \"\\f4f4\" } .fa-edge:before { content: \"\\f282\" } .fa-edit:before { content: \"\\f044\" } .fa-eject:before { content: \"\\f052\" } .fa-elementor:before { content: \"\\f430\" } .fa-ellipsis-h:before { content: \"\\f141\" } .fa-ellipsis-v:before { content: \"\\f142\" } .fa-ello:before { content: \"\\f5f1\" } .fa-ember:before { content: \"\\f423\" } .fa-empire:before { content: \"\\f1d1\" } .fa-envelope:before { content: \"\\f0e0\" } .fa-envelope-open:before { content: \"\\f2b6\" } .fa-envelope-open-text:before { content: \"\\f658\" } .fa-envelope-square:before { content: \"\\f199\" } .fa-envira:before { content: \"\\f299\" } .fa-equals:before { content: \"\\f52c\" } .fa-eraser:before { content: \"\\f12d\" } .fa-erlang:before { content: \"\\f39d\" } .fa-ethereum:before { content: \"\\f42e\" } .fa-etsy:before { content: \"\\f2d7\" } .fa-euro-sign:before { content: \"\\f153\" } .fa-exchange-alt:before { content: \"\\f362\" } .fa-exclamation:before { content: \"\\f12a\" } .fa-exclamation-circle:before { content: \"\\f06a\" } .fa-exclamation-triangle:before { content: \"\\f071\" } .fa-expand:before { content: \"\\f065\" } .fa-expand-arrows-alt:before { content: \"\\f31e\" } .fa-expeditedssl:before { content: \"\\f23e\" } .fa-external-link-alt:before { content: \"\\f35d\" } .fa-external-link-square-alt:before { content: \"\\f360\" } .fa-eye:before { content: \"\\f06e\" } .fa-eye-dropper:before { content: \"\\f1fb\" } .fa-eye-slash:before { content: \"\\f070\" } .fa-facebook:before { content: \"\\f09a\" } .fa-facebook-f:before { content: \"\\f39e\" } .fa-facebook-messenger:before { content: \"\\f39f\" } .fa-facebook-square:before { content: \"\\f082\" } .fa-fantasy-flight-games:before { content: \"\\f6dc\" } .fa-fast-backward:before { content: \"\\f049\" } .fa-fast-forward:before { content: \"\\f050\" } .fa-fax:before { content: \"\\f1ac\" } .fa-feather:before { content: \"\\f52d\" } .fa-feather-alt:before { content: \"\\f56b\" } .fa-female:before { content: \"\\f182\" } .fa-fighter-jet:before { content: \"\\f0fb\" } .fa-file:before { content: \"\\f15b\" } .fa-file-alt:before { content: \"\\f15c\" } .fa-file-archive:before { content: \"\\f1c6\" } .fa-file-audio:before { content: \"\\f1c7\" } .fa-file-code:before { content: \"\\f1c9\" } .fa-file-contract:before { content: \"\\f56c\" } .fa-file-csv:before { content: \"\\f6dd\" } .fa-file-download:before { content: \"\\f56d\" } .fa-file-excel:before { content: \"\\f1c3\" } .fa-file-export:before { content: \"\\f56e\" } .fa-file-image:before { content: \"\\f1c5\" } .fa-file-import:before { content: \"\\f56f\" } .fa-file-invoice:before { content: \"\\f570\" } .fa-file-invoice-dollar:before { content: \"\\f571\" } .fa-file-medical:before { content: \"\\f477\" } .fa-file-medical-alt:before { content: \"\\f478\" } .fa-file-pdf:before { content: \"\\f1c1\" } .fa-file-powerpoint:before { content: \"\\f1c4\" } .fa-file-prescription:before { content: \"\\f572\" } .fa-file-signature:before { content: \"\\f573\" } .fa-file-upload:before { content: \"\\f574\" } .fa-file-video:before { content: \"\\f1c8\" } .fa-file-word:before { content: \"\\f1c2\" } .fa-fill:before { content: \"\\f575\" } .fa-fill-drip:before { content: \"\\f576\" } .fa-film:before { content: \"\\f008\" } .fa-filter:before { content: \"\\f0b0\" } .fa-fingerprint:before { content: \"\\f577\" } .fa-fire:before { content: \"\\f06d\" } .fa-fire-extinguisher:before { content: \"\\f134\" } .fa-firefox:before { content: \"\\f269\" } .fa-first-aid:before { content: \"\\f479\" } .fa-first-order:before { content: \"\\f2b0\" } .fa-first-order-alt:before { content: \"\\f50a\" } .fa-firstdraft:before { content: \"\\f3a1\" } .fa-fish:before { content: \"\\f578\" } .fa-fist-raised:before { content: \"\\f6de\" } .fa-flag:before { content: \"\\f024\" } .fa-flag-checkered:before { content: \"\\f11e\" } .fa-flask:before { content: \"\\f0c3\" } .fa-flickr:before { content: \"\\f16e\" } .fa-flipboard:before { content: \"\\f44d\" } .fa-flushed:before { content: \"\\f579\" } .fa-fly:before { content: \"\\f417\" } .fa-folder:before { content: \"\\f07b\" } .fa-folder-minus:before { content: \"\\f65d\" } .fa-folder-open:before { content: \"\\f07c\" } .fa-folder-plus:before { content: \"\\f65e\" } .fa-font:before { content: \"\\f031\" } .fa-font-awesome:before { content: \"\\f2b4\" } .fa-font-awesome-alt:before { content: \"\\f35c\" } .fa-font-awesome-flag:before { content: \"\\f425\" } .fa-font-awesome-logo-full:before { content: \"\\f4e6\" } .fa-fonticons:before { content: \"\\f280\" } .fa-fonticons-fi:before { content: \"\\f3a2\" } .fa-football-ball:before { content: \"\\f44e\" } .fa-fort-awesome:before { content: \"\\f286\" } .fa-fort-awesome-alt:before { content: \"\\f3a3\" } .fa-forumbee:before { content: \"\\f211\" } .fa-forward:before { content: \"\\f04e\" } .fa-foursquare:before { content: \"\\f180\" } .fa-free-code-camp:before { content: \"\\f2c5\" } .fa-freebsd:before { content: \"\\f3a4\" } .fa-frog:before { content: \"\\f52e\" } .fa-frown:before { content: \"\\f119\" } .fa-frown-open:before { content: \"\\f57a\" } .fa-fulcrum:before { content: \"\\f50b\" } .fa-funnel-dollar:before { content: \"\\f662\" } .fa-futbol:before { content: \"\\f1e3\" } .fa-galactic-republic:before { content: \"\\f50c\" } .fa-galactic-senate:before { content: \"\\f50d\" } .fa-gamepad:before { content: \"\\f11b\" } .fa-gas-pump:before { content: \"\\f52f\" } .fa-gavel:before { content: \"\\f0e3\" } .fa-gem:before { content: \"\\f3a5\" } .fa-genderless:before { content: \"\\f22d\" } .fa-get-pocket:before { content: \"\\f265\" } .fa-gg:before { content: \"\\f260\" } .fa-gg-circle:before { content: \"\\f261\" } .fa-ghost:before { content: \"\\f6e2\" } .fa-gift:before { content: \"\\f06b\" } .fa-git:before { content: \"\\f1d3\" } .fa-git-square:before { content: \"\\f1d2\" } .fa-github:before { content: \"\\f09b\" } .fa-github-alt:before { content: \"\\f113\" } .fa-github-square:before { content: \"\\f092\" } .fa-gitkraken:before { content: \"\\f3a6\" } .fa-gitlab:before { content: \"\\f296\" } .fa-gitter:before { content: \"\\f426\" } .fa-glass-martini:before { content: \"\\f000\" } .fa-glass-martini-alt:before { content: \"\\f57b\" } .fa-glasses:before { content: \"\\f530\" } .fa-glide:before { content: \"\\f2a5\" } .fa-glide-g:before { content: \"\\f2a6\" } .fa-globe:before { content: \"\\f0ac\" } .fa-globe-africa:before { content: \"\\f57c\" } .fa-globe-americas:before { content: \"\\f57d\" } .fa-globe-asia:before { content: \"\\f57e\" } .fa-gofore:before { content: \"\\f3a7\" } .fa-golf-ball:before { content: \"\\f450\" } .fa-goodreads:before { content: \"\\f3a8\" } .fa-goodreads-g:before { content: \"\\f3a9\" } .fa-google:before { content: \"\\f1a0\" } .fa-google-drive:before { content: \"\\f3aa\" } .fa-google-play:before { content: \"\\f3ab\" } .fa-google-plus:before { content: \"\\f2b3\" } .fa-google-plus-g:before { content: \"\\f0d5\" } .fa-google-plus-square:before { content: \"\\f0d4\" } .fa-google-wallet:before { content: \"\\f1ee\" } .fa-gopuram:before { content: \"\\f664\" } .fa-graduation-cap:before { content: \"\\f19d\" } .fa-gratipay:before { content: \"\\f184\" } .fa-grav:before { content: \"\\f2d6\" } .fa-greater-than:before { content: \"\\f531\" } .fa-greater-than-equal:before { content: \"\\f532\" } .fa-grimace:before { content: \"\\f57f\" } .fa-grin:before { content: \"\\f580\" } .fa-grin-alt:before { content: \"\\f581\" } .fa-grin-beam:before { content: \"\\f582\" } .fa-grin-beam-sweat:before { content: \"\\f583\" } .fa-grin-hearts:before { content: \"\\f584\" } .fa-grin-squint:before { content: \"\\f585\" } .fa-grin-squint-tears:before { content: \"\\f586\" } .fa-grin-stars:before { content: \"\\f587\" } .fa-grin-tears:before { content: \"\\f588\" } .fa-grin-tongue:before { content: \"\\f589\" } .fa-grin-tongue-squint:before { content: \"\\f58a\" } .fa-grin-tongue-wink:before { content: \"\\f58b\" } .fa-grin-wink:before { content: \"\\f58c\" } .fa-grip-horizontal:before { content: \"\\f58d\" } .fa-grip-vertical:before { content: \"\\f58e\" } .fa-gripfire:before { content: \"\\f3ac\" } .fa-grunt:before { content: \"\\f3ad\" } .fa-gulp:before { content: \"\\f3ae\" } .fa-h-square:before { content: \"\\f0fd\" } .fa-hacker-news:before { content: \"\\f1d4\" } .fa-hacker-news-square:before { content: \"\\f3af\" } .fa-hackerrank:before { content: \"\\f5f7\" } .fa-hammer:before { content: \"\\f6e3\" } .fa-hamsa:before { content: \"\\f665\" } .fa-hand-holding:before { content: \"\\f4bd\" } .fa-hand-holding-heart:before { content: \"\\f4be\" } .fa-hand-holding-usd:before { content: \"\\f4c0\" } .fa-hand-lizard:before { content: \"\\f258\" } .fa-hand-paper:before { content: \"\\f256\" } .fa-hand-peace:before { content: \"\\f25b\" } .fa-hand-point-down:before { content: \"\\f0a7\" } .fa-hand-point-left:before { content: \"\\f0a5\" } .fa-hand-point-right:before { content: \"\\f0a4\" } .fa-hand-point-up:before { content: \"\\f0a6\" } .fa-hand-pointer:before { content: \"\\f25a\" } .fa-hand-rock:before { content: \"\\f255\" } .fa-hand-scissors:before { content: \"\\f257\" } .fa-hand-spock:before { content: \"\\f259\" } .fa-hands:before { content: \"\\f4c2\" } .fa-hands-helping:before { content: \"\\f4c4\" } .fa-handshake:before { content: \"\\f2b5\" } .fa-hanukiah:before { content: \"\\f6e6\" } .fa-hashtag:before { content: \"\\f292\" } .fa-hat-wizard:before { content: \"\\f6e8\" } .fa-haykal:before { content: \"\\f666\" } .fa-hdd:before { content: \"\\f0a0\" } .fa-heading:before { content: \"\\f1dc\" } .fa-headphones:before { content: \"\\f025\" } .fa-headphones-alt:before { content: \"\\f58f\" } .fa-headset:before { content: \"\\f590\" } .fa-heart:before { content: \"\\f004\" } .fa-heartbeat:before { content: \"\\f21e\" } .fa-helicopter:before { content: \"\\f533\" } .fa-highlighter:before { content: \"\\f591\" } .fa-hiking:before { content: \"\\f6ec\" } .fa-hippo:before { content: \"\\f6ed\" } .fa-hips:before { content: \"\\f452\" } .fa-hire-a-helper:before { content: \"\\f3b0\" } .fa-history:before { content: \"\\f1da\" } .fa-hockey-puck:before { content: \"\\f453\" } .fa-home:before { content: \"\\f015\" } .fa-hooli:before { content: \"\\f427\" } .fa-hornbill:before { content: \"\\f592\" } .fa-horse:before { content: \"\\f6f0\" } .fa-hospital:before { content: \"\\f0f8\" } .fa-hospital-alt:before { content: \"\\f47d\" } .fa-hospital-symbol:before { content: \"\\f47e\" } .fa-hot-tub:before { content: \"\\f593\" } .fa-hotel:before { content: \"\\f594\" } .fa-hotjar:before { content: \"\\f3b1\" } .fa-hourglass:before { content: \"\\f254\" } .fa-hourglass-end:before { content: \"\\f253\" } .fa-hourglass-half:before { content: \"\\f252\" } .fa-hourglass-start:before { content: \"\\f251\" } .fa-house-damage:before { content: \"\\f6f1\" } .fa-houzz:before { content: \"\\f27c\" } .fa-hryvnia:before { content: \"\\f6f2\" } .fa-html5:before { content: \"\\f13b\" } .fa-hubspot:before { content: \"\\f3b2\" } .fa-i-cursor:before { content: \"\\f246\" } .fa-id-badge:before { content: \"\\f2c1\" } .fa-id-card:before { content: \"\\f2c2\" } .fa-id-card-alt:before { content: \"\\f47f\" } .fa-image:before { content: \"\\f03e\" } .fa-images:before { content: \"\\f302\" } .fa-imdb:before { content: \"\\f2d8\" } .fa-inbox:before { content: \"\\f01c\" } .fa-indent:before { content: \"\\f03c\" } .fa-industry:before { content: \"\\f275\" } .fa-infinity:before { content: \"\\f534\" } .fa-info:before { content: \"\\f129\" } .fa-info-circle:before { content: \"\\f05a\" } .fa-instagram:before { content: \"\\f16d\" } .fa-internet-explorer:before { content: \"\\f26b\" } .fa-ioxhost:before { content: \"\\f208\" } .fa-italic:before { content: \"\\f033\" } .fa-itunes:before { content: \"\\f3b4\" } .fa-itunes-note:before { content: \"\\f3b5\" } .fa-java:before { content: \"\\f4e4\" } .fa-jedi:before { content: \"\\f669\" } .fa-jedi-order:before { content: \"\\f50e\" } .fa-jenkins:before { content: \"\\f3b6\" } .fa-joget:before { content: \"\\f3b7\" } .fa-joint:before { content: \"\\f595\" } .fa-joomla:before { content: \"\\f1aa\" } .fa-journal-whills:before { content: \"\\f66a\" } .fa-js:before { content: \"\\f3b8\" } .fa-js-square:before { content: \"\\f3b9\" } .fa-jsfiddle:before { content: \"\\f1cc\" } .fa-kaaba:before { content: \"\\f66b\" } .fa-kaggle:before { content: \"\\f5fa\" } .fa-key:before { content: \"\\f084\" } .fa-keybase:before { content: \"\\f4f5\" } .fa-keyboard:before { content: \"\\f11c\" } .fa-keycdn:before { content: \"\\f3ba\" } .fa-khanda:before { content: \"\\f66d\" } .fa-kickstarter:before { content: \"\\f3bb\" } .fa-kickstarter-k:before { content: \"\\f3bc\" } .fa-kiss:before { content: \"\\f596\" } .fa-kiss-beam:before { content: \"\\f597\" } .fa-kiss-wink-heart:before { content: \"\\f598\" } .fa-kiwi-bird:before { content: \"\\f535\" } .fa-korvue:before { content: \"\\f42f\" } .fa-landmark:before { content: \"\\f66f\" } .fa-language:before { content: \"\\f1ab\" } .fa-laptop:before { content: \"\\f109\" } .fa-laptop-code:before { content: \"\\f5fc\" } .fa-laravel:before { content: \"\\f3bd\" } .fa-lastfm:before { content: \"\\f202\" } .fa-lastfm-square:before { content: \"\\f203\" } .fa-laugh:before { content: \"\\f599\" } .fa-laugh-beam:before { content: \"\\f59a\" } .fa-laugh-squint:before { content: \"\\f59b\" } .fa-laugh-wink:before { content: \"\\f59c\" } .fa-layer-group:before { content: \"\\f5fd\" } .fa-leaf:before { content: \"\\f06c\" } .fa-leanpub:before { content: \"\\f212\" } .fa-lemon:before { content: \"\\f094\" } .fa-less:before { content: \"\\f41d\" } .fa-less-than:before { content: \"\\f536\" } .fa-less-than-equal:before { content: \"\\f537\" } .fa-level-down-alt:before { content: \"\\f3be\" } .fa-level-up-alt:before { content: \"\\f3bf\" } .fa-life-ring:before { content: \"\\f1cd\" } .fa-lightbulb:before { content: \"\\f0eb\" } .fa-line:before { content: \"\\f3c0\" } .fa-link:before { content: \"\\f0c1\" } .fa-linkedin:before { content: \"\\f08c\" } .fa-linkedin-in:before { content: \"\\f0e1\" } .fa-linode:before { content: \"\\f2b8\" } .fa-linux:before { content: \"\\f17c\" } .fa-lira-sign:before { content: \"\\f195\" } .fa-list:before { content: \"\\f03a\" } .fa-list-alt:before { content: \"\\f022\" } .fa-list-ol:before { content: \"\\f0cb\" } .fa-list-ul:before { content: \"\\f0ca\" } .fa-location-arrow:before { content: \"\\f124\" } .fa-lock:before { content: \"\\f023\" } .fa-lock-open:before { content: \"\\f3c1\" } .fa-long-arrow-alt-down:before { content: \"\\f309\" } .fa-long-arrow-alt-left:before { content: \"\\f30a\" } .fa-long-arrow-alt-right:before { content: \"\\f30b\" } .fa-long-arrow-alt-up:before { content: \"\\f30c\" } .fa-low-vision:before { content: \"\\f2a8\" } .fa-luggage-cart:before { content: \"\\f59d\" } .fa-lyft:before { content: \"\\f3c3\" } .fa-magento:before { content: \"\\f3c4\" } .fa-magic:before { content: \"\\f0d0\" } .fa-magnet:before { content: \"\\f076\" } .fa-mail-bulk:before { content: \"\\f674\" } .fa-mailchimp:before { content: \"\\f59e\" } .fa-male:before { content: \"\\f183\" } .fa-mandalorian:before { content: \"\\f50f\" } .fa-map:before { content: \"\\f279\" } .fa-map-marked:before { content: \"\\f59f\" } .fa-map-marked-alt:before { content: \"\\f5a0\" } .fa-map-marker:before { content: \"\\f041\" } .fa-map-marker-alt:before { content: \"\\f3c5\" } .fa-map-pin:before { content: \"\\f276\" } .fa-map-signs:before { content: \"\\f277\" } .fa-markdown:before { content: \"\\f60f\" } .fa-marker:before { content: \"\\f5a1\" } .fa-mars:before { content: \"\\f222\" } .fa-mars-double:before { content: \"\\f227\" } .fa-mars-stroke:before { content: \"\\f229\" } .fa-mars-stroke-h:before { content: \"\\f22b\" } .fa-mars-stroke-v:before { content: \"\\f22a\" } .fa-mask:before { content: \"\\f6fa\" } .fa-mastodon:before { content: \"\\f4f6\" } .fa-maxcdn:before { content: \"\\f136\" } .fa-medal:before { content: \"\\f5a2\" } .fa-medapps:before { content: \"\\f3c6\" } .fa-medium:before { content: \"\\f23a\" } .fa-medium-m:before { content: \"\\f3c7\" } .fa-medkit:before { content: \"\\f0fa\" } .fa-medrt:before { content: \"\\f3c8\" } .fa-meetup:before { content: \"\\f2e0\" } .fa-megaport:before { content: \"\\f5a3\" } .fa-meh:before { content: \"\\f11a\" } .fa-meh-blank:before { content: \"\\f5a4\" } .fa-meh-rolling-eyes:before { content: \"\\f5a5\" } .fa-memory:before { content: \"\\f538\" } .fa-menorah:before { content: \"\\f676\" } .fa-mercury:before { content: \"\\f223\" } .fa-microchip:before { content: \"\\f2db\" } .fa-microphone:before { content: \"\\f130\" } .fa-microphone-alt:before { content: \"\\f3c9\" } .fa-microphone-alt-slash:before { content: \"\\f539\" } .fa-microphone-slash:before { content: \"\\f131\" } .fa-microscope:before { content: \"\\f610\" } .fa-microsoft:before { content: \"\\f3ca\" } .fa-minus:before { content: \"\\f068\" } .fa-minus-circle:before { content: \"\\f056\" } .fa-minus-square:before { content: \"\\f146\" } .fa-mix:before { content: \"\\f3cb\" } .fa-mixcloud:before { content: \"\\f289\" } .fa-mizuni:before { content: \"\\f3cc\" } .fa-mobile:before { content: \"\\f10b\" } .fa-mobile-alt:before { content: \"\\f3cd\" } .fa-modx:before { content: \"\\f285\" } .fa-monero:before { content: \"\\f3d0\" } .fa-money-bill:before { content: \"\\f0d6\" } .fa-money-bill-alt:before { content: \"\\f3d1\" } .fa-money-bill-wave:before { content: \"\\f53a\" } .fa-money-bill-wave-alt:before { content: \"\\f53b\" } .fa-money-check:before { content: \"\\f53c\" } .fa-money-check-alt:before { content: \"\\f53d\" } .fa-monument:before { content: \"\\f5a6\" } .fa-moon:before { content: \"\\f186\" } .fa-mortar-pestle:before { content: \"\\f5a7\" } .fa-mosque:before { content: \"\\f678\" } .fa-motorcycle:before { content: \"\\f21c\" } .fa-mountain:before { content: \"\\f6fc\" } .fa-mouse-pointer:before { content: \"\\f245\" } .fa-music:before { content: \"\\f001\" } .fa-napster:before { content: \"\\f3d2\" } .fa-neos:before { content: \"\\f612\" } .fa-network-wired:before { content: \"\\f6ff\" } .fa-neuter:before { content: \"\\f22c\" } .fa-newspaper:before { content: \"\\f1ea\" } .fa-nimblr:before { content: \"\\f5a8\" } .fa-nintendo-switch:before { content: \"\\f418\" } .fa-node:before { content: \"\\f419\" } .fa-node-js:before { content: \"\\f3d3\" } .fa-not-equal:before { content: \"\\f53e\" } .fa-notes-medical:before { content: \"\\f481\" } .fa-npm:before { content: \"\\f3d4\" } .fa-ns8:before { content: \"\\f3d5\" } .fa-nutritionix:before { content: \"\\f3d6\" } .fa-object-group:before { content: \"\\f247\" } .fa-object-ungroup:before { content: \"\\f248\" } .fa-odnoklassniki:before { content: \"\\f263\" } .fa-odnoklassniki-square:before { content: \"\\f264\" } .fa-oil-can:before { content: \"\\f613\" } .fa-old-republic:before { content: \"\\f510\" } .fa-om:before { content: \"\\f679\" } .fa-opencart:before { content: \"\\f23d\" } .fa-openid:before { content: \"\\f19b\" } .fa-opera:before { content: \"\\f26a\" } .fa-optin-monster:before { content: \"\\f23c\" } .fa-osi:before { content: \"\\f41a\" } .fa-otter:before { content: \"\\f700\" } .fa-outdent:before { content: \"\\f03b\" } .fa-page4:before { content: \"\\f3d7\" } .fa-pagelines:before { content: \"\\f18c\" } .fa-paint-brush:before { content: \"\\f1fc\" } .fa-paint-roller:before { content: \"\\f5aa\" } .fa-palette:before { content: \"\\f53f\" } .fa-palfed:before { content: \"\\f3d8\" } .fa-pallet:before { content: \"\\f482\" } .fa-paper-plane:before { content: \"\\f1d8\" } .fa-paperclip:before { content: \"\\f0c6\" } .fa-parachute-box:before { content: \"\\f4cd\" } .fa-paragraph:before { content: \"\\f1dd\" } .fa-parking:before { content: \"\\f540\" } .fa-passport:before { content: \"\\f5ab\" } .fa-pastafarianism:before { content: \"\\f67b\" } .fa-paste:before { content: \"\\f0ea\" } .fa-patreon:before { content: \"\\f3d9\" } .fa-pause:before { content: \"\\f04c\" } .fa-pause-circle:before { content: \"\\f28b\" } .fa-paw:before { content: \"\\f1b0\" } .fa-paypal:before { content: \"\\f1ed\" } .fa-peace:before { content: \"\\f67c\" } .fa-pen:before { content: \"\\f304\" } .fa-pen-alt:before { content: \"\\f305\" } .fa-pen-fancy:before { content: \"\\f5ac\" } .fa-pen-nib:before { content: \"\\f5ad\" } .fa-pen-square:before { content: \"\\f14b\" } .fa-pencil-alt:before { content: \"\\f303\" } .fa-pencil-ruler:before { content: \"\\f5ae\" } .fa-penny-arcade:before { content: \"\\f704\" } .fa-people-carry:before { content: \"\\f4ce\" } .fa-percent:before { content: \"\\f295\" } .fa-percentage:before { content: \"\\f541\" } .fa-periscope:before { content: \"\\f3da\" } .fa-phabricator:before { content: \"\\f3db\" } .fa-phoenix-framework:before { content: \"\\f3dc\" } .fa-phoenix-squadron:before { content: \"\\f511\" } .fa-phone:before { content: \"\\f095\" } .fa-phone-slash:before { content: \"\\f3dd\" } .fa-phone-square:before { content: \"\\f098\" } .fa-phone-volume:before { content: \"\\f2a0\" } .fa-php:before { content: \"\\f457\" } .fa-pied-piper:before { content: \"\\f2ae\" } .fa-pied-piper-alt:before { content: \"\\f1a8\" } .fa-pied-piper-hat:before { content: \"\\f4e5\" } .fa-pied-piper-pp:before { content: \"\\f1a7\" } .fa-piggy-bank:before { content: \"\\f4d3\" } .fa-pills:before { content: \"\\f484\" } .fa-pinterest:before { content: \"\\f0d2\" } .fa-pinterest-p:before { content: \"\\f231\" } .fa-pinterest-square:before { content: \"\\f0d3\" } .fa-place-of-worship:before { content: \"\\f67f\" } .fa-plane:before { content: \"\\f072\" } .fa-plane-arrival:before { content: \"\\f5af\" } .fa-plane-departure:before { content: \"\\f5b0\" } .fa-play:before { content: \"\\f04b\" } .fa-play-circle:before { content: \"\\f144\" } .fa-playstation:before { content: \"\\f3df\" } .fa-plug:before { content: \"\\f1e6\" } .fa-plus:before { content: \"\\f067\" } .fa-plus-circle:before { content: \"\\f055\" } .fa-plus-square:before { content: \"\\f0fe\" } .fa-podcast:before { content: \"\\f2ce\" } .fa-poll:before { content: \"\\f681\" } .fa-poll-h:before { content: \"\\f682\" } .fa-poo:before { content: \"\\f2fe\" } .fa-poop:before { content: \"\\f619\" } .fa-portrait:before { content: \"\\f3e0\" } .fa-pound-sign:before { content: \"\\f154\" } .fa-power-off:before { content: \"\\f011\" } .fa-pray:before { content: \"\\f683\" } .fa-praying-hands:before { content: \"\\f684\" } .fa-prescription:before { content: \"\\f5b1\" } .fa-prescription-bottle:before { content: \"\\f485\" } .fa-prescription-bottle-alt:before { content: \"\\f486\" } .fa-print:before { content: \"\\f02f\" } .fa-procedures:before { content: \"\\f487\" } .fa-product-hunt:before { content: \"\\f288\" } .fa-project-diagram:before { content: \"\\f542\" } .fa-pushed:before { content: \"\\f3e1\" } .fa-puzzle-piece:before { content: \"\\f12e\" } .fa-python:before { content: \"\\f3e2\" } .fa-qq:before { content: \"\\f1d6\" } .fa-qrcode:before { content: \"\\f029\" } .fa-question:before { content: \"\\f128\" } .fa-question-circle:before { content: \"\\f059\" } .fa-quidditch:before { content: \"\\f458\" } .fa-quinscape:before { content: \"\\f459\" } .fa-quora:before { content: \"\\f2c4\" } .fa-quote-left:before { content: \"\\f10d\" } .fa-quote-right:before { content: \"\\f10e\" } .fa-quran:before { content: \"\\f687\" } .fa-r-project:before { content: \"\\f4f7\" } .fa-random:before { content: \"\\f074\" } .fa-ravelry:before { content: \"\\f2d9\" } .fa-react:before { content: \"\\f41b\" } .fa-readme:before { content: \"\\f4d5\" } .fa-rebel:before { content: \"\\f1d0\" } .fa-receipt:before { content: \"\\f543\" } .fa-recycle:before { content: \"\\f1b8\" } .fa-red-river:before { content: \"\\f3e3\" } .fa-reddit:before { content: \"\\f1a1\" } .fa-reddit-alien:before { content: \"\\f281\" } .fa-reddit-square:before { content: \"\\f1a2\" } .fa-redo:before { content: \"\\f01e\" } .fa-redo-alt:before { content: \"\\f2f9\" } .fa-registered:before { content: \"\\f25d\" } .fa-rendact:before { content: \"\\f3e4\" } .fa-renren:before { content: \"\\f18b\" } .fa-reply:before { content: \"\\f3e5\" } .fa-reply-all:before { content: \"\\f122\" } .fa-replyd:before { content: \"\\f3e6\" } .fa-researchgate:before { content: \"\\f4f8\" } .fa-resolving:before { content: \"\\f3e7\" } .fa-retweet:before { content: \"\\f079\" } .fa-rev:before { content: \"\\f5b2\" } .fa-ribbon:before { content: \"\\f4d6\" } .fa-ring:before { content: \"\\f70b\" } .fa-road:before { content: \"\\f018\" } .fa-robot:before { content: \"\\f544\" } .fa-rocket:before { content: \"\\f135\" } .fa-rocketchat:before { content: \"\\f3e8\" } .fa-rockrms:before { content: \"\\f3e9\" } .fa-route:before { content: \"\\f4d7\" } .fa-rss:before { content: \"\\f09e\" } .fa-rss-square:before { content: \"\\f143\" } .fa-ruble-sign:before { content: \"\\f158\" } .fa-ruler:before { content: \"\\f545\" } .fa-ruler-combined:before { content: \"\\f546\" } .fa-ruler-horizontal:before { content: \"\\f547\" } .fa-ruler-vertical:before { content: \"\\f548\" } .fa-running:before { content: \"\\f70c\" } .fa-rupee-sign:before { content: \"\\f156\" } .fa-sad-cry:before { content: \"\\f5b3\" } .fa-sad-tear:before { content: \"\\f5b4\" } .fa-safari:before { content: \"\\f267\" } .fa-sass:before { content: \"\\f41e\" } .fa-save:before { content: \"\\f0c7\" } .fa-schlix:before { content: \"\\f3ea\" } .fa-school:before { content: \"\\f549\" } .fa-screwdriver:before { content: \"\\f54a\" } .fa-scribd:before { content: \"\\f28a\" } .fa-scroll:before { content: \"\\f70e\" } .fa-search:before { content: \"\\f002\" } .fa-search-dollar:before { content: \"\\f688\" } .fa-search-location:before { content: \"\\f689\" } .fa-search-minus:before { content: \"\\f010\" } .fa-search-plus:before { content: \"\\f00e\" } .fa-searchengin:before { content: \"\\f3eb\" } .fa-seedling:before { content: \"\\f4d8\" } .fa-sellcast:before { content: \"\\f2da\" } .fa-sellsy:before { content: \"\\f213\" } .fa-server:before { content: \"\\f233\" } .fa-servicestack:before { content: \"\\f3ec\" } .fa-shapes:before { content: \"\\f61f\" } .fa-share:before { content: \"\\f064\" } .fa-share-alt:before { content: \"\\f1e0\" } .fa-share-alt-square:before { content: \"\\f1e1\" } .fa-share-square:before { content: \"\\f14d\" } .fa-shekel-sign:before { content: \"\\f20b\" } .fa-shield-alt:before { content: \"\\f3ed\" } .fa-ship:before { content: \"\\f21a\" } .fa-shipping-fast:before { content: \"\\f48b\" } .fa-shirtsinbulk:before { content: \"\\f214\" } .fa-shoe-prints:before { content: \"\\f54b\" } .fa-shopping-bag:before { content: \"\\f290\" } .fa-shopping-basket:before { content: \"\\f291\" } .fa-shopping-cart:before { content: \"\\f07a\" } .fa-shopware:before { content: \"\\f5b5\" } .fa-shower:before { content: \"\\f2cc\" } .fa-shuttle-van:before { content: \"\\f5b6\" } .fa-sign:before { content: \"\\f4d9\" } .fa-sign-in-alt:before { content: \"\\f2f6\" } .fa-sign-language:before { content: \"\\f2a7\" } .fa-sign-out-alt:before { content: \"\\f2f5\" } .fa-signal:before { content: \"\\f012\" } .fa-signature:before { content: \"\\f5b7\" } .fa-simplybuilt:before { content: \"\\f215\" } .fa-sistrix:before { content: \"\\f3ee\" } .fa-sitemap:before { content: \"\\f0e8\" } .fa-sith:before { content: \"\\f512\" } .fa-skull:before { content: \"\\f54c\" } .fa-skull-crossbones:before { content: \"\\f714\" } .fa-skyatlas:before { content: \"\\f216\" } .fa-skype:before { content: \"\\f17e\" } .fa-slack:before { content: \"\\f198\" } .fa-slack-hash:before { content: \"\\f3ef\" } .fa-slash:before { content: \"\\f715\" } .fa-sliders-h:before { content: \"\\f1de\" } .fa-slideshare:before { content: \"\\f1e7\" } .fa-smile:before { content: \"\\f118\" } .fa-smile-beam:before { content: \"\\f5b8\" } .fa-smile-wink:before { content: \"\\f4da\" } .fa-smoking:before { content: \"\\f48d\" } .fa-smoking-ban:before { content: \"\\f54d\" } .fa-snapchat:before { content: \"\\f2ab\" } .fa-snapchat-ghost:before { content: \"\\f2ac\" } .fa-snapchat-square:before { content: \"\\f2ad\" } .fa-snowflake:before { content: \"\\f2dc\" } .fa-socks:before { content: \"\\f696\" } .fa-solar-panel:before { content: \"\\f5ba\" } .fa-sort:before { content: \"\\f0dc\" } .fa-sort-alpha-down:before { content: \"\\f15d\" } .fa-sort-alpha-up:before { content: \"\\f15e\" } .fa-sort-amount-down:before { content: \"\\f160\" } .fa-sort-amount-up:before { content: \"\\f161\" } .fa-sort-down:before { content: \"\\f0dd\" } .fa-sort-numeric-down:before { content: \"\\f162\" } .fa-sort-numeric-up:before { content: \"\\f163\" } .fa-sort-up:before { content: \"\\f0de\" } .fa-soundcloud:before { content: \"\\f1be\" } .fa-spa:before { content: \"\\f5bb\" } .fa-space-shuttle:before { content: \"\\f197\" } .fa-speakap:before { content: \"\\f3f3\" } .fa-spider:before { content: \"\\f717\" } .fa-spinner:before { content: \"\\f110\" } .fa-splotch:before { content: \"\\f5bc\" } .fa-spotify:before { content: \"\\f1bc\" } .fa-spray-can:before { content: \"\\f5bd\" } .fa-square:before { content: \"\\f0c8\" } .fa-square-full:before { content: \"\\f45c\" } .fa-square-root-alt:before { content: \"\\f698\" } .fa-squarespace:before { content: \"\\f5be\" } .fa-stack-exchange:before { content: \"\\f18d\" } .fa-stack-overflow:before { content: \"\\f16c\" } .fa-stamp:before { content: \"\\f5bf\" } .fa-star:before { content: \"\\f005\" } .fa-star-and-crescent:before { content: \"\\f699\" } .fa-star-half:before { content: \"\\f089\" } .fa-star-half-alt:before { content: \"\\f5c0\" } .fa-star-of-david:before { content: \"\\f69a\" } .fa-star-of-life:before { content: \"\\f621\" } .fa-staylinked:before { content: \"\\f3f5\" } .fa-steam:before { content: \"\\f1b6\" } .fa-steam-square:before { content: \"\\f1b7\" } .fa-steam-symbol:before { content: \"\\f3f6\" } .fa-step-backward:before { content: \"\\f048\" } .fa-step-forward:before { content: \"\\f051\" } .fa-stethoscope:before { content: \"\\f0f1\" } .fa-sticker-mule:before { content: \"\\f3f7\" } .fa-sticky-note:before { content: \"\\f249\" } .fa-stop:before { content: \"\\f04d\" } .fa-stop-circle:before { content: \"\\f28d\" } .fa-stopwatch:before { content: \"\\f2f2\" } .fa-store:before { content: \"\\f54e\" } .fa-store-alt:before { content: \"\\f54f\" } .fa-strava:before { content: \"\\f428\" } .fa-stream:before { content: \"\\f550\" } .fa-street-view:before { content: \"\\f21d\" } .fa-strikethrough:before { content: \"\\f0cc\" } .fa-stripe:before { content: \"\\f429\" } .fa-stripe-s:before { content: \"\\f42a\" } .fa-stroopwafel:before { content: \"\\f551\" } .fa-studiovinari:before { content: \"\\f3f8\" } .fa-stumbleupon:before { content: \"\\f1a4\" } .fa-stumbleupon-circle:before { content: \"\\f1a3\" } .fa-subscript:before { content: \"\\f12c\" } .fa-subway:before { content: \"\\f239\" } .fa-suitcase:before { content: \"\\f0f2\" } .fa-suitcase-rolling:before { content: \"\\f5c1\" } .fa-sun:before { content: \"\\f185\" } .fa-superpowers:before { content: \"\\f2dd\" } .fa-superscript:before { content: \"\\f12b\" } .fa-supple:before { content: \"\\f3f9\" } .fa-surprise:before { content: \"\\f5c2\" } .fa-swatchbook:before { content: \"\\f5c3\" } .fa-swimmer:before { content: \"\\f5c4\" } .fa-swimming-pool:before { content: \"\\f5c5\" } .fa-synagogue:before { content: \"\\f69b\" } .fa-sync:before { content: \"\\f021\" } .fa-sync-alt:before { content: \"\\f2f1\" } .fa-syringe:before { content: \"\\f48e\" } .fa-table:before { content: \"\\f0ce\" } .fa-table-tennis:before { content: \"\\f45d\" } .fa-tablet:before { content: \"\\f10a\" } .fa-tablet-alt:before { content: \"\\f3fa\" } .fa-tablets:before { content: \"\\f490\" } .fa-tachometer-alt:before { content: \"\\f3fd\" } .fa-tag:before { content: \"\\f02b\" } .fa-tags:before { content: \"\\f02c\" } .fa-tape:before { content: \"\\f4db\" } .fa-tasks:before { content: \"\\f0ae\" } .fa-taxi:before { content: \"\\f1ba\" } .fa-teamspeak:before { content: \"\\f4f9\" } .fa-teeth:before { content: \"\\f62e\" } .fa-teeth-open:before { content: \"\\f62f\" } .fa-telegram:before { content: \"\\f2c6\" } .fa-telegram-plane:before { content: \"\\f3fe\" } .fa-tencent-weibo:before { content: \"\\f1d5\" } .fa-terminal:before { content: \"\\f120\" } .fa-text-height:before { content: \"\\f034\" } .fa-text-width:before { content: \"\\f035\" } .fa-th:before { content: \"\\f00a\" } .fa-th-large:before { content: \"\\f009\" } .fa-th-list:before { content: \"\\f00b\" } .fa-the-red-yeti:before { content: \"\\f69d\" } .fa-theater-masks:before { content: \"\\f630\" } .fa-themeco:before { content: \"\\f5c6\" } .fa-themeisle:before { content: \"\\f2b2\" } .fa-thermometer:before { content: \"\\f491\" } .fa-thermometer-empty:before { content: \"\\f2cb\" } .fa-thermometer-full:before { content: \"\\f2c7\" } .fa-thermometer-half:before { content: \"\\f2c9\" } .fa-thermometer-quarter:before { content: \"\\f2ca\" } .fa-thermometer-three-quarters:before { content: \"\\f2c8\" } .fa-thumbs-down:before { content: \"\\f165\" } .fa-thumbs-up:before { content: \"\\f164\" } .fa-thumbtack:before { content: \"\\f08d\" } .fa-ticket-alt:before { content: \"\\f3ff\" } .fa-times:before { content: \"\\f00d\" } .fa-times-circle:before { content: \"\\f057\" } .fa-tint:before { content: \"\\f043\" } .fa-tint-slash:before { content: \"\\f5c7\" } .fa-tired:before { content: \"\\f5c8\" } .fa-toggle-off:before { content: \"\\f204\" } .fa-toggle-on:before { content: \"\\f205\" } .fa-toilet-paper:before { content: \"\\f71e\" } .fa-toolbox:before { content: \"\\f552\" } .fa-tooth:before { content: \"\\f5c9\" } .fa-torah:before { content: \"\\f6a0\" } .fa-torii-gate:before { content: \"\\f6a1\" } .fa-tractor:before { content: \"\\f722\" } .fa-trade-federation:before { content: \"\\f513\" } .fa-trademark:before { content: \"\\f25c\" } .fa-traffic-light:before { content: \"\\f637\" } .fa-train:before { content: \"\\f238\" } .fa-transgender:before { content: \"\\f224\" } .fa-transgender-alt:before { content: \"\\f225\" } .fa-trash:before { content: \"\\f1f8\" } .fa-trash-alt:before { content: \"\\f2ed\" } .fa-tree:before { content: \"\\f1bb\" } .fa-trello:before { content: \"\\f181\" } .fa-tripadvisor:before { content: \"\\f262\" } .fa-trophy:before { content: \"\\f091\" } .fa-truck:before { content: \"\\f0d1\" } .fa-truck-loading:before { content: \"\\f4de\" } .fa-truck-monster:before { content: \"\\f63b\" } .fa-truck-moving:before { content: \"\\f4df\" } .fa-truck-pickup:before { content: \"\\f63c\" } .fa-tshirt:before { content: \"\\f553\" } .fa-tty:before { content: \"\\f1e4\" } .fa-tumblr:before { content: \"\\f173\" } .fa-tumblr-square:before { content: \"\\f174\" } .fa-tv:before { content: \"\\f26c\" } .fa-twitch:before { content: \"\\f1e8\" } .fa-twitter:before { content: \"\\f099\" } .fa-twitter-square:before { content: \"\\f081\" } .fa-typo3:before { content: \"\\f42b\" } .fa-uber:before { content: \"\\f402\" } .fa-uikit:before { content: \"\\f403\" } .fa-umbrella:before { content: \"\\f0e9\" } .fa-umbrella-beach:before { content: \"\\f5ca\" } .fa-underline:before { content: \"\\f0cd\" } .fa-undo:before { content: \"\\f0e2\" } .fa-undo-alt:before { content: \"\\f2ea\" } .fa-uniregistry:before { content: \"\\f404\" } .fa-universal-access:before { content: \"\\f29a\" } .fa-university:before { content: \"\\f19c\" } .fa-unlink:before { content: \"\\f127\" } .fa-unlock:before { content: \"\\f09c\" } .fa-unlock-alt:before { content: \"\\f13e\" } .fa-untappd:before { content: \"\\f405\" } .fa-upload:before { content: \"\\f093\" } .fa-usb:before { content: \"\\f287\" } .fa-user:before { content: \"\\f007\" } .fa-user-alt:before { content: \"\\f406\" } .fa-user-alt-slash:before { content: \"\\f4fa\" } .fa-user-astronaut:before { content: \"\\f4fb\" } .fa-user-check:before { content: \"\\f4fc\" } .fa-user-circle:before { content: \"\\f2bd\" } .fa-user-clock:before { content: \"\\f4fd\" } .fa-user-cog:before { content: \"\\f4fe\" } .fa-user-edit:before { content: \"\\f4ff\" } .fa-user-friends:before { content: \"\\f500\" } .fa-user-graduate:before { content: \"\\f501\" } .fa-user-injured:before { content: \"\\f728\" } .fa-user-lock:before { content: \"\\f502\" } .fa-user-md:before { content: \"\\f0f0\" } .fa-user-minus:before { content: \"\\f503\" } .fa-user-ninja:before { content: \"\\f504\" } .fa-user-plus:before { content: \"\\f234\" } .fa-user-secret:before { content: \"\\f21b\" } .fa-user-shield:before { content: \"\\f505\" } .fa-user-slash:before { content: \"\\f506\" } .fa-user-tag:before { content: \"\\f507\" } .fa-user-tie:before { content: \"\\f508\" } .fa-user-times:before { content: \"\\f235\" } .fa-users:before { content: \"\\f0c0\" } .fa-users-cog:before { content: \"\\f509\" } .fa-ussunnah:before { content: \"\\f407\" } .fa-utensil-spoon:before { content: \"\\f2e5\" } .fa-utensils:before { content: \"\\f2e7\" } .fa-vaadin:before { content: \"\\f408\" } .fa-vector-square:before { content: \"\\f5cb\" } .fa-venus:before { content: \"\\f221\" } .fa-venus-double:before { content: \"\\f226\" } .fa-venus-mars:before { content: \"\\f228\" } .fa-viacoin:before { content: \"\\f237\" } .fa-viadeo:before { content: \"\\f2a9\" } .fa-viadeo-square:before { content: \"\\f2aa\" } .fa-vial:before { content: \"\\f492\" } .fa-vials:before { content: \"\\f493\" } .fa-viber:before { content: \"\\f409\" } .fa-video:before { content: \"\\f03d\" } .fa-video-slash:before { content: \"\\f4e2\" } .fa-vihara:before { content: \"\\f6a7\" } .fa-vimeo:before { content: \"\\f40a\" } .fa-vimeo-square:before { content: \"\\f194\" } .fa-vimeo-v:before { content: \"\\f27d\" } .fa-vine:before { content: \"\\f1ca\" } .fa-vk:before { content: \"\\f189\" } .fa-vnv:before { content: \"\\f40b\" } .fa-volleyball-ball:before { content: \"\\f45f\" } .fa-volume-down:before { content: \"\\f027\" } .fa-volume-mute:before { content: \"\\f6a9\" } .fa-volume-off:before { content: \"\\f026\" } .fa-volume-up:before { content: \"\\f028\" } .fa-vuejs:before { content: \"\\f41f\" } .fa-walking:before { content: \"\\f554\" } .fa-wallet:before { content: \"\\f555\" } .fa-warehouse:before { content: \"\\f494\" } .fa-weebly:before { content: \"\\f5cc\" } .fa-weibo:before { content: \"\\f18a\" } .fa-weight:before { content: \"\\f496\" } .fa-weight-hanging:before { content: \"\\f5cd\" } .fa-weixin:before { content: \"\\f1d7\" } .fa-whatsapp:before { content: \"\\f232\" } .fa-whatsapp-square:before { content: \"\\f40c\" } .fa-wheelchair:before { content: \"\\f193\" } .fa-whmcs:before { content: \"\\f40d\" } .fa-wifi:before { content: \"\\f1eb\" } .fa-wikipedia-w:before { content: \"\\f266\" } .fa-wind:before { content: \"\\f72e\" } .fa-window-close:before { content: \"\\f410\" } .fa-window-maximize:before { content: \"\\f2d0\" } .fa-window-minimize:before { content: \"\\f2d1\" } .fa-window-restore:before { content: \"\\f2d2\" } .fa-windows:before { content: \"\\f17a\" } .fa-wine-bottle:before { content: \"\\f72f\" } .fa-wine-glass:before { content: \"\\f4e3\" } .fa-wine-glass-alt:before { content: \"\\f5ce\" } .fa-wix:before { content: \"\\f5cf\" } .fa-wizards-of-the-coast:before { content: \"\\f730\" } .fa-wolf-pack-battalion:before { content: \"\\f514\" } .fa-won-sign:before { content: \"\\f159\" } .fa-wordpress:before { content: \"\\f19a\" } .fa-wordpress-simple:before { content: \"\\f411\" } .fa-wpbeginner:before { content: \"\\f297\" } .fa-wpexplorer:before { content: \"\\f2de\" } .fa-wpforms:before { content: \"\\f298\" } .fa-wrench:before { content: \"\\f0ad\" } .fa-x-ray:before { content: \"\\f497\" } .fa-xbox:before { content: \"\\f412\" } .fa-xing:before { content: \"\\f168\" } .fa-xing-square:before { content: \"\\f169\" } .fa-y-combinator:before { content: \"\\f23b\" } .fa-yahoo:before { content: \"\\f19e\" } .fa-yandex:before { content: \"\\f413\" } .fa-yandex-international:before { content: \"\\f414\" } .fa-yelp:before { content: \"\\f1e9\" } .fa-yen-sign:before { content: \"\\f157\" } .fa-yin-yang:before { content: \"\\f6ad\" } .fa-yoast:before { content: \"\\f2b1\" } .fa-youtube:before { content: \"\\f167\" } .fa-youtube-square:before { content: \"\\f431\" } .fa-zhihu:before { content: \"\\f63f\" } .sr-only { border: 0; clip: rect(0,0,0,0); height: 1px; margin: -1px; overflow: hidden; padding: 0; position: absolute; width: 1px } .sr-only-focusable:active,.sr-only-focusable:focus { clip: auto; height: auto; margin: 0; overflow: visible; position: static; width: auto } @font-face { font-family: \"Font Awesome 5 Brands\"; font-style: normal; font-weight: normal; src: url(./webfonts/fa-brands-400.eot); src: url(./webfonts/fa-brands-400.eot?#iefix) format(\"embedded-opentype\"),url(./webfonts/fa-brands-400.woff2) format(\"woff2\"),url(./webfonts/fa-brands-400.woff) format(\"woff\"),url(./webfonts/fa-brands-400.ttf) format(\"truetype\"),url(./webfonts/fa-brands-400.svg#fontawesome) format(\"svg\") } .fab { font-family: \"Font Awesome 5 Brands\" } @font-face { font-family: \"Font Awesome 5 Free\"; font-style: normal; font-weight: 400; src: url(./webfonts/fa-regular-400.eot); src: url(./webfonts/fa-regular-400.eot?#iefix) format(\"embedded-opentype\"),url(./webfonts/fa-regular-400.woff2) format(\"woff2\"),url(./webfonts/fa-regular-400.woff) format(\"woff\"),url(./webfonts/fa-regular-400.ttf) format(\"truetype\"),url(./webfonts/fa-regular-400.svg#fontawesome) format(\"svg\") } .far { font-weight: 400 } @font-face { font-family: \"Font Awesome 5 Free\"; font-style: normal; font-weight: 900; src: url(./webfonts/fa-solid-900.eot); src: url(./webfonts/fa-solid-900.eot?#iefix) format(\"embedded-opentype\"),url(./webfonts/fa-solid-900.woff2) format(\"woff2\"),url(./webfonts/fa-solid-900.woff) format(\"woff\"),url(./webfonts/fa-solid-900.ttf) format(\"truetype\"),url(./webfonts/fa-solid-900.svg#fontawesome) format(\"svg\") } .fa,.far,.fas { font-family: \"Font Awesome 5 Free\" } .fa,.fas { font-weight: 900 }","link":"/icons/all.css"}],"posts":[{"title":"JavaScript 的 new 操作符","text":"JavaScript 的 new 操作符都做了些什么？如何用一个函数来模拟 new 呢？ 官方文档官方文档第一段中的说法： new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象（即 {}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤 1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this 。 官方文档在 “描述” 章节中的说法： 当代码 new Foo(...) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 要点根据上面两段描述，可以整理出以下要点： 使用 new 来调用时，构造函数的上下文的 this 是一个新创建的对象，继承自构造函数的原型（prototype） 当构造函数的返回值是一个对象的时候，返回这个对象，否则返回用作 this 的那个对象 根据这两个要点，可以用函数来表示 new 操作符的逻辑。 函数表示12345678function newOperator(Constructor, args) { const thisValue = Object.create(Constructor.prototype); const returnValue = Constructor.apply(thisValue, args); if (typeof returnValue === 'object' &amp;&amp; returnValue !== null) { return returnValue; } return thisValue;} 相关要点创建一个继承自特定对象的新对象最简单粗暴的方式是，创建一个对象，并且将原型指向继承的那个对象： 12const newObject = {};newObject.__proto__ = parentObject; 不过 JavaScript 不推荐直接使用 __proto__（下面会说），并且为我们提供了这样一个函数： 1Object.create(proto, [propertiesObject]); 参数： proto - 作为新创建对象的原型的对象 propertiesObject - 可选参数。如果提供，将作为 Object.defineProperties() 的参数来使用 不推荐直接使用 __proto__来自官方文档的警告： 警告：通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性, 这种行为在每一个 JavaScript 引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 obj.__proto__ = ... 语句上, 它还会影响到所有继承来自该 [[Prototype]] 的对象，如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]。相反, 创建一个新的且可以继承 [[Prototype]] 的对象，推荐使用 Object.create()。 警告：当Object.prototype.__proto__ 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在 ECMAScript 2015 规范中被标准化为传统功能，以确保 Web 浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。 Object.prototype 的 __proto__ 属性是一个访问器属性（一个 getter 函数和一个 setter 函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 null)。 简单来说，官方不推荐直接修改或者访问 __proto__ 属性，修改会有性能问题，如果要创建包含继承关系的对象，推荐用 Object.create()，如果要访问原型，建议只使用 Object.getPrototypeOf()。","link":"/2019/05/22/js-new-operator/"},{"title":"JavaScript 中的闭包（Closures）","text":"什么是闭包？哪里用得到闭包？ 闭包是函数和声明该函数的词法环境的组合。 什么是闭包？ 闭包是函数和声明该函数的词法环境的组合。 —- JavaScript Reference 词法作用域考虑如下情况： 123456789function init() { var name = 'Mozilla'; // name 是 init 函数的局部变量 // displayName() 是一个内部函数，是一个闭包 function displayName() { console.log(name); // 使用了外部函数中的变量 } displayName();}init(); 这个例子说明词法作用域的范围，函数的词法作用域包括了函数自身的作用域以及定义该函数的位置的作用域。也就是说，函数可以访问在其上层作用域中定义的变量。 作用域对象每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。这与那些保存的所有全局变量和函数的全局对象（global object）类似，但仍有一些很重要的区别，第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；第二，与全局对象（在浏览器里面是当做 window 对象来访问的）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有可以遍历当前的作用域对象里面属性的方法。 一个闭包就是一个函数和其外层函数的作用域对象的组合。 闭包再看一下这个例子： 123456789function makeFunc() { var name = 'Mozilla'; function displayName() { console.log(name); } return displayName;}var myFunc = makeFunc();myFunc(); 在这个例子中，内部函数并没有直接执行，而是被外部函数返回。这个例子在 JavaScript 中是可行的。但是在一些其它的编程语言中，函数中的局部变量仅函数的其执行期可用，一旦函数执行完毕，函数中的局部变量将被销毁。但其实变量销毁的逻辑其实是一样的，都为了节省内存，在变量不可再被访问时，进行销毁。（比如这些语言的局部变量一定是在函数执行完毕就无法再被访问了，又比如一些语言的引用计数方式的 GC） 由于 JavaScript 中的函数会形成闭包，闭包可以访问其外层作用域，所以只要这些函数还能被访问到，外层作用域的变量就不会被销毁。由于我们还持有 myFunc（等同于 displayName，一个可以访问 name 变量的闭包），所以 name 变量不会被销毁。 下面是一个更有意思的例子： 1234567891011function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 在这个例子中，add5 和 add10 共享函数定义，但是各自有不同的词法环境。add5 的环境中，x 为 5，而 add10 中，x 为 10。 闭包的用处闭包是一个很有用的特性，因为他可以将函数和其定义的环境联系起来。这个面向对象编程中，对象允许将其方法和其属性与其它方法联系起来有些相像。 函数工厂在上面那个例子中，我们可以看到闭包的一种用法：函数工厂。根据不同参数，创建行为具有相同规则但是又不相同的函数，例如创建可以修改字体大小的函数，并且绑定到不同事件上面去： 123456789function fontSizeSetter(size) { return function() { document.body.style.fontSize = size + 'px'; };}document.getElementById('font-size-12').onClick = fontSizeSetter(12);document.getElementById('font-size-14').onClick = fontSizeSetter(14);document.getElementById('font-size-16').onClick = fontSizeSetter(16); 模拟私有变量与方法JavaScript 不像 Java 等一些其它语言，JavaScript 无法定义私有的变量或方法（即只能被同一个类访问的变量或方法）。 但是通过闭包，我们可以模拟相同的效果。例如： 123456789101112131415161718192021222324var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } };})();console.log(Counter.value()); // 0Counter.increment();Counter.increment();console.log(Counter.value()); // 2Counter.decrement();console.log(Counter.value()); // 1 这个例子中，Counter 对象有三个方法：increment、decrement 和 value，并且除了这三个方法，没有地方再可以访问 privateCounter 与 changeBy。 像这种通过闭包来定义公共函数，并使其可以访问私有变量和函数的方式，通常被称为模块模式（Module Pattern）。 再举一个更加面向对象一些的例子： 123456789101112131415161718192021222324function Counter(initValue) { var privateCounter = initValue || 0; return { increment() { privateCounter += 1; return this; }, decrement() { privateCounter -= 1; return this; }, get value() { return privateCounter; } };}const counter1 = new Counter();counter1.increment().increment().value; // 2counter1.decrement().value; // 1const counter2 = new Counter(counter1.value);counter2.increment().value; // 2counter2.increment().decrement().value; // 2 运用 class 语法的版本： 123456789101112131415161718class Counter { constructor(initValue = 0) { let privateCounter = initValue; function makeChainableChanger(value) { return function() { privateCounter += value; return this; }; } return { increment: makeChainableChanger(1), decrement: makeChainableChanger(-1), get value() { return privateCounter; } }; }} 闭包的常见错误在 ECMAScript 2015 引入 let 关键字之前，在循环中有一个常见的闭包创建问题。 示例如下： 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 这个例子中，每个循环创建了一个闭包，由于在循环中被创建，这 3 个闭包共享了相同的词法环境（循环的词法环境），在这些闭包被调用时，循环早已结束，词法环境中的 item 已经指向了 helpText 的最后一项。 解决这个问题有很多种办法，比如可以通过引入更多闭包解决： 123456789101112131415161718192021222324function showHelp(help) { document.getElementById('help').innerHTML = help;}function showHelpCallback(item) { return function() { showHelp(item.help); };}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = showHelpCallback(item); }}setupHelp(); 或者使用匿名闭包： 12345678910111213141516171819202122function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { (function() { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; })(); }}setupHelp(); 而更好的方法是，使用 let 关键词将变量声明到块作用域（循环的块作用域是每一次循环独立的）而不是整个循环上。（所以在很多项目的规范中，要求永远不要使用 var 关键词） 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { const helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (let i = 0; i &lt; helpText.length; i++) { let item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 性能考量 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。 —- JavaScript Reference 考虑以下示例： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; };} 在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();}MyObject.prototype.getName = function() { return this.name;};MyObject.prototype.getMessage = function() { return this.message;};","link":"/2019/05/23/js-closures/"},{"title":"JavaScript 中的相等性判断","text":"JavaScript 中提供了三种不同的值比较操作： 严格相等（”Strict Equality Comparison”, or “Identity”）：=== 宽松相等（”Abstract Equality Comparision”, or “Loose Equality”）：== 同值判断（”SameValue”）：Object.is（ECMAScript 2015 新特性） 而 ECMAScript 2015 中的相等算法则分为四种： 非严格相等比较（==） 严格相等比较（===），用于 Array.prototype.indexOf，Array.prototype.lastIndexOf 以及 switch...case 同值（Object.is） 同值零（”SameValueZero”），用于 %TypedArray% 和 ArrayBuffer 的构造函数，Map 和 Set 操作，以及 ECMAScript 2016 中的 String.prototype.includes 中 简而言之， == 将进行类型转换并比较 === 不会进行类型转换，比较两个值是否相同（如果类型不同，则总是返回 false） Object.is 的行为与 === 相同，但是对于 NaN，-0 和 +0 进行了特殊处理，Object.is(+0, -0) 为 false，而 Object.is(NaN, NaN) 为 true（根据 IEEE 754, 使用 == 或 === 比较两个 NaN 结果将为 false） “SameValueZero” 与 Object.is 类似，但认为 -0 和 +0 是相等的 而以上这些比较，虽然结果有所区别，但均属于判断两个值是否相同。对于两个不同的非原始对象，以上判断的结果都是 false。 严格相等 ===全等操作符（===）比较两个值是否相等，被比较的值不会进行隐式类型转换，判断逻辑如下： 如果两个值具有不同的类型，则不全等 如果两个值具有相同的类型和值，且不为 number 类型，则全等 如果两个值都是 number 类型，且不为 NaN，且数值相等，则全等 如果两个值都是 NaN，则不全等 如果两个值分别为 +0 和 -0，则全等 在日常使用中 === 几乎总是正确的。 对于数字之外的类型，全等操作符有明确的定义：一个值只与自身相等。 对于数字类型，定义稍加修改： 浮点数 0 是不分正负的，因为除了特定的数学问题，大部分情况都不关心 0 值的正负 浮点数包含 NaN 值，来表示定义不明确的数学问题的解（比如：正负无穷相加），=== 认为 NaN 和任何值都不相等，包括它自己 x !== x 成立的唯一条件就是 x 为 NaN，因此可以用来做 NaN 值判断 ECMA 规范中的定义：Section 11.9.6, The Strict Equality Algorithm 非严格相等 ==相等操作符（==）比较两个值是否相等，比较前将被比较的值转换为相同类型（等式的一边或两边都可能进行转换），然后进行 === 比较。相等操作符满足交换律。判断逻辑如下： 具有不同类型时： 如果两个值为 null 或 undefined，则相等 如果一个值为 null 或 undefined，另一个值为 number 或 string 或 boolean，则不相等 如果一个值为 null 或 undefined，另一个值为 object，则对 object 进行 “IsFalsy” 判断 如果一个值为 object，另一个值为 number 或 string，则对 object 进行 “ToPrimitive” 转换并判断是否全等 如果一个值为 object，另一个值为 boolean，则将 boolean 转换为 number 并对 object 进行 “ToPrimitive” 转换并判断是否全等 如果一个值为 number，另一个值为 string 或 boolean，则将另一个值转换为 number 并判断是否全等 如果一个值为 string，另一个值为 boolean，则都转换为 number 来判断 注： “ToPrimitive” 通过尝试调用 toString() 和 valueOf() 来将对象转换为原始值 转换为 number 的逻辑与一元 + 运算符相同 “IsFalsy” 判断：大部分浏览器允许非常窄的一类对象在某种情况下充当 undefined，仅当这种情况下，”IsFalsy” 判断为 true 有些开发者认为，最好永远都不要使用 ==，因为 == 的结果难以预测，且会进行隐式类型转换，=== 更加容易预测并更加快速。 ECMA 规范中的定义：Section 11.9.3, The Abstract Equality Algorithm 同值相等（”SameValue”）同值相等（”SameValue”）用于判断两个对象是否在任何情况下功能上是相同的，判断逻辑如下： 如果两个值具有不同的类型，则不同值相等 如果两个值具有相同的类型和值，且不为 number 类型，则同值相等 如果两个值都是 number 类型，且不为 NaN，且数值相等，则同值相等 如果两个值都是 NaN，则同值相等（与 === 相反） 如果两个值分别为 +0 和 -0，则不同值相等（与 === 相反） 比如 Object.defineProperty 在试图修改不可变属性的时候，如果值发生变化就会抛出异常，而值没有变化的话则什么都不做。这时就是用同值相等来判断值是否发生了变化。 1234567891011Object.defineProperty(Number, 'NEGATIVE_ZERO', { value: -0, writable: false, configurable: false, enumerable: false});function attemptMutation(v) { Object.defineProperty(Number, 'NEGATIVE_ZERO', { value: v });}attemptMutation(-0); // 不发生任何事情attemptMutation(+0); // 将抛出异常 这个算法在 ES5 中仅用于 JS 引擎的内部，ES6 中通过 Object.is 暴露了这个算法。 ECMA 规范中的定义：Section 9.12, The SameValue Algorithm 同值零相等（”SameValueZero”）同值零相等（”SameValueZero”）与同值相等类似，只是它认为 +0 和 -0 是相等的。 什么时候使用 Object.is？总的来说，除了对待 NaN 的方式不同，Object.is 与 === 的唯一区别就是对待 -0 和 +0 的不同。 下面这些方法和操作符会区别对待 -0 和 +0： 一元负号（Unary -） 一元负号在表达式的使用可能会无意识产生 -0，比如：obj.mass * - obj.velocity，如果 obj.mass 为 0，则会得到一个 -0 Math.atan2 Math.ceil Math.pow Math.round 这些函数即使参数中没有 -0，都有可能产生 -0 的结果 Math.floor Math.max Math.min Math.sin Math.sqrt Math.tan 这些函数当参数中有 -0 时，有可能产生 -0 的结果 ~ &lt;&lt; &gt;&gt; 这些操作符内部都使用了 ToInt32 算法。因为内部的 Int32 类型不区分 0 的正负，-0 在进行了这些操作后，不会保留负号。 因此在未考虑到 0 的符号的情况下使用 Object.is 可能得不到预期的效果。","link":"/2019/05/23/js-equality-and-sameness/"},{"title":"重新介绍 JavaScript（一）","text":"为什么会有这一篇 “重新介绍” 呢？因为 JavaScript 堪称世界上被人误解最深的编程语言。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤为必要。 本篇涉及类型、变量、运算符、对象以及数组。 与大多数编程语言不同，JavaScript 没有输入或输出的概念。它是一个在主机环境（host environment）下运行的脚本语言，任何与外界沟通的机制都是由主机环境提供的。浏览器是最常见的主机环境，但在非常多的其他程序中也包含 JavaScript 解释器，如 Adobe Acrobat、Photoshop、SVG 图像、Yahoo! 的 Widget 引擎，以及 Node.js 之类的服务器端环境。JavaScript 的实际应用远不止这些，除此之外还有 NoSQL 数据库（如开源的 Apache CouchDB）、嵌入式计算机，以及包括 GNOME （注：GNU/Linux 上最流行的 GUI 之一）在内的桌面环境等等。 —- JavaScript Reference 概览JavaScript 是一种面向对象的动态语言，包含了类型、运算符、内置对象和方法。语法源于 Java 和 C 语言。和 Java 的主要区别在于 JavaScript 不支持类，类的概念在 JavaScript 中通过对象原型与继承的方式来实现。JavaScript 支持函数式编程，因为 JavaScript 中函数也是一种对象，可以保存在变量中并当作参数传递。 类型JavaScript 的类型包括： Number（数字） String（字符串） Boolean（布尔值） Symbol（符号，ES6 新增的类型） Object（对象） Function（函数） Array（数组） Date（日期） RegExp（正则表达式） null（空值） undefined（未定义） 数字JavaScript 采用 IEEE 754 双精度 64 位数字表示法，并且不区分整数和浮点数类型，所有数字均为浮点数值（但是在具体实现时，整数通常被视为 32 位整型变量），所以在进行计算时需要特别注意，比如： 10.1 + 0.2 = 0.30000000000000004 JavaScript 的算数运算符包括加（+）、减（-）、乘（*）、除（/）、取余（%）以及乘方（**，ES7 新增的操作符）。 JavaScript 内置的 Math 对象用于处理更多的数学函数和常数。 可以使用内置函数 parseInt() 将字符串转换为整型。该函数的第二个参数表示字符串所表示数字的基（进制）： 12parseInt('123', 10); // 123parseInt('010', 10); // 10 如果调用时没有提供第二个参数（字符串所表示数字的基），则会根据字符串来确定进制，但是 2013 年以前的 JavaScript 实现会返回一个意外的结果： 12parseInt('010'); // 8parseInt('0x10'); // 16 因为旧版本的 JavaScript 会认为 '0' 开头的数字字符串是八进制，而新版本只会认为 '0o'开头的数字字符串是八进制。 还有其它方法可以将字符串转换成数字：一元加号 +、以及 Number 函数，它们两个的效果是一样的。 parseInt 和 parseFloat 方法会尝试逐个解析字符串中的字符，直到遇上一个无法被解析成数字的字符，然后返回该字符前所有数字字符组成的数字。而一元加号 + 和 Number 函数则是如果字符串中包含无法解析成数字的字符，结果都将会是 NaN。 字符串JavaScript 中的字符串是一串 Unicode 字符的序列。更准确地说，是 UTF-16 编码单元的序列，而每个 Unicode 字符由 1 或 2 个编码单元来表示。 字符串的方法无法区分 Unicode 字符，只能按照 UTF-16 编码单元来拆分字符串： 12const t = '😄😂';t.split('') === ['�', '�', '�', '�']; 而把字符串当作迭代器来使用的话，就可以根据 Unicode 字符来迭代字符串了： 12const t = '😄😂';[...t] === ['😄', '😂']; 其它类型JavaScript 中的 null 和 undefined 是不同的，前者代表空值（non-value），必须使用 null 关键字访问，后者是 “未定义” 类型的对象，表示未初始化的值，也就是尚未分配的值。 所有值都可以转换为布尔值，可能在判断中隐式转换或者使用 Boolean 函数显式转换，布尔值的转换规则为： false、0、空字符串 ''、NaN、null 和 undefined 被转换为 false 其它值都被转换为 true 变量在 JavaScript 中，可以通过 let、const 或 var 关键字来声明新变量。 let 语句可以声明一个块级作用域的变量，并可以使用一个值来初始化该变量。 12345let a;{ let name = 'Simon';}a = name; // 抛出异常，因为这里不可访问 name 变量 const 语句用于定义一个不可变的常量（对于对象类型的值，对象的成员仍然可能是可修改的）。const 语句必须指定一个值来初始化变量。 var 是最常见的声明变量的关键字。它没有其他两个关键字的种种限制。这是因为它是传统上在 JavaScript 声明变量的唯一方法。使用 var 声明的变量在它所声明的整个函数都是可见的。 JavaScript 与其他语言的（如 Java）的重要区别是在 JavaScript 中语句块（blocks）是没有作用域的，只有函数有作用域。因此如果在一个复合语句中（如 if 控制结构中）使用 var 声明一个变量，那么它的作用域是整个函数（复合语句在函数中）。 但是从 ES6 开始将有所不同的， let 和 const 关键字允许你创建块作用域的变量。 运算符二元加号 + 可以用来连接字符串，如果你用一个字符串加上一个数字（或其他值），那么操作数都会被首先转换为字符串。通过与空字符串相加，可以将某个变量快速转换成字符串类型。 对象JavaScript 的对象可以简单理解成键值对，与其它语言的一些概念类似： Python 中的字典 Perl 和 Ruby 的 Hash C/C++ 中的哈希表 Java 中的 HashMap PHP 中的关联数组 JavaScript 中，几乎一切都是对象，所以 JavaScript 程序必然与大量的散列表查找操作有着千丝万缕的联系，而散列表擅长的正是高速查找。 数组JavaScript 中的数组是一种特殊的对象。它的工作原理与普通对象类似（以数字为属性名，但只能通过 [] 来访问），但数组还有一个特殊的属性 —— length（长度）属性。这个属性的值通常比数组最大索引大 1。 注意，Array.length 并不总是等于数组中元素的个数，如下所示： 123var a = ['dog', 'cat', 'hen'];a[100] = 'fox';a.length; // 101 记住：数组的长度是比数组最大索引值多一的数。 数组的 push、pop、shift、unshift 方法可以数组头尾添加或删除元素（取出元素）。 数组的 splice(index, deleteCount, ...insertItems) 方法可以在数组指定位置删除或添加多个元素。 数组的 sort([cmpfn]) 方法可以依据 cmpfn 返回的结果进行排序，如果未指定比较函数则按字符顺序比较（即使元素是数字）。","link":"/2019/05/24/js-re-introduction-1/"},{"title":"Node.js 中的事件循环","text":"Node.js 中有一些用于稍后执行的函数，比如 setTimeout(fn, ms)，setImmediate(fn) 以及 process.nextTick(fn)。如何区分它们，将与 Node.js 的事件循环机制息息相关。 本文主要参考另一篇文章进行转述。 一些常见的误解 事件循环是 JS 引擎来处理的 最常见的误解就是，事件循环是 JavaScript 引擎（V8、SpiderMonkey 等）的一部分。实际上，事件循环只用到 JS 引擎来执行 JavaScript 代码。Node.js 的事件循环是由 libuv 来完成的。 有一个栈或者队列来管理回调函数 首先排除用栈，其次也不是一个单一的队列。这个过程是复杂的，有多个队列（比如数据结构中的队列）参与。 事件循环运行在一个单独的线程里面 因为一些错误的 Node.js 事件循环图，很多人认为有两个线程，一个执行 JavaScript 代码，另一个执行事件循环。事实上，这两个是在同一个线程执行的。 在 setTimeout 中有系统的参与 另一个非常大的误解是 setTimeout 的回调函数在给定的延迟完成之后被（可能是 OS 或者内核）推进一个队列。 setImmediate 将回调函数放在第一个位置 作为常见的事件循环描述只有一个队列，所以一些开发者认为 setImmediate 将回调放在工作队列的前面。然而这是不正确的。 事件循环的结构下图描述的是 Node.js 中的事件循环过程： 事件循环分为 6 个阶段，每个阶段负责特定的任务。每个阶段都有独立的队列（或其它用作队列的数据结构），JavaScript 代码可以在空闲/准备阶段之外的 5 个阶段执行。图中的 nextTick 队列与微任务队列不属于事件循环的一部分，而是在任何阶段都可以执行，它们有比事件循环更高的优先级。 计时器阶段（Timer） 计时器阶段是一个循环的开始，这个阶段处理计时器（setTimeout、setInterval）的回调。 计时器队列是一个最小堆，它用于保留计时器和其回调。计时器阶段会检查计时器队列中过期的计时器，并执行它们的回调。 I/O 回调阶段（Pending I/O Callbacks） 这个阶段执行 Pending Queue 中的回调。这些回调是在之前的操作中加入到队列的（一般是 I/O 操作完成时加入的）错误处理的回调也将在这里执行。 空闲/等待阶段（Idle, Prepare） 这个阶段主要执行 Node.js 的一些内部操作，暂时不讨论其内容。 轮询阶段（Poll） 这个阶段接受新传入的连接（建立 Socket 等等）和数据（读取文件等待）。这个阶段大致可以分成两个部分： 如果 Watch Queue 里面有任务，它们将依次被执行。 一旦队列空了，Node.js 就会等待新的连接或数据。等待的时间取决于多种因素（待会再看） 检查阶段（Check） 轮询阶段专门用于处理 setImmediate 设置的回调。 关闭回调（Close） 关闭回调都是在这里处理的，像一个清理的阶段。 nextTick 队列与微任务队列 nextTick 队列中保存 process.nextTick() 设置的回调。而微任务队列保存 Promise 中的回调。它们不属于事件循环（libuv）的一部分，而是 Node.js 的一部分。在 C/C++与 JavaScript 交叉的过程中，它们都是尽可能快地被调用（不一定是当前的回调完成时）。 事件循环的流程当你用 Node.js 执行一段 JavaScript 脚本时，Node.js 首先进行执行脚本前的准备（比如准备全局环境、初始化事件循环等），然后解析并执行代码（所有同步代码以及微任务将在这时候被执行），执行完代码，将检查循环是否还有事情要做（Alive），如果没有，将进入进程结束流程，否则将进入事件循环。 计时器阶段根据前面的描述，计时器阶段将检查过期的计时器并执行回调。 具体来说，计时器队列（最小堆）以时间升序来保存计时器。每次都检查堆顶的计时器是否过期，如果过期就取出队列并执行回调，否则直接进入下一个阶段（因为后面的计时器都一定没有过期）。 当然，事件循环的每个阶段执行的任务数量是有最大限制的，达到这个数量后，即使有过期的计时器也不会执行，直接进入下一阶段。 I/O 回调阶段I/O 回调阶段检查 Pending Queue 中是否有任务，如果有，依次执行，直到队列为空或者达到系统限制。 之后将进入空闲阶段（Idle），然后 Node.js 将做一些内部准备，并进入轮询阶段。 轮询阶段这个阶段首先检查 Watcher Queue 中是否有任务（比如文件读响应，Socket 连接请求、HTTP 连接请求等），如果有，将依次执行，直到队列为空或者达到系统限制。 如果没有要执行的回调，轮询阶段在某些条件下将等待一会儿。 如果关闭阶段、空闲阶段、I/O 回调阶段或者关闭阶段任意一个队列有任务在等待，则轮询阶段将等待 0ms，并进入检查阶段。 否则它将检查计时器队列的堆顶，并决定等待时间（如果已过期，则等待 0ms） 检查阶段这个阶段将执行被 setImmediate 设置的回调，直到队列为空或者达到系统限制。 关闭阶段这个阶段将执行处理关闭或者销毁的 close 回调。这个阶段完成后，将再次检查循环是否活着（还有任务要做）。如果没有，将退出事件循环，进入进程结束阶段；如果有，将再次进入计时器阶段。 nextTick 队列与微任务队列这两个队列会在一个阶段结束时尽可能快的运行。不像其他阶段，它们两个没有系统设置的最大限制，node 运行它们直到两个队列是空的。但是，nextTick 队列会比微任务队列有更高的任务优先级。 根据另一篇文章的解释，这两个队列会在每个阶段结束前按顺序执行，直到它们为空。 进程池（Thread Pool）一个普遍的误解是 Node.js 有一个处理所有异步操作的进程池。 实际上，进程池是 libuv 的一部分，但不属于事件循环机制的一部分。而且并不是每个任务都要被进程池处理。libuv 能够灵活运用操作系统的异步 API 来保持环境为事件驱动的。而操作系统的异步 API 无法处理的任务（比如：DNS 查询、文件读取等），将由进程池来处理。进程池默认有 4 个进程，可以通过环境变量 uv_threadpool_size 来设置它的进程数量（最多可设置 128 个）。 帮助理解的例子基础理解下面代码的打印顺序如何？ 123456setTimeout(() =&gt; { console.log('setTimeout');}, 0);setImmediate(() =&gt; { console.log('setImmediate');}); 你可能会认为是 ‘setTimeout’ 先被打印出来，或者 ‘setImmediate’ 先被打印出来。但是，这个例子的打印顺序是不确定的。因为在计时器阶段，可能不会检查到计时器过期。 首先，根据 Node.js 的文档，setTimeout 的延时小于 1ms 或者大于 2147483647ms 时，将重置为 1ms。进入计时器阶段时，会记录一个时间，然后根据执行代码时的系统性能表现，检查计时器时，可能已经经过了 1ms，也可能没有经过。所以在第一次循环 ‘setTimeout’ 不一定会被打印，而 ‘setImmediate’ 一定会被打印。 但是，如果这段代码位于 I/O 回调中的话，’setImmediate’ 一定会在 ‘setTimeout’ 之前被打印。 更好地理解计时器123456789101112let i = 0;const start = new Date();function foo() { i++; if (i &lt; 1000) { setImmediate(foo); } else { const end = new Date(); console.log('Execution time: ', end - start); }}foo(); 上面的例子是连续使用 setImmediate 设置回调，直到 i == 1000。在我的 Macbook Pro 上面用 Node.js 10.14.1 执行，大约需要 80ms。 把其中的 setImmediate 修改为 setTimeout： 123456789101112let i = 0;const start = new Date();function foo() { i++; if (i &lt; 1000) { setTimeout(foo, 0); } else { const end = new Date(); console.log('Execution time: ', end - start); }}foo(); 在同样的环境下执行修改后的代码，将需要约 1400ms 毫秒。 它们的差距在于，首先 setTimeout 至少会产生 1ms 的延时，其次 setTimeout 需要花一些时间来注册计时器，而计时器阶段的过期检查也需要一些开销。而再 setImmediate 的阶段，再回调中注册 setImmediate 将导致队列仍不为空，所以也不会跳出这一阶段（直到系统限制），将进行更少的循环，也节省了一些时间。 nextTick() 与计时器12345678910111213let i = 0;function foo() { i++; if (i &gt; 20) { return; } console.log('foo'); setTimeout(() =&gt; { console.log('setTimeout'); }, 0); process.nextTick(foo);}setTimeout(foo, 2); 上面的例子将输出 20 次 ‘foo’，再输出 20 次 ‘setTimeout’。2 秒后，连续进行nextTick() 调用，然后检查别的任务（setTimeout）。 所以是每个回调执行完之后，开始检查 nextTick 队列的吗？再看看下面的例子。 12345678910111213141516let i = 0;function foo() { i++; if (i &gt; 20) { return; } console.log('foo', i); setTimeout(() =&gt; { console.log('setTimeout', i); }, 0); process.nextTick(foo);}setTimeout(foo, 2);setTimeout(() =&gt; { console.log('Other setTimeout');}, 2); 这个例子很可能会在第一个 ‘foo’ 打印之后打印 ‘other setTimeout’。 相同的计时器分成一组，nextTick 队列会在这组回调执行完之后执行。 一些普遍的问题 JavaScript 代码是在哪里执行的？ 大多数人会认为事件循环有一个独立的线程执行，将回调推入一个队列，然后负责执行 JavaScript 的线程来依次执行。然而，事件循环和 JavaScript 的执行是同一个线程里的。所以，如果 JavaScript 代码不完成的话，事件循环不会向后走。 为什么有了 setTimeout(fn, 0) 还需要 setImmediate(fn)？ 因为 setTimeout(fn, 0) 的 0 不是 0ms，而是 1ms（因为至少要 1ms）。其次，setImmediate 可以减少额外的检查。而且 setImmediate 设置的回调将于轮询阶段的下一个阶段执行，因此用于 I/O 回调中，可以尽早执行。 为什么 setImmediate 与 process.nextTick 的意思相反？ 因为历史原因导致的命名问题。 如果在进程结束回调中使用 setTimeout 会如何？ 它也许会创建计时器，但是回调将不会被调用。因为这时已经结束了事件循环。","link":"/2019/05/27/node-event-loop/"},{"title":"自己实现一个 Promise 类","text":"自从 ES6 引入的 Promise 将我们从回调地狱中解放了出来，ES7 提出的 async/await 特性更是进一步地简化了异步代码的编写。 那么我们就通过自己实现一个 Promise 类，来一窥其内部的奥秘（本文将遵照 Promise/A+ 规范实现 Promise，并且添加一些常用的函数） 本文将新的 Promise 类命名为 Future（参考 Dart 中与 Promise 对应的概念的名称） 本文为了模拟 Promise 的微任务，使用 Node.js 的 process.nextTick 函数来产生微任务。并且本文将使用 ES2015+ 语法来实现。 基本实现首先我们不考虑结果为 Promise 或者 thenable 的情况。 构造器首先我们知道，Promise 的构造器需要传入一个函数（我们称为 executor），这个函数有 resolve、reject 两个参数，分别用于将 Promise 的状态设为成功（fulfilled）或者失败（rejected），并且如果这个函数抛出错误，Promise 也将失败。而 Promise 一开始就具有待定（pending）状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 属性常量 */const state = Symbol();const result = Symbol();/* 状态常量 */const PENDING = Symbol();const REJECTED = Symbol();const FULFILLED = Symbol();/* 工具函数 */// 设置不可枚举属性const defineProperty = (obj, key, value) =&gt; Object.defineProperty(obj, key, { value, writable: true, configurable: false, enumerable: false });class Future { constructor(executor) { // 参数检查 if (typeof executor !== 'function') { throw new Error('Future executor undefined is not a function'); } // 设置状态、结果属性 defineProperty(this, state, PENDING); defineProperty(this, result, undefined); // 成功处理函数 const resolveFunction = value =&gt; { if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; } }; // 失败处理函数 const rejectFunction = reason =&gt; { if (this[state] === PENDING) { this[state] = REJECTED; this[result] = reason; } }; try { executor(resolveFunction, rejectFunction); } catch (err) { rejectFunction(err); } }} 这里简化了 “私有” 属性的声明，使用私有 Symbol 作为不可枚举属性的名称，可以防止外部模块访问（实际上，使用 Object.getOwnPropertySymbols 仍然可以得到这些 Symbol，但是需要额外的判断来确定 Symbol 的作用）。 then 方法我们知道，Promise 的 then 方法可以传入两个参数作为回调，分别处理成功和失败的情况，而这两个参数分别只有在类型为函数的情况下，才认为有效，其余情况会忽略。then 函数会返回一个新的 Promise，用于处理 then 的回调产生的结果（或者没有设置对应回调的情况下，处理原 Promise 的结果）。 为了使原 Promise 可以处理 then 的回调，我们定义两个队列用于存放回调。 1234567/* 属性常量 */const onFulfilledCallbacks = Symbol();const onRejectedCallbacks = Symbol();// @{Future.constructor} 在 Promise 的构造器中设置回调队列defineProperty(this, onFulfilledCallbacks, []);defineProperty(this, onRejectedCallbacks, []); 在对应的处理函数中，调用这些回调： 12345678910111213// 成功的时候，调用所有成功回调队列中的函数this[state] = FULFILLED;this[result] = value;this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result]));});// 失败的时候，调用所有失败回调队列中的函数this[state] = REJECTED;this[result] = reason;this[onRejectedCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result]));}); 做好这些准备，我们就可以开始实现 then 函数了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Future { // constructor(executor) { ... } then(onFulfilled, onRejected) { const newFuture = new Future((resolve, reject) =&gt; { // 设置原 Promise 成功处理函数 const onPrevFulfilled = value =&gt; { if (typeof onFulfilled !== 'function') { // 如果没有设置成功回调，则直接使用原 Promise 的成功结果 resolve(value); } else { // 如果设置了成功回调，则用成功的结果为参数调用回调 try { // 并以回调的结果为本次成功结果 resolve(onFulfilled(value)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; // 设置原 Promise 失败处理函数 const onPrevRejected = reason =&gt; { // 如果没有设置失败回调，则直接使用原 Promise 的失败结果 if (typeof onRejected !== 'function') { reject(reason); } else { // 如果设置了失败回调，则用失败的结果为参数调用回调 try { // 并以回调的结果为本次**成功**结果 resolve(onRejected(reason)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; if (this[state] === FULFILLED) { // 如果原 Promise 已经成功，直接调用成功处理函数 process.nextTick(() =&gt; { onPrevFulfilled(this[result]); }); } else if (this[state] === REJECTED) { // 如果原 Promise 已经失败，直接调用失败处理函数 process.nextTick(() =&gt; { onPrevRejected(this[result]); }); } else { // 如果原 Promise 仍然待定，则将处理函数加到原 Promise 的回调队列中 this[onFulfilledCallbacks].push(onPrevFulfilled); this[onRejectedCallbacks].push(onPrevRejected); } }); // 返回新创建的 Promise return newFuture; }} 这里 process.nextTick 用于模拟 then 回调的微任务执行优先级。 处理 thenable刚才的基本实现应该可以处理普通的结果了，现在我们要考虑将 Promise 或者 thenable 作为结果的情况。 thenable 其实就是定义了 then 方法的对象（或函数），对 thenable 的支持可以使得不同的 Promise 实现之间相互兼容。 只要对象可以成功提供 then 函数，我们就认为它是合法的 thenable，就可以把 then 当作 Promise 的 then 方法来使用。 根据以上描述，Promise 对象本身就是一个 thenable，那么其实我们只需要判断 thenable 即可。 支持 thenable 结果如果当前 Promise 的结果是 thenable，我们就等到它们的状态变为成功或失败，并将它们的结果设为当前 Promise 的结果。 根据 Promise/A+ 规范，executor 的 reject 回调用于设置失败原因，不需要处理 thenable 的情况。我们只需要修改成功处理函数（resolveFunction）来等待 thenable 的结果： 1234567891011121314151617181920212223242526272829// 成功处理函数const resolveFunction = value =&gt; { // 处理 thenable 的情况 // 首先判断是一个对象或函数 if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; // 取得 then 函数，并且将当前 Promise 的处理函数设置为回调 if (typeof then === 'function') { then.call(value, resolveFunction, rejectFunction); return; } } catch (err) { // 如果无法成功获得 then 函数，设置当前 Promise 为错误状态 rejectFunction(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 正确处理结果回调我们知道，resolveFunction 和 rejectFunction 只有最初调用的那个可以生效，我们一开始使用一个简单的有限状态机来控制状态转移。 但是由于加入了 thenable 的处理，状态设置的顺序和调用处理函数的顺序将可能会不同，我们将无法保证只有第一次调用能够生效。如果我们先 resolve 一个 thenable，再 resolve 一个普通结果，如上的处理方式会采用后面的普通结果；同理，如果先 resolve 一个 thenable，再抛出异常，我们会得到失败的结果。所以，我们需要另外的机制来保证只有第一次调用的处理函数才能生效。 首先，我们采用一个工具函数来包装这对处理函数，使得它们总共只能被调用一次。 12345678const once = (resolve, reject) =&gt; { let called = false; const callable = () =&gt; (called ? false : ((called = true), true)); return { resolve: value =&gt; (callable() ? resolve(value) : undefined), reject: reason =&gt; (callable() ? reject(reason) : undefined) };}; 我们修改构造器的最后一段，将处理过的函数丢给 executor： 123456const { resolve, reject } = once(resolveFunction, rejectFunction);try { executor(resolve, reject);} catch (err) { reject(err);} 这样就可以保证 executor 只能调用一次处理函数，之后再调用或者抛出异常都不再理会。 正确处理 thenable 嵌套但是 thenable 也可能会提供一个 thenable 作为结果，这时候对新的 thenable 的处理，我们是放在 resolveFunction 中的，回顾一下刚刚的代码： 12345678910111213141516171819202122232425// 成功处理函数const resolveFunction = value =&gt; { if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { then.call(value, resolveFunction, rejectFunction); return; } } catch (err) { rejectFunction(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 这里同样会产生上述回调处理顺序问题，所以我们需要保证 resolveFunction 中产生的回调，也只能执行一次。 1234567891011121314151617181920212223242526272829// 成功处理函数const resolveFunction = value =&gt; { // 使用带执行检查的函数作为回调 const callback = once(resolveFunction, rejectFunction); if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { // 修改这里的回调 then.call(value, callback.resolve, callback.reject); return; } } catch (err) { // 修改这里的错误处理函数 callback.reject(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); }}; 测试我们先安装 Promise/A+ 测试库： 1npm i -g promises-aplus-tests 然后加入以下代码，提供测试库需要的接口： 12345678910111213141516exports.resolved = value =&gt; new Future((resolve, reject) =&gt; { resolve(value); });exports.rejected = reason =&gt; new Future((resolve, reject) =&gt; { reject(reason); });exports.deferred = () =&gt; { const response = {}; response.promise = new Future((resolve, reject) =&gt; { response.resolve = resolve; response.reject = reject; }); return response;}; 接着执行测试（--bail 参数用于控制测试在第一次失败时终止）： 1promises-aplus-tests custom_promise.js --bail 我们发现，我们的实现不符合规范的第 2.3.1 条： 2.3.1: If promise and x refer to the same object, reject promise with a `TypeError’ as the reason. via return from a fulfilled promise 这一条是说，Promise 不能以他自己为结果，否则得抛出 TypeError，测试的情况为： 12345const promise = new Promise((resolve, reject) =&gt; { process.nextTick(() =&gt; { resolve(promise); });}); 这种情况下，Promise 会等待自己完成时才能完成，这是一个死锁。 我们在 resolveFunction 的开头增加一段检查，来完成这一条规范： 12345678const resolveFunction = value =&gt; { const callback = once(resolveFunction, rejectFunction); if (value === this) { callback.reject(new TypeError('Promise cannot resolve itself.')); return; } // ...}; 再次执行测试，我们会发现全部的测试都可以通过了。 最终通过测试的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* 属性常量 */const state = Symbol();const result = Symbol();const onFulfilledCallbacks = Symbol();const onRejectedCallbacks = Symbol();/* 状态常量 */const PENDING = Symbol();const REJECTED = Symbol();const FULFILLED = Symbol();/* 工具函数 */// 设置不可枚举属性const defineProperty = (obj, key, value) =&gt; Object.defineProperty(obj, key, { value, writable: true, configurable: false, enumerable: false });const once = (resolve, reject) =&gt; { let called = false; const callable = () =&gt; (called ? false : ((called = true), true)); return { resolve: value =&gt; (callable() ? resolve(value) : undefined), reject: reason =&gt; (callable() ? reject(reason) : undefined) };};class Future { constructor(executor) { // 参数检查 if (typeof executor !== 'function') { throw new Error('Future executor undefined is not a function'); } // 设置状态、结果属性 defineProperty(this, state, PENDING); defineProperty(this, result, undefined); // 设置回调队列 defineProperty(this, onFulfilledCallbacks, []); defineProperty(this, onRejectedCallbacks, []); // 成功处理函数 const resolveFunction = value =&gt; { try { // 使用带执行检查的函数作为回调 const callback = once(resolveFunction, rejectFunction); // 检查是否结果为自己本身 if (value === this) { callback.reject(new TypeError('Promise cannot resolve itself.')); return; } if ( (value !== null &amp;&amp; typeof value === 'object') || typeof value === 'function' ) { try { const then = value.then; if (typeof then === 'function') { then.call(value, callback.resolve, callback.reject); return; } } catch (err) { callback.reject(err); return; } } if (this[state] === PENDING) { this[state] = FULFILLED; this[result] = value; this[onFulfilledCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); } } catch (err) { console.error(err.stack); } }; // 失败处理函数 const rejectFunction = reason =&gt; { try { if (this[state] === PENDING) { this[state] = REJECTED; this[result] = reason; this[onRejectedCallbacks].forEach(cb =&gt; { process.nextTick(() =&gt; cb(this[result])); }); } } catch (err) { console.error(err.stack); } }; const { resolve, reject } = once(resolveFunction, rejectFunction); try { executor(resolve, reject); } catch (err) { reject(err); } } then(onFulfilled, onRejected) { const newFuture = new Future((resolve, reject) =&gt; { // 设置原 Promise 成功处理函数 const onPrevFulfilled = value =&gt; { if (typeof onFulfilled !== 'function') { // 如果没有设置成功回调，则直接使用原 Promise 的成功结果 resolve(value); } else { // 如果设置了成功回调，则用成功的结果为参数调用回调 try { // 并以回调的结果为本次成功结果 resolve(onFulfilled(value)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; // 设置原 Promise 失败处理函数 const onPrevRejected = reason =&gt; { // 如果没有设置失败回调，则直接使用原 Promise 的失败结果 if (typeof onRejected !== 'function') { reject(reason); } else { // 如果设置了失败回调，则用失败的结果为参数调用回调 try { // 并以回调的结果为本次**成功**结果 resolve(onRejected(reason)); } catch (err) { // 如果抛出异常，则设置为错误结果 reject(err); } } }; if (this[state] === FULFILLED) { // 如果原 Promise 已经成功，直接调用成功处理函数 process.nextTick(() =&gt; { onPrevFulfilled(this[result]); }); } else if (this[state] === REJECTED) { // 如果原 Promise 已经失败，直接调用失败处理函数 process.nextTick(() =&gt; { onPrevRejected(this[result]); }); } else { // 如果原 Promise 仍然待定，则将处理函数加到原 Promise 的回调队列中 this[onFulfilledCallbacks].push(onPrevFulfilled); this[onRejectedCallbacks].push(onPrevRejected); } }); // 返回新创建的 Promise return newFuture; }} 添加常用的函数Promise.prototype.catch 和 Promise.prototype.finallycatch 方法类似于 then 方法，只是它只接受一个错误回调。我们可以通过使用 then 函数来达到它的效果。 123456class Future { // then(onFulfilled, onRejected) { ... } catch(onRejected) { return this.then(undefined, onRejected); }} finally 方法可以指定一个没有参数的回调，用于在 Promise 的状态发生变化时触发，finally 方法返回一个新的 Promise。 只有在回调抛出异常的情况下，新 Promise 会以这个异常为原因失败，否则新的 Promise 的结果将和原 Promise 一致。 同样，我们可以通过使用 then 函数来达到它的效果。 12345678910111213class Future { // then(onFulfilled, onRejected) { ... } finally(onFinally) { const callback = typeof onFinally === 'function' ? () =&gt; onFinally() : undefined; return this.then(callback, callback).then(() =&gt; { if (this[state] === REJECTED) { throw this[result]; } return this[result]; }); }} Promise.resolve 和 Promise.rejectPromise 的类方法 resolve 和 reject 用于构造一个确定结果的 Promise。 12345678class Future { static resolve(value) { return new Future((resolve, reject) =&gt; resolve(value)); } static reject(reason) { return new Future((resolve, reject) =&gt; reject(reason)); }} Promise.all 和 Promise.racePromise 的类方法 all 和 race 用于多个 Promise 的控制。 all 方法的参数为一个可迭代对象（Iterable，比如数组），返回一个 Promise。Promise 成功的结果将是一个新的数组。如果传入的数组里有 thenable，则将结果放到结果的对应位置，否则放数组元素本身。任意一个 thenable 的失败，都将导致整个结果失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Future { static all(iterable) { let pending = 0; return new Future((resolve, reject) =&gt; { const iterator = iterable &amp;&amp; iterable[Symbol.iterator]; if (!iterator || typeof iterator.next !== 'function') { throw new TypeError('argument must be iterable.'); } const values = []; for ( let item = iterator.next(), index = 0; !(item &amp;&amp; item.done); item = iterator.next(), index += 1 ) { if (item == null || typeof item !== 'object') { throw new TypeError('iterator.next() returned a non-object value'); } if ( (item.value !== null &amp;&amp; typeof item.value === 'object') || typeof item.value === 'function' ) { const then = item.value.then; if (typeof then === 'function') { pending += 1; const callback = value =&gt; { values[i] = value; pending -= 1; if (pending === 0) { resolve(values); } }; then.call(item.value, callback, reject); } else { values[i] = item.value; } } else { values[i] = item.value; } } if (pending === 0) { resolve(values); } }); }} race 方法的参数也为一个可迭代对象（Iterable，比如数组），返回一个 Promise。Promise 的结果将是数组元素中最快确定的结果（如果数组元素是 thenable，则需要等待它的结果，否则立即取出结果）。任意一个 thenable 的失败，都将导致整个结果失败。 123456789101112131415161718192021222324252627282930313233343536class Future { static race(iterable) { return new Promise((resolve, reject) =&gt; { const iterator = iterable &amp;&amp; iterable[Symbol.iterator]; if (!iterator || typeof iterator.next !== 'function') { throw new TypeError('argument must be iterable.'); } for ( let item = iterator.next(), index = 0; !(item &amp;&amp; item.done); item = iterator.next(), index += 1 ) { if (item == null || typeof item !== 'object') { throw new TypeError('iterator.next() returned a non-object value'); } if ( (item.value !== null &amp;&amp; typeof item.value === 'object') || typeof item.value === 'function' ) { const then = item.value.then; if (typeof then === 'function') { then.call(item.value, resolve, reject); } else { process.nextTick(() =&gt; { resolve(item.value); }); } } else { process.nextTick(() =&gt; { resolve(item.value); }); } } }); }} Promise.promisifypromisify 函数用于将标准回调风格异步函数转换成 Promise 风格异步函数，将会在函数列表末尾增加一个错误优先风格的回调（(err, value) =&gt; { ... }）来用于转换。 1234567891011121314class Future { static futurify(asyncFunctionWithCallback) { return (...args) =&gt; new Future((resolve, reject) =&gt; { asyncFunctionWithCallback(...args, (err, value) =&gt; { if (err) { reject(err); } else { resolve(value); } }); }); }} 总结到此，一个满足 Promise/A+ 规范的自定义 Promise 类就完成了，也顺便添加了一些常用的规范外的方法。","link":"/2019/05/30/node-custom-promise/"},{"title":"算法基础思想","text":"本篇介绍一些算法的基础思想。 包括：迭代、数学归纳法、递归、分治。（还讲了一下位运算和排列组合） 迭代迭代法（Iterative Method），在计算数学中，迭代是通过从一个初始估计出发寻找一系列近似解来解决问题（一般是解方程或者方程组）的数学过程，为实现这一过程所使用的方法统称。 而在计算机中，迭代是程序中对一组指令（或一定步骤）的重复。它既可以被用作通用的术语（与 “重复” 同义，此时迭代的定义包括了递归），也可以用来描述一种特定形式的具有可变状态的重复（就是一般我们所说的迭代，与递归相对的概念）。迭代很容易通过循环语句来实现。 应用： 通过不断逼近来求某个数值或其近视值。典型方法包括二分法和牛顿法。 在一定范围内查找目标值。典型方法如二分查找。 机器学习算法中的迭代。比如 K-均值算法、PageRank 的马尔可夫链、梯度下降法等。 案例 1 二分法求平方根近似值1234567891011121314151617181920212223242526272829/** * @param {number} n 待求平方根的数 * @param {number} e 相对误差要求 * @param {number} limit 迭代次数限制 * @return {number} */function getSquareRootOf(n, e = 0.00000001, limit = 100000) { if (n &lt; 0) { return NaN; } if (n === 0 || n === 1) { return n; } let min = n &gt; 1 ? 1 : n; let max = n &gt; 1 ? n : 1; for (let times = 0; times &lt; limit; times += 1) { const middle = min + (max - min) / 2; const square = middle * middle; const diff = Math.abs(square / n - 1); if (diff &lt; e) { return middle; } else if (square &gt; n) { max = middle; } else { min = middle; } } return min + (max - min) / 2;} 技巧 1 使用 min + (max - min) / 2 而不是 (min + max) / 2 来防止计算溢出 技巧 2 计算相对误差来使迭代次数相对稳定（Math.abs(square / n - 1)） 案例 2 二分查找二分查找的条件为：数组的元素是可比较的，且数组是有序的（或者说，需要先排序的）。 12345678910111213141516171819202122232425/** * @param {number} value 待搜索的值 * @param {number} array 搜索的数组 * @param {number} isSorted 数组是否有序（是否需要排序） * @return {boolean} */function bisectionSearch(value, array, isSorted = false) { if (!isSorted) { array = array.sort((a, b) =&gt; a - b); } let left = 0; let right = array.length - 1; while (left &lt; right) { const middle = Math.floor(left + (right - left) / 2); const current = array[middle]; if (current === value) { return true; } else if (current &lt; value) { left = middle; } else { right = middle; } } return false;} 数学归纳法使用数学归纳法可以从理论上证明一些结论的成立而避免迭代计算。 数学归纳法（Mathematical Induction、MI、ID）是一种数学证明方法，通常被用于证明某个给定命题在整个（或者局部）自然数范围内成立。除了自然数以外，广义上的数学归纳法也可以用于证明一般良基结构，例如：集合论中的树。这种广义的数学归纳法应用于数学逻辑和计算机科学领域，称作结构归纳法。 使用数学归纳法证明通常需要以下两步： 证明基本情况（$ n=1 $）时，结论成立； 假设 $ n=k $ 时结论成立，证明 $ n=k+1 $ 时结论也成立（$ k $ 为任意大于 0 的自然数）。 以上两步的条件不是绝对的，基本情况的条件，以及第二步的递推条件都是可以修改的。当然，修改后结论成立的范围也需要重新审视。 案例 3 棋盘麦粒古印度一位宰相将受到国王赏赐麦粒，国王问他要多少麦粒，他拿出一个 8x8 的棋盘，说在第一个格子里放 1 粒、第二个格子里放 2 粒、之后每一个格子都放前一个个格子的 2 倍数量的麦粒，他需要放完这个棋盘所有格子的麦粒。 这一题（n 个格子的麦粒总数）最直接的方式就是通过迭代来解答： 123456789function countWheats(latticeCount) { let sum = 0; let current = 1; for (let i = 0; i &lt; latticeCount; i += 1) { sum += current; current *= 2; } return sum;} 不过我们可以发现，n 个格子的麦粒总数为 $ 1 + 2 + 2^2 + 2^3 + … + 2^{n-1} = 2^n-1 $，我们可以用数学归纳法来证明这个结论。 我们用 $ f(n) $ 来表示前 n 个格子的麦粒总数。 $ n=1 $ 时，$ f(n) = 1 = 2^0 - 1 $，结论成立 假设 $ f(n) = 2^n - 1 $，那么 $ f(n + 1) = f(n) + 2^n = 2^n + 2^n - 1 = 2^{n+1} - 1 $，结论成立 通过以上步骤，我们成功证明了结论在 n 为正整数的情况下均成立。 所以这个解答可以简化为： 123function countWheats(latticeCount) { return 2 ** latticeCount - 1;} 但是这个案例，通过浮点数计算乘方可能会损失精度，如果需要精确的值，我们需要使用 BigInt 类型来表示数值，通过迭代得到精确值。 递归递归（Recursion）在数学和计算机科学中，是指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。 观察数学归纳法的证明过程，我们可以发现，只要在 $ f(n) $ 值已知的情况下可以求的 $ f(n+1) $ 的值，并且能够得到初始条件下的值，我们就可以求得任意大于初始条件的情况下的 $ f(n) $。 例如案例 3，我们也可以通过递归来得到答案： 123456function countWheats(n) { if (n === 1) { return 1; } return countWheats(n - 1) + 2 ** (n - 1);} 递归的条件在于，我们已知基本情况的结果，而对于复杂情况，我们能够一步步地简化，直到简化为基本情况。 案例 4 列出 N 局猜拳获胜的所有情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const ROCK = '石头';const SCISSORS = '剪刀';const PAPER = '布';const shapes = [ROCK, SCISSORS, PAPER];const compare = (a, b) =&gt; { if (a === b) { return 0; } if ( (a === ROCK &amp;&amp; b === SCISSORS) || (a === SCISSORS &amp;&amp; b === PAPER) || (a === PAPER &amp;&amp; b === ROCK) ) { return 1; } return -1;};/** * @param {number} games 还有多少场比赛要比 * @param {[string, string][]} stack 已经比过的比赛的出拳方式 * @return {number} 获胜的情况数量 */function winCaces(games = 1, stack = []) { // 还有比赛要比 if (games &gt; 0) { let count = 0; for (const thisSide of shapes) { for (const thatSide of shapes) { count += winCaces(games - 1, [...stack, [thisSide, thatSide]]); } } return count; } else { const totalScore = stack .map(([thisSide, thatSide]) =&gt; compare(thisSide, thatSide)) .reduce((sum, score) =&gt; sum + score, 0); if (totalScore &gt; 0) { console.log(stack.map(pair =&gt; pair.join('vs')).join(', ')); return 1; } return 0; }}const count = winCaces(3);console.log('如上，一共' + count + '种获胜情况'); 分治在上一节递归中，我们知道了一种基于数学归纳的将复杂问题逐步简单化的方式，但是还有一些复杂问题可能无法通过逐步归纳的方式来简单化，比如二分查找、归并排序等等。这一节我们介绍另一种将复杂问题简单化的思想 —- 分治。 在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 这个技巧是很多高效算法的基础，如排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。 案例 5 归并排序归并排序是一种典型的使用分治思想的算法。它的核心步骤 “归并” 就是将两个有序的数组合并成一个有序的数组。归并排序就是将原数组分解成若干个长度为 1 的小数组，最后再归并成一个大数组的方法。 由于归并过程的复杂度为 $ O(n) $，分解的次数为 $ O(\\log_2{n}) $，归并排序的时间复杂度为 $ O(n\\log_2{n}) $。由于归并过程总是产生相同长度的数组，归并排序的空间复杂度为 $ O(n) $。 12345678910111213141516171819202122function mergeSort(array) { if (array.length &lt; 2) { return array; } const middle = Math.floor(array.length / 2); const left = mergeSort(array.slice(0, middle)); const right = mergeSort(array.slice(middle)); return merge(left, right);}function merge(a, b) { const c = []; let ia = 0; let ib = 0; while (ia &lt; a.length &amp;&amp; ib &lt; b.length) { c.push(a[ia] &lt;= b[ib] ? a[ia++] : b[ib++]); } return c.concat(ia &lt; a.length ? a.slice(ia) : b.slice(ib));}const sorted = mergeSort([1, 5, 4, 6, 7, 2, 4, 6, 7, 8, 1, 2, 4]);console.log(sorted); 位运算位运算包括：左移、右移、与、或、非、异或。 异或有以下性质：x ^ x = 0、0 ^ x = x。 位运算由于其性质，在解决一些问题时有奇效。 案例 6 使用位运算判断奇偶再一些语言中，位运算比取余运算要快得多，可以使用位运算来判断奇偶，来节省执行时间。 1const isOdd = number =&gt; (number &amp; 1) === 1; 案例 7 不使用额外空间来交换整型变量利用异或的特性，我们可以不使用额外的变量就可以交换两个变量的值。 $$\\begin{align}x &amp;= x_0, y = y_0 \\\\x &amp;= x \\oplus y = x_0 \\oplus y_0 \\\\y &amp;= x \\oplus y = x_0 \\oplus y_0 \\oplus y_0 = x_0 \\\\x &amp;= x \\oplus y = x_0 \\oplus y_0 \\oplus x_0 = y_0 \\\\\\end{align}$$ 12345function swap(arr, i, j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j];} 位的集合操作位数组可以用来描述一组相互独立的布尔状态，通常可以用整型来表示。 比如，带分类的碰撞检测。我们要让魔法飞弹不能与建筑物碰撞，只能与怪物碰撞。 我们让每一个类型包括两个位数组属性，一个表示自身的分类，一个表示可以碰撞的分类。 123456789101112131415161718192021222324252627282930class Collision { mask = 0; hitMask = 0; canHit(other) { return (this.hitMask &amp; other.mask) !== 0; }}const Bit = { Monster: 1 &lt;&lt; 0, Building: 1 &lt;&lt; 1, MagicBullet: 1 &lt;&lt; 2};// 怪物可以与其它怪物、建筑、魔法飞弹碰撞class Monster extends Collision { mask = Bit.Monster; hitMask = Bit.Monster &amp; Bit.Building &amp; Bit.MagicBullet;}// 建筑可以与其它建筑、怪物碰撞class Building extends Collision { mask = Bit.Building; hitMask = Bit.Monster &amp; Bit.Building;}// 魔法飞弹只能与怪物碰撞class MagicBullet extends Collision { mask = Bit.MagicBullet; hitMask = Bit.Monster;} 排列与组合排列与组合一般用于分析或者列出所有可能的情况，即穷举法。 排列（permutation），数学的重要概念之一。从 n 个不同元素中每次取出 m（1≤m≤n）个不同元素，排成一列，称为从 n 个元素中取出 m 个元素的无重复排列或直线排列，简称排列。从 n 个不同元素中取出 m 个不同元素的所有不同排列的个数称为排列种数或称排列数，记为 $ P_n^m $（或 $ A_n^m $）。 $$P_n^m = n(n-1)(n-2)…(n-m+1) = \\frac{n!}{(n-m)!}$$ 特别的，将 n 个元素全部取出来排列的排列数成为全排列，记为 $ P_n $。 $$P_n = n! $$ 重复排列（permutation with repetiton）是一种特殊的排列，从 n 个元素中可重复地选取 m 个元素，按照一定的顺序排成一列，称作从 n 个元素中取 m 个元素的可重复排列。重复排列的排列数为 $ n^m $。 组合（combination），数学的重要概念之一。从 n 个不同元素中每次取出 m 个不同元素（0≤m≤n），不管其顺序合成一组，称为从 n 个元素中不重复地选取 m 个元素的一个组合。所有这样的组合的总数称为组合数，记为 $ C_n^m $。 $$C_n^m = \\frac{P_n^m}{P_m} = \\frac{n!}{m!(n-m)!}$$ 基本性质： $$\\begin{align}&amp;C_n^m = C_n^{n-m} \\\\&amp;C_{n+1}^m = C_n^m + C_n^{m-1} \\\\&amp;\\sum_{k=0}^{n}{C_n^k} = 2^n \\\\\\end{align}$$ 重复组合（combination with repetiton）是一种特殊的组合。从 n 个不同元素中可重复地选取 m 个元素。不管其顺序合成一组，称为从 n 个元素中取 m 个元素的可重复组合。从 n 个不同元素中可重复地选出 m 个元素的不同组合种数记为 $ H_n^m $。 $$H_n^m = \\frac{(n+m-1)!}{m!(n-1)!}$$","link":"/2019/06/06/algorithm-basis/"},{"title":"用矩阵求第 N 个斐波那契数","text":"编程求解第 N 个斐波那契数是一个经典问题，除了常规解法，本文将介绍几个较为特别的解法。 斐波那契数列的定义如下： $$\\begin{align}Fib_0 &amp;= 0 \\\\Fib_1 &amp;= 1 \\\\\\vdots \\\\Fib_n &amp;= Fib_{n-1} + Fib_{n-2} \\quad (n \\in \\mathbb Z^+, n \\geq 2) \\\\\\end{align}$$ 常规解法递归法最直观的方法是直接将斐波那契数列的定义写成对应的递归函数： 123456789function fib(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } return fib(n - 1) + fib(n - 2);} 根据 $ Fib_n = Fib_{n-1} + Fib_{n-2} $ 进行递归，最左侧的递归数高度为 $ n $，最右侧的递归数高度为 $ \\frac{n}{2} $，那么我们可以得出递归数的节点数量约为 $ \\frac{2^n}{2} = 2^{n-1} $，而递归树的高度为 $ n $。 所以递归法的时间复杂度为 $ O(2^n) $，空间复杂度为 $ O(n) $。 直接递归需要进行大量的重复计算，我们可以加入函数缓存来降低计算次数。 带函数缓存的递归解法如下： 12345678910111213function fib(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } if (!fib.cache[n]) { fib.cache[n] = fib(n - 1) + fib(n - 2); } return fib.cache[n];}fib.cache = []; 加入函数缓存后，对每一个重复位置的计算将只进行一次，因此时间复杂度降为 $ O(n) $，但是将多出 $ n $ 个数字的空间用于缓存结果，空间复杂度为 $ O(n) + O(n) = O(n) $。 迭代法 / 动态规划不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。 当然，因为斐波那契数列的公式比较简单，我们也可以简单地将递归的步骤直接转化为循环迭代，其逻辑与动态规划的方法一致。 动态规划的解法如下： 1234567function fib(n) { const dp = [0, 1]; for (let i = 2; i &lt;= n; i += 1) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n];} 该解法的时间复杂度与空间复杂度均为 $ O(n) $。 我们发现，每个状态的只与前两个状态相关，我们可以将储存状态的变量减少到 2 个来优化空间使用。 优化空间的动态规划解法如下： 123456789101112function fib(n) { if (n === 0) { return 0; } let prev = 0; // 保存前一个值 let curr = 1; // 保存当前值，初始化为 fib(1) // 迭代 n-1 次 while (--n &gt; 0) { [prev, curr] = [curr, prev + curr]; } return curr;} 优化后，动态规划解法的时间复杂度为 $ O(n) $，空间复杂度为 $ O(1) $。 非常规解法除了以上较为简单就可以想到的解法，如下方法虽然较难想到，但也是计算更加高效的算法。 斐波那契公式先由数学的方法求出斐波那契数列的通项。 我们设 $ Fib_n = a^n $，那么根据递推公式，我们可以得到 $ a^n = a^{n-1} + a^{n-2} $，约分一下可以得到 $ a^2 = a + 1 $ 即二次方程 $ a^2 - a - 1 = 0 $ 对二次方程求解可以得到： $$a = \\frac{1 \\pm \\sqrt 5}{2 \\sqrt 5}$$ 那么我们再设 $ Fib_n = A \\left( \\frac{1 + \\sqrt 5}{2 \\sqrt 5} * C \\right)^n + B \\left( \\frac{1 - \\sqrt 5}{2 \\sqrt 5} * C \\right)^n $ 代入数列前三项可以得到： $$\\begin{align}Fib_0 &amp;= A + B = 0 \\\\Fib_1 &amp;= \\frac{1 + \\sqrt 5}{2 \\sqrt 5} AC + \\frac{1 - \\sqrt 5}{2 \\sqrt 5} BC = 1 \\\\Fib_2 &amp;= \\frac{3 + \\sqrt 5}{10} AC^2 + \\frac{3 - \\sqrt 5}{10} BC^2 = 1 \\\\\\end{align}$$ 求解以上关于 $ A, B, C $ 的方程组可以得到： $$\\begin{align}A &amp;= \\frac{1}{\\sqrt 5} \\\\B &amp;= - \\frac{1}{\\sqrt 5} \\\\C &amp;= \\sqrt 5 \\\\\\end{align}$$ 代入 $ Fib_n = A \\left( \\frac{1 + \\sqrt 5}{2 \\sqrt 5} * C \\right)^n + B \\left( \\frac{1 - \\sqrt 5}{2 \\sqrt 5} * C \\right)^n $ 就可以得到斐波那契公式。 斐波那契公式： $$F_n = \\frac{1}{\\sqrt 5} * \\left[ \\left(\\frac{1 + \\sqrt 5}{2}\\right)^n - \\left(\\frac{1 - \\sqrt 5}{2}\\right)^n \\right]$$ 那么根据斐波那契公式，我们就可以编码求解了： 123456function fib(n) { const sqrt5 = Math.sqrt(5); const value = (Math.pow((1 + sqrt5) / 2, n) - Math.pow((1 - sqrt5) / 2, n)) / sqrt5; return Math.round(value);} 该方法的需要进行 1 次平方根与 2 次求幂操作，用二分法求平方根的复杂度为 $ O(log_2{n}) $，用快速幂方法求幂的复杂度为 $ O(log_2{n}) $，所以总体时间复杂度为 $ O(log_2{n}) $。同理，空间复杂度为 $ O(1) $。 但是由于涉及到浮点数计算，该方法可能会得到近似值而不是准确值。 Q-Matrix 方法Q-Matrix 方法是一种利用矩阵相乘特性来巧妙求解斐波那契数列的方式。公式如下： $$\\begin{bmatrix}F_{n+1} &amp; F_n \\\\F_n &amp; F_{n-1} \\\\\\end{bmatrix}= \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix}^n\\quad (n \\in \\mathbb Z^+)$$ 我们令 $ Q = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} $，则： $$Q^n = \\begin{bmatrix}F_{n+1} &amp; F_n \\\\F_n &amp; F_{n-1} \\\\\\end{bmatrix}\\quad (n \\in \\mathbb Z^+)$$ 我们可以用数学归纳法来证明上述公式成立，首先检验第一项满足条件： $$Q^1 = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} = \\begin{bmatrix} Fib_2 &amp; Fib_1 \\\\ Fib_1 &amp; Fib_0 \\\\ \\end{bmatrix}$$ 假设第 n-1 项满足条件，证明第 n 项也满足： $$\\begin{align}Q^n &amp;= Q^{n-1} Q \\\\ &amp;= \\begin{bmatrix}F_n &amp; F_{n-1} \\\\F_{n-1} &amp; F_{n-2} \\\\\\end{bmatrix} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\\\ \\end{bmatrix} \\\\ &amp;= \\begin{bmatrix}F_n + F_{n-1} &amp; F_{n-1} + F_{n-2} \\\\F_{n-1} + F{n-2} &amp; F_{n-1} \\\\\\end{bmatrix} \\\\ &amp;= \\begin{bmatrix}F_{n+1} &amp; F_n \\\\F_n &amp; F_{n-1} \\\\\\end{bmatrix}\\end{align}$$ 由上述步骤即可证明对于 $ n \\in \\mathbb Z^+ $ 结论成立，反过来可得对于 $ n \\in \\mathbb Z^+, n \\geq 2 $，$ Fib_n = Q^{n-1}[0,0] $。 那么转换成代码即： 1234567891011function fib(n) { if (n === 0) { return 0; } if (n === 1) { return 1; } const Q = [[1, 1], [1, 0]]; const powQ = pow2x2(Q, n - 1); return powQ[0][0];} 其中 pow2x2(mat, exp) 用于求 2x2 矩阵的正整数次幂。我们可以将快速幂方法延伸到矩阵求幂： 1234567891011121314151617181920function pow2x2(mat, exp) { let ret = [[1, 0], [0, 1]]; let tmp = mat; while (exp &gt; 0) { if ((exp &amp; 1) === 1) { ret = mul2x2(ret, tmp); } tmp = mul2x2(tmp, tmp); exp &gt;&gt;= 1; } return ret;}function mul2x2(A, B) { const C = [[0, 0], [0, 0]]; C[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0]; C[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1]; C[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0]; C[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1]; return C;} 这样 pow2x2(mat, exp) 的时间复杂度为 $ O(log_2{n}) $，空间复杂度为 $ O(1) $。 用 Q-Matrix 方法求斐波那契数只涉及一次矩阵求幂，那么它的的时间复杂度也为 $ O(log_2{n}) $，空间复杂度也为 $ O(1) $。 总结以上所述计算斐波那契数的方法复杂度比较： 方法 时间复杂度 空间复杂度 递归 $ O(2^n) $ or $ O(n)^{[1]} $ $ O(n) $ 动态规划 $ O(n) $ $ O(n) $ or $ O(1)^{[2]} $ 斐波那契公式 $ O(log_2{n}) $ $ O(1) $ Q-Matrix $ O(log_2{n}) $ $ O(1) $ 注 [1]：使用函数缓存优化递归执行时间 注 [2]：优化状态存储来减少空间占用 附录用二分法求平方根上一篇文章中有提及到用二分法求平方根，这里直接贴出代码： 1234567891011121314151617181920212223242526272829/** * @param {number} n 待求平方根的数 * @param {number} e 相对误差要求 * @param {number} limit 迭代次数限制 * @return {number} */function getSquareRootOf(n, e = 0.00000001, limit = 100000) { if (n &lt; 0) { return NaN; } if (n === 0 || n === 1) { return n; } let min = n &gt; 1 ? 1 : n; let max = n &gt; 1 ? n : 1; for (let times = 0; times &lt; limit; times += 1) { const middle = min + (max - min) / 2; const square = middle * middle; const diff = Math.abs(square / n - 1); // 相对精度 if (diff &lt; e) { return middle; } else if (square &gt; n) { max = middle; } else { min = middle; } } return min + (max - min) / 2;} 分析可知其时间复杂度为 $ O(log_2{n}) $，空间复杂度为 $ O(1) $。 用快速幂方法求幂根据正整数的二进制数表示法，我们可以得到下列规律： $$13 = 1101_2 = 2^3 + 2^2 + 2^0$$ 那么对于乘方我们可以得到如下规律： $$a^{13} = a^{1101_2} = a^{(2^3 + 2^2 + 2^0)} = a^{2^3} * a^{2^2} * a^{2^0}$$ 利用这个规律，我们可以用 $ O(log_2{n}) $ 次相乘就可以得到 $ a^n \\ (n \\in \\mathbb Z^+) $。 123456789101112function pow(num, exp) { let ret = 1; let tmp = num; // num ^ 1 while (exp &gt; 0) { if ((exp &amp; 1) === 1) { ret *= tmp; // ret *= num ^ (2 ^ (i - 1)) } tmp *= tmp; // num ^ (2 ^ i), i 为循环次数 exp &gt;&gt;= 1; } return ret;} 分析可知其时间复杂度为 $ O(log_2{n}) $，空间复杂度为 $ O(1) $。","link":"/2019/06/11/binets-fibonacci/"},{"title":"JavaScript 中的继承与原型链","text":"对于使用过基于类的面向对象语言（如 Java 或 C++）的开发者而言，JavaScript 中的继承可能有些奇怪，因为它是动态的，并且没有类的概念。 尽管 JavaScript 基于原型的继承模型通常被认为是 JavaScript 弱点，但其实这比经典的基于类的模型要更加强大。 原型链JavaScript 的对象是动态的属性集合，其中有一个属性用于指向其原型对象。这种类似链表的结构被称为原型链。 根据 ECMAScript，[[Prototype]] 符号用于指向对象的原型。 从 ECMAScript 6 开始，可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 来访问对象的原型。而非标准属性 __proto__ 也用访问对象的原型。 这与构造函数的prototype属性不同。使用构造函数构造的实例对象的原型（[[Prototype]]）是构造函数的 prototype。Object.prototype 属性表示 Object 的原型对象，通常是原型链最后一层。 属性继承当访问一个对象的属性时，不仅会在该对象中查找属性，也会顺着原型链一层层地查找，直到找到一个名字匹配的属性或者达到原型链末尾。而设置对象的属性时，将直接在当前对象中创建或修改属性（除非该属性设置了 getter 或 setter）。 示例： 123456789101112131415161718192021222324252627282930313233const A = function() { this.a = 1; this.b = 2; this.c = 3; this.d = 4;};A.prototype.b = 5;Object.defineProperty(A.prototype, 'c', { get() { return 6; }});let d = 7;Object.defineProperty(A.prototype, 'd', { get() { return d; }, set(value) { d = value; }});const a = new A();// 原型链为 a { a: 1, b: 2 } -&gt; A.prototype { b: 4, c: 5, d: 7 } -&gt; Object.prototype -&gt; nullconsole.log(a.a); // 1console.log(a.b); // 2console.log(a.c); // 6console.log(a.d); // 4console.log(a.e); // undefinedconsole.log(A.prototype.b); // 5console.log(A.prototype.c); // 6console.log(A.prototype.d); // 4 注： a 中的 b 属性覆盖了原型上的 b 属性，这种情况叫做属性遮蔽（Property Shadowing）。 只定义 getter 的属性无法修改，也无法遮蔽。 定义了 setter 的属性将按照 setter 定义的方式去修改，不会进行遮蔽。 方法继承JavaScript 中其实并没有基于类的方法这一概念。在 JavaScript 中，我们把函数类型的属性称为方法。方法的继承和其他属性没有差别，包括属性遮蔽（这时候相当于方法的覆写）。 当继承的函数被调用时，this 指向当前对象，而不是继承的函数所在的原型对象。 示例： 123456789101112const parent = { val: 2, add(val) { this.val += val; }};const child = Object.create(parent); // 创建一个以 parent 为原型的对象child.val = 4;child.add(4);console.log(child.val); // 8console.log(parent.val); // 2 构造函数的 prototype 属性我们知道，JavaScript 中的函数也是对象的一种，函数也可以定义属性。而每一个函数都有一个特殊的属性 —- “prototype”，用于表示当这个函数用作构造函数时，所构造的对象的原型对象。 prototype 属性默认包括两个属性： “constructor” 属性，指向原来那个函数 “__proto__“ 属性，指向这个原型对象的原型（如之前所说，这是一个非标准属性） 通过不同方式创建对象并生成原型链使用字面量或者函数语法1234567891011121314const object = { a: 1 };// object// -&gt; Object.prototype { hasOwnProperty, ... }// -&gt; nullconst array = [2, 3, 4];// array// -&gt; Array.prototype { indexOf, forEach, ... }// -&gt; Object.prototype -&gt; nullconst func = () =&gt; 5;// func// -&gt; Function.prototype { call, bind, ...}// -&gt; Object.prototype -&gt; null 构造函数123456789101112function Graph() { this.vertices = []; this.edges = [];}Graph.prototype.addVertex = function(v) { this.vertices.push(v);};const g = new Graph();// g// -&gt; Graph.prototype { addVertex }// -&gt; Object.prototype -&gt; null Object.create1234567891011121314const a = { a: 1 };// a -&gt; Object.prototype -&gt; nullconst b = Object.create(a);// b -&gt; a -&gt; Object.prototype -&gt; nullconst c = Object.create(b);// c -&gt; b -&gt; a -&gt; Object.prototype -&gt; nullconst d = Object.create(null);// d -&gt; nulld.hasOwnProperty();// 报错，因为 d 没有继承 Object.prototype class 关键字ECMAScript 引入了一套新的关键字，可以让开发者用于使用基于类风格的语法来编写代码。但是这只是语法糖，其内部实现仍然是基于原型的。 这些关键字包括：class, constructor, static, extends 和 super。 12345678910111213141516171819202122232425262728class Rectangle { constructor(width, height) { this.width = width; this.height = height; } get area() { return this.width * this.height; }}class Square extends Rectangle { constructor(sideLength) { super(sideLength, sideLength); } get sideLength() { return this.width; } set sideLength(newValue) { this.width = newValue; this.height = newValue; }}const square = new Square(2);// square { width, height }// -&gt; Square.prototype { sideLength }// -&gt; Rectangle.prototype { area }// -&gt; Object.prototype -&gt; null 性能在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。 遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从 Object.prototype 继承的 hasOwnProperty 方法，或者使用 Object.keys()。 注意：检查属性是否为 undefined 是不能够检查其是否存在的。该属性可能已存在，但其值恰好被设置成了 undefined。 扩充原生对象的原型经常使用的一个错误实践是扩展 Object.prototype 或其他内置原型。 这种技术被称为猴子补丁并且会破坏封装。尽管一些流行的框架（如 Prototype.js）在使用该技术，但仍然没有足够好的理由使用附加的非标准方法来混入内置原型。 扩展内置原型的唯一理由是支持 JavaScript 引擎的新特性（polyfill），如 Array.forEach。 比较四种扩展原型链的方法 使用构造的实例 123456789101112function foo() {}foo.prototype = { foo: 'foo' };function bar() {}const proto = new foo();proto.bar = 'bar';bar.prototype = proto;const inst = new bar();// inst// -&gt; bar.prototype (proto) -&gt; foo.prototype// -&gt; Object.prototype -&gt; null 优点：支持目前以及所有可想象到的浏览器(IE5.5 都可以使用). 这种方法非常快，非常符合标准，并且充分利用 JIST 优化。 缺点：在初始化 foo 构造函数的过程中，可能会想设置一些实例属性，但是 foo 的构造器只会执行一次，可能会引发潜在的问题。 Object.create 12345678910function foo() {}foo.prototype = { foo: 'foo' };function bar() {}bar.prototype = Object.create(foo.prototype, { bar: { value: 'bar' } });const inst = new bar();// inst// -&gt; bar.prototype -&gt; foo.prototype// -&gt; Object.prototype -&gt; null 优点：支持所有流行的浏览器，包括 IE9 及以上。仅对原型进行一次修改，可以让浏览器进行更好的优化，也支持创建没有原型的对象。 缺点：IE8 及以下不可使用。使用第二个参数进行属性设置的时候可能会耗费大量时间，因为对每个属性的描述也是一个对象，对成百上千个属性的设置可能造成延迟。 Object.setPrototypeOf 12345678910function foo() {}foo.prototype = { foo: 'foo' };function bar() {}bar.prototype = Object.setPrototypeOf({ bar: 'bar' }, foo.prototype);const inst = new bar();// inst// -&gt; bar.prototype -&gt; foo.prototype// -&gt; Object.prototype -&gt; null 优点：支持所有流行的浏览器，包括 IE9 及以上。允许动态修改对象的原型，甚至给没有原型的对象设置原型。 缺点：应当被禁用，且会造成严重的性能问题。因为许多浏览器对原型进行优化，而动态修改原型打乱了这些优化，甚至导致浏览器重新编译并优化代码。且 IE8 及以下不可使用。 __proto__ 123456789101112const inst = { __proto__: { bar: 'bar', __proto__: { foo: 'foo', __proto__: Object.prototype } }};// inst// -&gt; bar.prototype -&gt; foo.prototype// -&gt; Object.prototype -&gt; null 优点：支持所有流行的浏览器，包括 IE11 及以上。允许动态修改对象的原型，甚至给没有原型的对象设置原型。而且给一个不是对象的值设置 __proto__ 属性会什么都不做而不会导致异常。 缺点：应当被禁用，且会造成严重的性能问题。因为许多浏览器对原型进行优化，而动态修改原型打乱了这些优化，甚至导致浏览器重新编译并优化代码。且 IE10 及以下不可使用。 动态性对于 Java 或 C++ 的开发者来说，JavaScript 可能会使人困惑，因为一切都是动态的，运行时的。 在构造函数的 prototype 中设置的属性可以共享给所有构造出来的实例。 而甚至在实例构造之后，仍可以修改 prototype 的属性，其修改将影响所有继承该原型的对象（除非属性被遮蔽）。 总结在编写使用它的复杂代码之前，理解原型继承模型是至关重要的。此外，请注意代码中原型链的长度，并在必要时将其分解，以避免可能的性能问题。此外，原生原型不应该被扩展，除非它是为了与新的 JavaScript 特性兼容。","link":"/2019/06/12/js-inheritance/"},{"title":"理解 Node.js 中的垃圾回收机制","text":"虽然 Node.js 的学习曲线非常平坦，但是保持 Node.js 运行的机制非常复杂。为了避免一些性能缺陷，我们必须理解其机制。 这篇文章将介绍 Node.js 的内存管理方式。 V8 引擎是 Google 为 Chrome 浏览器而开发 JavaScript 引擎，但同时也可以脱离 Chrome 独立使用。Node.js 内部就是使用了 V8 引擎来执行 JavaScript 代码。 在 Node.js 中 V8 引擎负责编译并执行 JavaScript 代码、为 JavaScript 的变量和对象分配内存以及进行垃圾回收。 V8 的内存管理机制像 C 这样的语言是将内存管理全权交给开发者来管理，开发者来决定分配多少的内存并何时释放，一旦开发者忘记释放，那么这片内存将永远被占用，且无法使用。而在 JavaScript 中，内存管理是交给引擎来做的，开发者不必考虑何时去释放不再使用的内存。 在 V8 引擎中，是通过垃圾回收机制来管理内存的。垃圾回收机制通过定期检查来找出那些已经无法被访问到的对象来清楚它们使用的内存。 通过自动的垃圾回收机制，我们不需要再管理内存，可以更加专注于应用的逻辑。但是同时，如果我们对其机制不了解，就可能会写出具有缺陷的代码，造成内存泄漏。 V8 的内存分配结构V8 中为 JavaScript 所分配的内存空间称为常驻内存集（Resident Set），其中包括用于存放代码逻辑的代码段（Code Segment，这里是存放包含 JIT 指令处理过的特殊对象），用于存放局部变量或引用的栈（Stack）以及用于存放对象与闭包的堆（Heap）。 在 Node.js 中，可以通过内置 API 来获取内存使用信息： 12345console.log(process.memoryUsage());// { rss: 23752704,// heapTotal: 9682944,// heapUsed: 5774144,// external: 33920 } 其中： ‘rss’（Resident Set Size）代表常驻内存集的大小 ‘heapTotal’ 代表堆大小 ‘heapUsed’ 代表堆中已使用空间的大小（用来判断内存泄漏） ‘external’ 代表 V8 引擎内部的 C++对象所占用的空间 由于 V8 是为浏览器开发的引擎，不太可能会遇到使用大量内存的场景，所以它默认的可分配内存上线设置的不大，64 位系统下约为 1.4GB，32 位系统中约为 700MB。 V8 的垃圾回收机制回看 JavaScript 中的垃圾回收机制，一般分为两种：引用计数机制与标记清除机制。其中 IE6 使用的是引用计数机制，现代浏览器使用的都是标记清除机制。 引用计数机制（IE6 等）引用计数机制记录对每个对象的引用的数量，当数量为 0 时，引用计数机制就认为可以清除这个对象了。 引用计数机制有一个很严重的缺陷：循环引用导致的内存泄漏。 例如： 123456function showPitfall() { const a = {}; const b = {}; a.b = b; b.a = a;} 在这个例子中，a 和 b 对对方都有一个引用，因此在函数执行完后，它们的引用计数也不为 0，将永远不会被清除。 但其实我们经常在写隐含着循环引用的代码，例如： 1234const element = document.querySelector('#el');element.onclick = function onclick(event) { console.log('#el is clicked.');}; 这个例子中，onclick 函数形成了一个可以访问 element 的闭包，而 element 上又绑定了 onclick 这个函数，element 与闭包之间形成了循环引用。 标记清除机制（V8 等）标记清除算法在对象中添加一个标记，通过对可访问的对象设置标记来识别出那些不可被访问的对象。 通常标记清楚算法会选取一些根节点，比如 window 对象，然后将所有根节点及其子节点标记为活跃，所有从根节点可访问的对象都视为不可删除。 所有没有被标记的对象都是可以清除的。 现代浏览器的引擎通过不同的方法来优化这个机制，但本质都是一样的。 在这种机制下，内存泄漏通常是由于我们保存了不必要的引用。 比如： 不必要的全局变量，比如在宽松语法下意外声明的全局变量（未使用声明关键字或者不正确地使用 this 关键字） 12345function foo() { bar = 'This is an implicit global variable'; this.bar = 'This is an implicit global variable via this';}foo(); 忘记清除地计时器或者其他回调 12345678910function startSettingHTML() { const someData = getData(); setInterval(function() { const node = document.querySelector('#node'); if (node) { node.innerHTML = JSON.stringify(someData); } }, 1000);}startSettingHTML(); 这个例子中，计时器的回调函数产生了一个可以访问 someData 的闭包，由于计时器没有被清除，即使 #node 元素不再存在，这个回调不再有意义，someData 也不会被清除。 保留了 DOM 节点的引用 有时候为了方便使用，会在代码中保存对 DOM 节点的引用。如果你忘记清除该引用，那么由于子节点会保留父节点的引用，即使父节点从 DOM 树中移除，子节点这条链上的元素都无法被清除。（比如保留 tr 元素的引用，之后删掉整个 table，但是 table 还会一直在内存里） 12345678910111213window.inputs = {};window.forms = {};// ...forms.login = document.querySelector('#login-form');inputs.password = forms.login.querySelector('.password-input');inputs.password.onkeyup = validatePassword;// ...function onLogin() { forms.login.remove(); // forms is just like inputs, stores DOM elements. froms.login = null;}// 只要 inputs.password 不清除，#login-form 就一直无法清除 闭包 12345678910111213141516let theThing = null;let replaceThing = function() { let originalThing = theThing; let unused = function() { if (originalThing) { console.log('originalThings exists.'); } }; theThing = { longString: '*'.repeat(1000000), someMethod() { console.log('some message'); } };};setInterval(replaceThing, 1000); 这是个由微妙的方式导致内存泄漏的例子（Metero 的开发者发现了这个漏洞，并在这篇文章中有详细描述）。V8 可以识别闭包中是否使用了变量，但是这个例子中，unused 和 someMethod 共享了闭包作用域，而 unused 中使用了 originalThing，迫使 originalThing 处于活跃状态。 V8 的垃圾回收策略标记擦除机制会对所有可访问的对象进行标记，这在对象较多时是一个很耗时的操作，V8 通过分代管理内存的方式来降低这个消耗。 分代内存基于一种假设：大部分新生对象倾向于早死，无法存活多次 GC 周期；能够存活多个 GC 周期的对象都比较长寿。 V8 的分代内存管理就是将堆内存空间划分为新生代（New Generation）空间和老生代（Old Generation）空间，对它们采用不同的垃圾回收算法。 新生代的对象存活时间较短，为经历过 0 次或 1 次 GC 的对象。 老生代的对象存活时间较长，为经历过 2 次或以上 GC 的对象。 默认情况下，64 位系统下，新生代空间为 32MB，老生代空间为 1.4GB，32 位系统下，新生代空间为 16MB，老生代空间为 700MB。 将新生代中的对象转移到老生代的过程称为晋升。 新生代的内存管理算法1、分配方式 新生代存放的都是生存周期短的对象，分配内存也比较容易，只保存一个指向内存空间的指针，根据分配对象大小递增指针即可，当存储空间快要满时，进行一次垃圾回收。 2、垃圾回收算法 新生代采用 Scavenge 垃圾回收算法，算法实现时主要采用 Cheney 算法。 Cheney 算法将内存均分为两个 semispace，一块处于使用状态（称为 From 空间），一块处于闲置状态（称为 To 空间）。 Cheney 算法的过程如下： 从 From 空间分配对象，如果 From 空间被占满，则执行 Scavenge 算法进行垃圾回收。 检查 From 空间的存活对象，如果对象存活，检查是否满足晋升条件，如果满足则晋升到老生代，不满足则复制到 To 空间。 如果对象不存活，则释放其使用的空间。 完成上述过程后，反转 From 空间与 To 空间。 对象晋升条件对象晋升的条件有两个： 对象是否经历过 Scavenge 回收。如果已经经历过一次 Scavenge，则将对象晋升，否则复制到 To 空间。 To 空间的使用率是否超过限制（25%）。如果超过 25%的限制，则直接分配至老生代。设置 25% 的原因是，如果反转 semiplace 之后，空间占用比过高，会影响后续内存分配。 老生代的内存管理算法老生代与新生代不同，不适合用 Scavenge 算法进行垃圾回收： 老生代的存活对象的比例更高，复制存活对象的操作会很多 老生代的空间远大于新生代，采用 Scavenge 算法将空间分为两部分将造成很大的浪费。 老生代内存空间的垃圾回收有两种方式：标记清除（Mark Sweep）和标记合并（Mark Compact）。 1、标记清除 标记清除算法在标记阶段对死掉的对象进行标记，并且在回收阶段直接释放掉对应的内存空间。 标记清除算法只清除死掉的对象，Scavenge 算法只复制存活的对象，而在老生代中死对象的比例较低，新生代中存活对象的比例较低，所以这两种算法都能够较高效地进行垃圾回收。 但是，标记清除这种方式会产生内存空间碎片化（占用空间不连续）的问题。 2、标记合并 为了解决标记清除的空间碎片化问题，我们需要引入标记合并算法。 标记合并算法在标记阶段和标记清除一样，对死对象进行标记，在回收阶段，将存活的对象向内存空间的一端移动，然后直接将这部分之外的内存占用全部清除掉。 3、两者的结合 很明显，标记合并涉及到很多内存复制操作，效率要比标记清除低很多。 在 V8 中，老生代主要使用标记清除进行垃圾回收，只有当空间不足以从新生代晋级新对象的时候才会使用标记合并算法。 总结 Node.js 中的的垃圾回收就是 V8 的垃圾回收 V8 主要使用标记清除算法 V8 的堆分为两块：新生代与老生代 新生代存放没有或仅经历一次 GC 的对象，使用 Scavenge 算法进行 GC 老生代存放从新生代晋升的对象，结合标记清除与标记合并两种算法进行 GC","link":"/2019/06/21/nodejs-understanding-gc/"},{"title":"Rust学习笔记1","text":"本文是 Rust 学习笔记系列第一篇，参考 Rust 指南的第 2 到 3 章，涉及变量、数据类型、函数、注释、控制流。 变量Rust 中用 let 关键字定义变量，变量默认都是不可变的，用 let mut 定义可变的变量。（可变变量必须显式使用 mut 声明，这是 Rust 从安全方面的考虑） 不可变的变量一旦初始化就不能再被改变。 1234567fn main() { let foo = 5; // 不可变 let mut bar = 5; // 可变 let x; x = 5;} 常量和不可变变量类似，常量也是将一个不可变的值绑定到标识符。 常量用 const 关键字定义，无法用 mut 将常量定义为可变，且常量的类型必须显式指定。 1const MAX_POINTS: u32 = 100_000; Rust 的命名习惯是将常量定义为大写字母加下划线的风格 常量在程序执行过程中一直存在，在其定义的作用域中有效。 变量覆盖（Shadowing）Rust 可以在同一个作用于中定义相同名称的变量，然后先定义的变量将无法在被访问到。 12345fn main() { let x = 5; let x = x + 1; let x = x * 2;} 变量覆盖与可变变量不同，当无意中在未使用 let 关键字的情况下为变量赋值时将产生编译错误。并且使用变量覆盖时可以换一个新的类型。 数据类型Rust 中所有的值都有类型，类型分为标量类型和复合类型。 Rust 是一种静态类型语言，也就是说 Rust 必须在编译期知道所有变量的类型。通常编译器可以从值或者其用法推断出类型，但是当有多种可能的类型时，就需要显式声明变量的类型了。 1let guess: u32 = \"42\".parse().expect(\"Not a number!\"); 标量类型（Scalar Type）标量类型代表一个单独的值。Rust 有 4 种基础标量类型：整数、浮点数、布尔值、字符。 整数整数类型可以用于表示不含小数部分的数字。根据是否有符号以及存储空间大小区别，分为以下 12 种变种： 长度 有符号 无符号 8 位 i8 u8 16 位 i16 u16 32 位 i32 u32 64 位 i64 u64 128 位 i128 u128 与当前运行环境的架构一致(32 位或 64 位) isize usize 所有的变种都具备有符号或无符号的约束，且有一个固定的存储空间大小。有符号的整数使用二进制补码的方式存储，有效值范围为 $-(2^{n-1})$ 到 $2^{n-1}-1$（$n$ 为存储空间位数）；无符号的整数有效值范围为 $0$ 到 $2^n-1$（$n$ 为存储空间位数）。 以下字面量可以用于表示整数： 字面量类型 例子 十进制 1024 十六进制 0x400 八进制 0o2000 二进制 0b10000000000 字节（仅用于 u8 类型） b'A' 除了字节字面量，其他的字面量都可以用整数变种名作为后缀，并且可以用_作为数字的分隔符，例如：1024u16，1_024。 如果不确定要用哪一种整数变种，可以让 Rust 使用默认的i32，即使是在 64 位系统中，也通常是运算最快的。isize 和 usize 的主要使用场景是作为某种集合的索引类型。 如果尝试给整数赋值超出有效范围的值，会导致整数溢出。Rust 在 debug 模式下溢出会崩溃，release 模式下溢出则不会产生崩溃，但是可能会与预期值不一致。 浮点数Rust 的浮点数分为两种：f32 和 f64。和整数一样，这两种类型仅在存储空间大小上有区别。默认的浮点数类型为 f64，因为在现代 CPU 中，32 位浮点数与 64 位浮点数运算速度相差无几，而 64 位可以提供更高的精度。 1234fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32} 浮点数使用 IEEE-754 标准来表示，f32 为单精度浮点数，f64 为双精度浮点数。 数学运算Rust 为所有的数字类型提供数学基本运算：加减乘除与取余。 1234567fn main() { let sum = 5 + 10; let difference = 95.5 - 4.3; let product = 4 * 30; let quotient = 56.7 / 32.2; let remainder = 43 % 5;} 布尔类型与大部分其他语言一样，Rust 的布尔值类型有两个可能值：true 和 false。布尔值使用 1 个字节的存储空间。 1234fn main() { let t = true; let f: bool = false;} 布尔值主要用于条件判断，比如 if 表达式。 字符类型Rust 中的 char 类型是最基本的文本类型，字符字面量使用单引号（字符串则是双引号）： 12345fn main() { let c = 'z'; let z = 'ℤ'; let heart_eyed_cat = '😻';} Rust 的 char 类型使用 4 个字节存储，表示一个 Unicode 标量（UTF-32）。在 Rust 中字母变种、中文、日文、韩文、Emoji，零宽度空格都是一个有效的 char 值。Unicode 标量的有效范围为 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF。然而 Unicode 中并没有字符的概念，所以一般所说的字符可能和 char 会有出入。 复合类型（Compound Type）复合类型用于将多个值组合成一个类型。Rust 有两个基本复合类型：元组（tuple）与数组（array） 元组元组用于将多个值组合成一个类型，这些值可以是不同的类型。Rust 是一种静态类型语言，每个元组类型拥有固定个数的值，并且对应位置的值的类型也是确定的。 1234567fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); let tup = (500, 6.4, 1); let (x, y, z) = tup; // 通过解构取出元组中的值 let x2 = tup.0; // 直接按位置取出元组中的值} 数组与元组不同，数组的所有元素必须是同一种类型。与其他的一些语言不同，Rust 中的数组是固定长度的。 1234567891011fn main() { let arr = [1, 2, 3, 4, 5]; let arr: [i32; 5] = [1, 2, 3, 4, 5]; // 数组的类型语法：[type; length] // 另一种数组字面量，用于创建包含重复元素的数组 let arr: [i32; 5] = [1; 5]; // 等同于 [1, 1, 1, 1, 1] let first = arr[0]; // 使用下标访问数组元素 let second = arr[1];} 数组下标越界会产生编译错误。 函数Rust 中用 fn 关键字定义函数。最重要的函数是 main 函数，是整个程序的入口。 Rust 中函数和变量使用小写下划线的命名风格。 12345678fn main() { println!(\"Hello, world!\"); another_function();}fn another_function() { println!(\"Another function.\");} Rust 中的函数调用不关心函数定义的顺序。 函数的参数函数的参数必须显式指定类型。 12345678fn main() { another_function(5, 6);}fn another_function(x: i32, y: i32) { println!(\"The value of x is: {}\", x); println!(\"The value of y is: {}\", y);} 函数体，语句与表达式函数体由一系列的语句构成，可以由一个表达式结尾。Rust 是一种基于表达式的语言，能区分语句与表达式的区别尤为重要。 语句指的是执行某些动作的操作，并不返回值；而表达式会有一个值作为结果。 参数定义和函数体都是语句的一种。 123fn main() { // fn statement let y = 6; // let statement} 与其他语言不同，Rust 中赋值语句不产生结果，因此诸如 x = y = 5 的写法在 Rust 中行不通。 表达式可以是语句的一部分。 函数调用、宏调用、块都是表达式的一种。 12345678910fn main() { let x = 5; let y = { // block expression let x = 3; x + 1 // 结尾表达式，如果加`;`会变成语句 }; println!(\"The value of y is: {}\", y);} 块可以创建新的作用域，块表达式的值是其结尾表达式的值。 函数的返回值函数可以给调用自己的地方返回一个值，返回值没有名称，但是需要定义类型。在 Rust 中，函数的返回值是作为函数体的块的值（即结尾表达式的值），但是可以用 return 关键字提前返回结果。 12345678fn five() -&gt; i32 { 5}fn main() { let x = five(); println!(\"The value of x is: {}\", x);} 注释和其他一些语言一样，Rust 使用 // some words、/* some words */ 表示注释，还有一种文档注释，之后再说。 控制流if 表达式12345678910111213141516171819202122232425fn main() { let number = 3; if number &lt; 5 { println!(\"condition was true\"); } if number &lt; 5 { println!(\"condition was true\"); } else { println!(\"condition was false\"); } if number % 4 == 0 { println!(\"number is divisible by 4\"); } else if number % 3 == 0 { println!(\"number is divisible by 3\"); } else if number % 2 == 0 { println!(\"number is divisible by 2\"); } else { println!(\"number is not divisible by 4, 3, or 2\"); } let number_at_least_5 = if number &gt; 5 { 5 } else { number }} if 表达式的值为执行的那个块的值，if 语句的所有块的值类型必须一致。 循环Rust 有三种循环：loop、while、for。 loop 循环loop 关键字会循环执行一个块，直到使用 break 关键字中止循环。 12345fn main() { loop { println!(\"again!\"); }} loop 的返回值使用 break 关键字中止循环，break 后面接的值就是 loop 的值。 12345678910111213fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\"The result is {}\", result);} while 循环while 关键字会重复检查条件，当条件满足时，执行作为循环体的块，否则中止循环。 12345678910fn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index &lt; 5 { println!(\"the value is: {}\", a[index]); index += 1; }} while 循环没有返回值。 for 循环for 关键字会遍历一个集合 123456789101112fn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter() { println!(\"the value is: {}\", element); } for number in (1..4).rev() { println!(\"{}!\", number); } println!(\"LIFTOFF!!!\");} for 循环没有返回值。","link":"/2020/10/09/learning-rust-1/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"OOJS","slug":"OOJS","link":"/tags/OOJS/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Fibonnaci","slug":"Fibonnaci","link":"/tags/Fibonnaci/"},{"name":"Matrix","slug":"Matrix","link":"/tags/Matrix/"},{"name":"Performance","slug":"Performance","link":"/tags/Performance/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"}]}