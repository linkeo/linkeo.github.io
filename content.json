{"pages":[],"posts":[{"title":"JavaScript 的 new 操作符","text":"JavaScript 的 new 操作符都做了些什么？如何用一个函数来模拟 new 呢？ 官方文档官方文档第一段中的说法： new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象（即 {}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤 1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this 。 官方文档在 “描述” 章节中的说法： 当代码 new Foo(...) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 要点根据上面两段描述，可以整理出以下要点： 使用 new 来调用时，构造函数的上下文的 this 是一个新创建的对象，继承自构造函数的原型（prototype） 当构造函数的返回值是一个对象的时候，返回这个对象，否则返回用作 this 的那个对象 根据这两个要点，可以用函数来表示 new 操作符的逻辑。 函数表示12345678function newOperator(Constructor, args) { const thisValue = Object.create(Constructor.prototype); const returnValue = Constructor.apply(thisValue, args); if (typeof returnValue === 'object' &amp;&amp; returnValue !== null) { return returnValue; } return thisValue;} 相关要点创建一个继承自特定对象的新对象最简单粗暴的方式是，创建一个对象，并且将原型指向继承的那个对象： 12const newObject = {};newObject.__proto__ = parentObject; 不过 JavaScript 不推荐直接使用 __proto__（下面会说），并且为我们提供了这样一个函数： 1Object.create(proto, [propertiesObject]); 参数： proto - 作为新创建对象的原型的对象 propertiesObject - 可选参数。如果提供，将作为 Object.defineProperties() 的参数来使用 不推荐直接使用 __proto__来自官方文档的警告： 警告：通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性, 这种行为在每一个 JavaScript 引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 obj.__proto__ = ... 语句上, 它还会影响到所有继承来自该 [[Prototype]] 的对象，如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]。相反, 创建一个新的且可以继承 [[Prototype]] 的对象，推荐使用 Object.create()。 警告：当Object.prototype.__proto__ 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在 ECMAScript 2015 规范中被标准化为传统功能，以确保 Web 浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。 Object.prototype 的 __proto__ 属性是一个访问器属性（一个 getter 函数和一个 setter 函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 null)。 简单来说，官方不推荐直接修改或者访问 __proto__ 属性，修改会有性能问题，如果要创建包含继承关系的对象，推荐用 Object.create()，如果要访问原型，建议只使用 Object.getPrototypeOf()。","link":"/2019/05/22/js-new-operator/"},{"title":"JavaScript 中的闭包（Closures）","text":"什么是闭包？哪里用得到闭包？ 闭包是函数和声明该函数的词法环境的组合。 什么是闭包？ 闭包是函数和声明该函数的词法环境的组合。 —- JavaScript Reference 词法作用域考虑如下情况： 123456789function init() { var name = 'Mozilla'; // name 是 init 函数的局部变量 // displayName() 是一个内部函数，是一个闭包 function displayName() { console.log(name); // 使用了外部函数中的变量 } displayName();}init(); 这个例子说明词法作用域的范围，函数的词法作用域包括了函数自身的作用域以及定义该函数的位置的作用域。也就是说，函数可以访问在其上层作用域中定义的变量。 闭包再看一下这个例子： 123456789function makeFunc() { var name = 'Mozilla'; function displayName() { console.log(name); } return displayName;}var myFunc = makeFunc();myFunc(); 在这个例子中，内部函数并没有直接执行，而是被外部函数返回。这个例子在 JavaScript 中是可行的。但是在一些其它的编程语言中，函数中的局部变量仅函数的其执行期可用，一旦函数执行完毕，函数中的局部变量将被销毁。但其实变量销毁的逻辑其实是一样的，都为了节省内存，在变量不可再被访问时，进行销毁。（比如这些语言的局部变量一定是在函数执行完毕就无法再被访问了，又比如一些语言的引用计数方式的 GC） 由于 JavaScript 中的函数会形成闭包，闭包可以访问其外层作用域，所以只要这些函数还能被访问到，外层作用域的变量就不会被销毁。由于我们还持有 myFunc（等同于 displayName，一个可以访问 name 变量的闭包），所以 name 变量不会被销毁。 下面是一个更有意思的例子： 1234567891011function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 在这个例子中，add5 和 add10 共享函数定义，但是各自有不同的词法环境。add5 的环境中，x 为 5，而 add10 中，x 为 10。 闭包的用处闭包是一个很有用的特性，因为他可以将函数和其定义的环境联系起来。这个面向对象编程中，对象允许将其方法和其属性与其它方法联系起来有些相像。 函数工厂在上面那个例子中，我们可以看到闭包的一种用法：函数工厂。根据不同参数，创建行为具有相同规则但是又不相同的函数，例如创建可以修改字体大小的函数，并且绑定到不同事件上面去： 123456789function fontSizeSetter(size) { return function() { document.body.style.fontSize = size + 'px'; };}document.getElementById('font-size-12').onClick = fontSizeSetter(12);document.getElementById('font-size-14').onClick = fontSizeSetter(14);document.getElementById('font-size-16').onClick = fontSizeSetter(16); 模拟私有变量与方法JavaScript 不像 Java 等一些其它语言，JavaScript 无法定义私有的变量或方法（即只能被同一个类访问的变量或方法）。 但是通过闭包，我们可以模拟相同的效果。例如： 123456789101112131415161718192021222324var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } };})();console.log(Counter.value()); // 0Counter.increment();Counter.increment();console.log(Counter.value()); // 2Counter.decrement();console.log(Counter.value()); // 1 这个例子中，Counter 对象有三个方法：increment、decrement 和 value，并且除了这三个方法，没有地方再可以访问 privateCounter 与 changeBy。 像这种通过闭包来定义公共函数，并使其可以访问私有变量和函数的方式，通常被称为模块模式（Module Pattern）。 再举一个更加面向对象一些的例子： 123456789101112131415161718192021222324function Counter(initValue) { var privateCounter = initValue || 0; return { increment() { privateCounter += 1; return this; }, decrement() { privateCounter -= 1; return this; }, get value() { return privateCounter; } };}const counter1 = new Counter();counter1.increment().increment().value; // 2counter1.decrement().value; // 1const counter2 = new Counter(counter1.value);counter2.increment().value; // 2counter2.increment().decrement().value; // 2 运用 class 语法的版本： 123456789101112131415161718class Counter { constructor(initValue = 0) { let privateCounter = initValue; function makeChainableChanger(value) { return function() { privateCounter += value; return this; }; } return { increment: makeChainableChanger(1), decrement: makeChainableChanger(-1), get value() { return privateCounter; } }; }} 闭包的常见错误在 ECMAScript 2015 引入 let 关键字之前，在循环中有一个常见的闭包创建问题。 示例如下： 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 这个例子中，每个循环创建了一个闭包，由于在循环中被创建，这 3 个闭包共享了相同的词法环境（循环的词法环境），在这些闭包被调用时，循环早已结束，词法环境中的 item 已经指向了 helpText 的最后一项。 解决这个问题有很多种办法，比如可以通过引入更多闭包解决： 123456789101112131415161718192021222324function showHelp(help) { document.getElementById('help').innerHTML = help;}function showHelpCallback(item) { return function() { showHelp(item.help); };}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = showHelpCallback(item); }}setupHelp(); 或者使用匿名闭包： 12345678910111213141516171819202122function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { (function() { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; })(); }}setupHelp(); 而更好的方法是，使用 let 关键词将变量声明到块作用域（循环的块作用域是每一次循环独立的）而不是整个循环上。（所以在很多项目的规范中，要求永远不要使用 var 关键词） 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { const helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (let i = 0; i &lt; helpText.length; i++) { let item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 性能考量 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。 —- JavaScript Reference 考虑以下示例： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; };} 在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();}MyObject.prototype.getName = function() { return this.name;};MyObject.prototype.getMessage = function() { return this.message;};","link":"/2019/05/23/js-closures/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"OOJS","slug":"OOJS","link":"/tags/OOJS/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}