{"pages":[],"posts":[{"title":"JavaScript 中的相等性判断","text":"JavaScript 中提供了三种不同的值比较操作： 严格相等（”Strict Equality Comparison”, or “Identity”）：=== 宽松相等（”Abstract Equality Comparision”, or “Loose Equality”）：== 同值判断（”SameValue”）：Object.is（ECMAScript 2015 新特性） 而 ECMAScript 2015 中的相等算法则分为四种： 非严格相等比较（==） 严格相等比较（===），用于 Array.prototype.indexOf，Array.prototype.lastIndexOf 以及 switch...case 同值（Object.is） 同值零（”SameValueZero”），用于 %TypedArray% 和 ArrayBuffer 的构造函数，Map 和 Set 操作，以及 ECMAScript 2016 中的 String.prototype.includes 中 简而言之， == 将进行类型转换并比较 === 不会进行类型转换，比较两个值是否相同（如果类型不同，则总是返回 false） Object.is 的行为与 === 相同，但是对于 NaN，-0 和 +0 进行了特殊处理，Object.is(+0, -0) 为 false，而 Object.is(NaN, NaN) 为 true（根据 IEEE 754, 使用 == 或 === 比较两个 NaN 结果将为 false） “SameValueZero” 与 Object.is 类似，但认为 -0 和 +0 是相等的 而以上这些比较，虽然结果有所区别，但均属于判断两个值是否相同。对于两个不同的非原始对象，以上判断的结果都是 false。 严格相等 ===全等操作符（===）比较两个值是否相等，被比较的值不会进行隐式类型转换，判断逻辑如下： 如果两个值具有不同的类型，则不全等 如果两个值具有相同的类型和值，且不为 number 类型，则全等 如果两个值都是 number 类型，且不为 NaN，且数值相等，则全等 如果两个值都是 NaN，则不全等 如果两个值分别为 +0 和 -0，则全等 在日常使用中 === 几乎总是正确的。 对于数字之外的类型，全等操作符有明确的定义：一个值只与自身相等。 对于数字类型，定义稍加修改： 浮点数 0 是不分正负的，因为除了特定的数学问题，大部分情况都不关心 0 值的正负 浮点数包含 NaN 值，来表示定义不明确的数学问题的解（比如：正负无穷相加），=== 认为 NaN 和任何值都不相等，包括它自己 x !== x 成立的唯一条件就是 x 为 NaN，因此可以用来做 NaN 值判断 ECMA 规范中的定义：Section 11.9.6, The Strict Equality Algorithm 非严格相等 ==相等操作符（==）比较两个值是否相等，比较前将被比较的值转换为相同类型（等式的一边或两边都可能进行转换），然后进行 === 比较。相等操作符满足交换律。判断逻辑如下： 具有不同类型时： 如果两个值为 null 或 undefined，则相等 如果一个值为 null 或 undefined，另一个值为 number 或 string 或 boolean，则不相等 如果一个值为 null 或 undefined，另一个值为 object，则对 object 进行 “IsFalsy” 判断 如果一个值为 object，另一个值为 number 或 string，则对 object 进行 “ToPrimitive” 转换并判断是否全等 如果一个值为 object，另一个值为 boolean，则将 boolean 转换为 number 并对 object 进行 “ToPrimitive” 转换并判断是否全等 如果一个值为 number，另一个值为 string 或 boolean，则将另一个值转换为 number 并判断是否全等 如果一个值为 string，另一个值为 boolean，则都转换为 number 来判断 注： “ToPrimitive” 通过尝试调用 toString() 和 valueOf() 来将对象转换为原始值 转换为 number 的逻辑与一元 + 运算符相同 “IsFalsy” 判断：大部分浏览器允许非常窄的一类对象在某种情况下充当 undefined，仅当这种情况下，”IsFalsy” 判断为 true 有些开发者认为，最好永远都不要使用 ==，因为 == 的结果难以预测，且会进行隐式类型转换，=== 更加容易预测并更加快速。 ECMA 规范中的定义：Section 11.9.3, The Abstract Equality Algorithm 同值相等（”SameValue”）同值相等（”SameValue”）用于判断两个对象是否在任何情况下功能上是相同的，判断逻辑如下： 如果两个值具有不同的类型，则不同值相等 如果两个值具有相同的类型和值，且不为 number 类型，则同值相等 如果两个值都是 number 类型，且不为 NaN，且数值相等，则同值相等 如果两个值都是 NaN，则同值相等（与 === 相反） 如果两个值分别为 +0 和 -0，则不同值相等（与 === 相反） 比如 Object.defineProperty 在试图修改不可变属性的时候，如果值发生变化就会抛出异常，而值没有变化的话则什么都不做。这时就是用同值相等来判断值是否发生了变化。 1234567891011Object.defineProperty(Number, 'NEGATIVE_ZERO', { value: -0, writable: false, configurable: false, enumerable: false});function attemptMutation(v) { Object.defineProperty(Number, 'NEGATIVE_ZERO', { value: v });}attemptMutation(-0); // 不发生任何事情attemptMutation(+0); // 将抛出异常 这个算法在 ES5 中仅用于 JS 引擎的内部，ES6 中通过 Object.is 暴露了这个算法。 ECMA 规范中的定义：Section 9.12, The SameValue Algorithm 同值零相等（”SameValueZero”）同值零相等（”SameValueZero”）与同值相等类似，只是它认为 +0 和 -0 是相等的。 什么时候使用 Object.is？总的来说，除了对待 NaN 的方式不同，Object.is 与 === 的唯一区别就是对待 -0 和 +0 的不同。 下面这些方法和操作符会区别对待 -0 和 +0： 一元负号（Unary -） 一元负号在表达式的使用可能会无意识产生 -0，比如：obj.mass * - obj.velocity，如果 obj.mass 为 0，则会得到一个 -0 Math.atan2 Math.ceil Math.pow Math.round 这些函数即使参数中没有 -0，都有可能产生 -0 的结果 Math.floor Math.max Math.min Math.sin Math.sqrt Math.tan 这些函数当参数中有 -0 时，有可能产生 -0 的结果 ~ &lt;&lt; &gt;&gt; 这些操作符内部都使用了 ToInt32 算法。因为内部的 Int32 类型不区分 0 的正负，-0 在进行了这些操作后，不会保留负号。 因此在未考虑到 0 的符号的情况下使用 Object.is 可能得不到预期的效果。","link":"/2019/05/23/js-equality-and-sameness/"},{"title":"JavaScript 的 new 操作符","text":"JavaScript 的 new 操作符都做了些什么？如何用一个函数来模拟 new 呢？ 官方文档官方文档第一段中的说法： new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单 JavaScript 对象（即 {}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤 1 新创建的对象作为 this 的上下文 ； 如果该函数没有返回对象，则返回 this 。 官方文档在 “描述” 章节中的说法： 当代码 new Foo(...) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 要点根据上面两段描述，可以整理出以下要点： 使用 new 来调用时，构造函数的上下文的 this 是一个新创建的对象，继承自构造函数的原型（prototype） 当构造函数的返回值是一个对象的时候，返回这个对象，否则返回用作 this 的那个对象 根据这两个要点，可以用函数来表示 new 操作符的逻辑。 函数表示12345678function newOperator(Constructor, args) { const thisValue = Object.create(Constructor.prototype); const returnValue = Constructor.apply(thisValue, args); if (typeof returnValue === 'object' &amp;&amp; returnValue !== null) { return returnValue; } return thisValue;} 相关要点创建一个继承自特定对象的新对象最简单粗暴的方式是，创建一个对象，并且将原型指向继承的那个对象： 12const newObject = {};newObject.__proto__ = parentObject; 不过 JavaScript 不推荐直接使用 __proto__（下面会说），并且为我们提供了这样一个函数： 1Object.create(proto, [propertiesObject]); 参数： proto - 作为新创建对象的原型的对象 propertiesObject - 可选参数。如果提供，将作为 Object.defineProperties() 的参数来使用 不推荐直接使用 __proto__来自官方文档的警告： 警告：通过现代浏览器的操作属性的便利性，可以改变一个对象的 [[Prototype]] 属性, 这种行为在每一个 JavaScript 引擎和浏览器中都是一个非常慢且影响性能的操作，使用这种方式来改变和继承属性是对性能影响非常严重的，并且性能消耗的时间也不是简单的花费在 obj.__proto__ = ... 语句上, 它还会影响到所有继承来自该 [[Prototype]] 的对象，如果你关心性能，你就不应该在一个对象中修改它的 [[Prototype]]。相反, 创建一个新的且可以继承 [[Prototype]] 的对象，推荐使用 Object.create()。 警告：当Object.prototype.__proto__ 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在 ECMAScript 2015 规范中被标准化为传统功能，以确保 Web 浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。 Object.prototype 的 __proto__ 属性是一个访问器属性（一个 getter 函数和一个 setter 函数）, 暴露了通过它访问的对象的内部[[Prototype]] (一个对象或 null)。 简单来说，官方不推荐直接修改或者访问 __proto__ 属性，修改会有性能问题，如果要创建包含继承关系的对象，推荐用 Object.create()，如果要访问原型，建议只使用 Object.getPrototypeOf()。","link":"/2019/05/22/js-new-operator/"},{"title":"JavaScript 中的闭包（Closures）","text":"什么是闭包？哪里用得到闭包？ 闭包是函数和声明该函数的词法环境的组合。 什么是闭包？ 闭包是函数和声明该函数的词法环境的组合。 —- JavaScript Reference 词法作用域考虑如下情况： 123456789function init() { var name = 'Mozilla'; // name 是 init 函数的局部变量 // displayName() 是一个内部函数，是一个闭包 function displayName() { console.log(name); // 使用了外部函数中的变量 } displayName();}init(); 这个例子说明词法作用域的范围，函数的词法作用域包括了函数自身的作用域以及定义该函数的位置的作用域。也就是说，函数可以访问在其上层作用域中定义的变量。 作用域对象每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它和被传入函数的变量一起被初始化。这与那些保存的所有全局变量和函数的全局对象（global object）类似，但仍有一些很重要的区别，第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；第二，与全局对象（在浏览器里面是当做 window 对象来访问的）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有可以遍历当前的作用域对象里面属性的方法。 一个闭包就是一个函数和其外层函数的作用域对象的组合。 闭包再看一下这个例子： 123456789function makeFunc() { var name = 'Mozilla'; function displayName() { console.log(name); } return displayName;}var myFunc = makeFunc();myFunc(); 在这个例子中，内部函数并没有直接执行，而是被外部函数返回。这个例子在 JavaScript 中是可行的。但是在一些其它的编程语言中，函数中的局部变量仅函数的其执行期可用，一旦函数执行完毕，函数中的局部变量将被销毁。但其实变量销毁的逻辑其实是一样的，都为了节省内存，在变量不可再被访问时，进行销毁。（比如这些语言的局部变量一定是在函数执行完毕就无法再被访问了，又比如一些语言的引用计数方式的 GC） 由于 JavaScript 中的函数会形成闭包，闭包可以访问其外层作用域，所以只要这些函数还能被访问到，外层作用域的变量就不会被销毁。由于我们还持有 myFunc（等同于 displayName，一个可以访问 name 变量的闭包），所以 name 变量不会被销毁。 下面是一个更有意思的例子： 1234567891011function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 在这个例子中，add5 和 add10 共享函数定义，但是各自有不同的词法环境。add5 的环境中，x 为 5，而 add10 中，x 为 10。 闭包的用处闭包是一个很有用的特性，因为他可以将函数和其定义的环境联系起来。这个面向对象编程中，对象允许将其方法和其属性与其它方法联系起来有些相像。 函数工厂在上面那个例子中，我们可以看到闭包的一种用法：函数工厂。根据不同参数，创建行为具有相同规则但是又不相同的函数，例如创建可以修改字体大小的函数，并且绑定到不同事件上面去： 123456789function fontSizeSetter(size) { return function() { document.body.style.fontSize = size + 'px'; };}document.getElementById('font-size-12').onClick = fontSizeSetter(12);document.getElementById('font-size-14').onClick = fontSizeSetter(14);document.getElementById('font-size-16').onClick = fontSizeSetter(16); 模拟私有变量与方法JavaScript 不像 Java 等一些其它语言，JavaScript 无法定义私有的变量或方法（即只能被同一个类访问的变量或方法）。 但是通过闭包，我们可以模拟相同的效果。例如： 123456789101112131415161718192021222324var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } };})();console.log(Counter.value()); // 0Counter.increment();Counter.increment();console.log(Counter.value()); // 2Counter.decrement();console.log(Counter.value()); // 1 这个例子中，Counter 对象有三个方法：increment、decrement 和 value，并且除了这三个方法，没有地方再可以访问 privateCounter 与 changeBy。 像这种通过闭包来定义公共函数，并使其可以访问私有变量和函数的方式，通常被称为模块模式（Module Pattern）。 再举一个更加面向对象一些的例子： 123456789101112131415161718192021222324function Counter(initValue) { var privateCounter = initValue || 0; return { increment() { privateCounter += 1; return this; }, decrement() { privateCounter -= 1; return this; }, get value() { return privateCounter; } };}const counter1 = new Counter();counter1.increment().increment().value; // 2counter1.decrement().value; // 1const counter2 = new Counter(counter1.value);counter2.increment().value; // 2counter2.increment().decrement().value; // 2 运用 class 语法的版本： 123456789101112131415161718class Counter { constructor(initValue = 0) { let privateCounter = initValue; function makeChainableChanger(value) { return function() { privateCounter += value; return this; }; } return { increment: makeChainableChanger(1), decrement: makeChainableChanger(-1), get value() { return privateCounter; } }; }} 闭包的常见错误在 ECMAScript 2015 引入 let 关键字之前，在循环中有一个常见的闭包创建问题。 示例如下： 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 这个例子中，每个循环创建了一个闭包，由于在循环中被创建，这 3 个闭包共享了相同的词法环境（循环的词法环境），在这些闭包被调用时，循环早已结束，词法环境中的 item 已经指向了 helpText 的最后一项。 解决这个问题有很多种办法，比如可以通过引入更多闭包解决： 123456789101112131415161718192021222324function showHelp(help) { document.getElementById('help').innerHTML = help;}function showHelpCallback(item) { return function() { showHelp(item.help); };}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = showHelpCallback(item); }}setupHelp(); 或者使用匿名闭包： 12345678910111213141516171819202122function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (var i = 0; i &lt; helpText.length; i++) { (function() { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; })(); }}setupHelp(); 而更好的方法是，使用 let 关键词将变量声明到块作用域（循环的块作用域是每一次循环独立的）而不是整个循环上。（所以在很多项目的规范中，要求永远不要使用 var 关键词） 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { const helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' } ]; for (let i = 0; i &lt; helpText.length; i++) { let item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); }; }}setupHelp(); 性能考量 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。 —- JavaScript Reference 考虑以下示例： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; };} 在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();}MyObject.prototype.getName = function() { return this.name;};MyObject.prototype.getMessage = function() { return this.message;};","link":"/2019/05/23/js-closures/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"OOJS","slug":"OOJS","link":"/tags/OOJS/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}